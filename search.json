[{"title":"Day01-Go結構體與方法詳解","path":"/2025/03/13/Day01-Go結構體與方法詳解/","content":"Go 結構體與方法詳解結構體基礎Go 語言使用結構體(struct)作為組織和封裝資料的主要方式。相較於其他語言的類(Class)，Go的結構體更加輕量且直觀。 分離檔案結構在真實專案中，我們通常將結構體定義和主函數分開： room.go: 包含結構體定義和相關方法 main.go: 主程式，引用並使用結構體 這種分離可以提高程式的可維護性和可讀性。 結構體標籤詳解在 room.go 中，我們看到這樣的定義： 1234type Room struct &#123; ID int `json:&quot;id&quot;` // 其他欄位...&#125; json:&quot;id&quot; 是結構體標籤(struct tag)，它們是附加在結構體欄位上的元數據： 標籤格式: 反引號(&#96;) 包裹的字串 標籤用途: 主要用於運行時反射機制 常見標籤: json:&quot;欄位名&quot;: 指定JSON序列化&#x2F;反序列化時使用的欄位名 db:&quot;欄位名&quot;: 常用於資料庫ORM form:&quot;欄位名&quot;: 常用於HTTP表單解析 標籤選項標籤還可以包含選項，例如： 1Notes string `json:&quot;notes,omitempty&quot;` omitempty 選項表示：如果該欄位為零值(空字串、0、false等)，則在JSON序列化時省略此欄位。 標籤的作用當使用 json.Marshal() 序列化 Room 結構體時： 12room := Room&#123;ID: 1, Number: &quot;101&quot;&#125;jsonData, _ := json.Marshal(room) 輸出的JSON會根據標籤變成： 1&#123;&quot;id&quot;:1,&quot;room_number&quot;:&quot;101&quot;,...&#125; 而不是： 1&#123;&quot;ID&quot;:1,&quot;Number&quot;:&quot;101&quot;,...&#125; 這對API開發極其重要，可以保持JSON欄位名的一致風格，同時內部代碼可以遵循Go的命名規範。 值接收器方法詳解在 room.go 中定義了幾個使用值接收器的方法： 123func (r Room) Info() string &#123; // 方法實現...&#125; 讓我們深入理解值接收器方法： 值接收器的工作原理 接收器宣告: (r Room) 表示此方法附加到 Room 類型 參數傳遞: Go 使用值複製，方法內的 r 是原始結構體的副本 調用方式: room.Info() 會複製 room 到方法的 r 參數 值接收器的特性 不改變原始值: 1234567func (r Room) SetAvailable(available bool) &#123; r.Available = available // 只改變副本&#125;room := Room&#123;Available: true&#125;room.SetAvailable(false)fmt.Println(room.Available) // 仍然是 true 方法接收者是副本:每次調用方法都會創建結構體的完整副本，對於大型結構體可能影響性能 適合不修改狀態的操作: 123func (r Room) CalculateTotalPrice(nights int) float64 &#123; return r.Price * float64(nights)&#125; 方法鏈不可行:由於操作的是副本，無法實現有效的方法鏈 值接收器的最佳實踐 使用於小型結構體:結構體較小時，複製的開銷較低 用於讀取操作: 12func (r Room) Info() string &#123;...&#125;func (r Room) CalculateTotalPrice(nights int) float64 &#123;...&#125; 不可變性設計:值接收器方法保證不修改原結構體，提高程式可預測性 線程安全考量:每個線程操作的是獨立副本，避免共享狀態問題 使用案例分析讓我們分析 Room 結構體的幾個值接收器方法： Info() 方法1234func (r Room) Info() string &#123; return fmt.Sprintf(&quot;Room %s (Type: %s) - $%.2f per night, Capacity: %d persons&quot;, r.Number, r.Type, r.Price, r.Capacity)&#125; 目的: 格式化輸出房間信息 為何使用值接收器: 純讀取操作，不需修改結構體 CalculateTotalPrice() 方法123func (r Room) CalculateTotalPrice(nights int) float64 &#123; return r.Price * float64(nights)&#125; 目的: 計算特定住宿天數的總價 為何使用值接收器: 純計算，基於現有屬性，無需修改結構體 DaysSinceLastCleaning() 方法123func (r Room) DaysSinceLastCleaning() int &#123; return int(time.Since(r.LastCleaned).Hours() / 24)&#125; 目的: 計算自上次清潔以來的天數 為何使用值接收器: 純計算，不修改狀態 NeedsCleaning() 方法123func (r Room) NeedsCleaning() bool &#123; return r.DaysSinceLastCleaning() &gt;= 1&#125; 目的: 檢查房間是否需要清潔 為何使用值接收器: 基於其他方法的計算結果，不修改狀態 延伸學習資源 Go 官方文件: 方法 詳解 Go 中的方法接收器選擇 Go 序列化標籤的進階用法","tags":["Golang"],"categories":["Golang學習"]},{"title":"Day-06-Deploy-https-website-part01","path":"/2023/10/01/Day-06-Deploy-https-website/","content":"IngressIngress 是對 Cluster 中服務的外部存取進行管理的 API 對象，典型的存取方式是 HTTP Ingress Example123456789101112131415161718apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: minimal-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: ingressClassName: nginx-example rules: - http: paths: - path: /testpath pathType: Prefix backend: service: name: test port: number: 80 Ingress 需要指定 apiVersion、kind、 metadata和 spec Ingress rules host: Optional - 若沒有設定 host 的話則代表所有 http request, 若是有設定 host 則代表描述的是該 host 的規則 path 列表 - 每一個 path 可以指向不同 或是同一個 service service name 則需要對應到每一個 Service 的名稱 路徑類型Ingress 中的每個路徑都需要有對應的路徑類型（Path Type） 未明確設定 pathType 的路徑無法通過合法性檢查。目前支援的路徑類型有三種 ImplementationSpecific： 對於這種路徑類型，匹配方法取決於 IngressClass。具體實作可以將其作為單獨的 pathType 處理或作與 Prefix 或 Exact 類型相同的處理 Exact：精確匹配 URL 路徑，且區分大小寫 Prefix：基於以 / 分隔的 URL 路徑前綴匹配。匹配區分大小寫， 並且對路徑中各個元素逐一執行匹配操作。路徑元素指的是由 / 分隔符號分隔的路徑中的標籤清單。如果每個 p 都是請求路徑 p 的元素前綴，則請求與路徑 p 相符。 12Note： 如果路徑的最後一個元素是請求路徑中最後一個元素的子字串，則不會被視為符合（例如：/foo/bar 符合 /foo/bar/baz, 但不符合 /foo/barbaz） 萬用字符號主機名稱可以是精確匹配（例如 “foo.bar.com”）或使用通配符來匹配 （例如 “*.foo.com”） 精確比對要求 HTTP host 頭部欄位與 host 欄位值完全相符 通配符匹配則要求 HTTP host 頭部欄位與通配符規則中的後綴部分相同 1234567891011121314151617181920212223242526apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: ingress-wildcard-hostspec: rules: - host: &quot;foo.bar.com&quot; http: paths: - pathType: Prefix path: &quot;/bar&quot; backend: service: name: service1 port: number: 80 - host: &quot;*.foo.com&quot; http: paths: - pathType: Prefix path: &quot;/foo&quot; backend: service: name: service2 port: number: 80","tags":["DevOps","IThome2023","Docker","Kubernetes"],"categories":["IThome2023鐵人賽"]},{"title":"Day-05-ingress-controller","path":"/2023/09/20/Day-05-ingress-controller/","content":"Ingress ControllerIngress 是進入的意思 在 Kubernetes 中也是代表著進入 Cluster 的流量 Egress 則代表退出 Cluster 的流量 Ingress 是原生的 Kubernetes 的資源 使用 Ingress 可以維護 DNS routing 設定 如果沒有使用 Kubernetes Ingress 你需要增加一個 Loadbalancer 若是使用 Ingress 的話 如下圖 Note: AWS GCP 雲端 Ingress Controller 的實作略有不同。例如，AWS loadbalancer 充當入口控制器。GKE Ingress Setup 在 Kubernetes Ingress 穩定前可以先用 Nginx 或是 HAproxy kubernetes 將流量導入 Cluster Kubernetes Ingress 如何作用主要有兩個概念 Kubernetes Ingress 資源: Kubernetes Ingress 負責 Cluster 中的 DNS Routing 規則 Kubernetes Ingress Controller: Kubernetes 入口控制器（Nginx&#x2F;HAProxy 等）負責透過存取入口資源應用的 DNS 規則來進行路由 image3 實際範例hello-one.yaml 12345678910111213141516171819202122232425262728293031apiVersion: v1kind: Servicemetadata: name: hello-onespec: type: ClusterIP ports: - port: 80 targetPort: 80 selector: app: hello-one---apiVersion: apps/v1kind: Deploymentmetadata: name: hello-onespec: replicas: 3 selector: matchLabels: app: hello-one template: metadata: labels: app: hello-one spec: containers: - name: hello-ingress image: nginxdemos/hello ports: - containerPort: 80 hello-two.yaml 12345678910111213141516171819202122232425262728293031apiVersion: v1kind: Servicemetadata: name: hello-twospec: type: ClusterIP ports: - port: 80 targetPort: 80 selector: app: hello-two---apiVersion: apps/v1kind: Deploymentmetadata: name: hello-twospec: replicas: 3 selector: matchLabels: app: hello-two template: metadata: labels: app: hello-two spec: containers: - name: hello-ingress image: nginxdemos/hello ports: - containerPort: 80 my-new-ingress.yaml 1234567891011121314151617181920212223242526272829apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: my-new-ingress annotations: kubernetes.io/ingress.class: nginxspec: rules: - host: hello-one.tomas.website http: paths: - pathType: Prefix path: &quot;/&quot; backend: service: name: hello-one port: number: 80 - host: hello-two.tomas.website http: paths: - pathType: Prefix path: &quot;/&quot; backend: service: name: hello-two port: number: 80 完成之後可以打開頁面 hello-one.tomas.website hello-two.tomas.website 明天再來繼續聊聊 Ingress Controller","tags":["DevOps","IThome2023","Docker","Kubernetes"],"categories":["IThome2023鐵人賽"]},{"title":"Day-04-Deploy-to-cluster","path":"/2023/09/19/Day-04-Deploy-to-cluster/","content":"Deploy to Cluster on LKE建立一個 app 的資料夾 123$ mkdir app$ mv ./* ./app$ mkdir manifests 建立一個 static-site-deployment.yaml 檔案 12345678910111213141516171819202122apiVersion: apps/v1kind: Deploymentmetadata: name: static-site-deployment labels: app: static-sitespec: replicas: 3 selector: matchLabels: app: static-site template: metadata: labels: app: static-site spec: containers: - name: static-site image: horsekit1982/lke-example:v1.0.0 imagePullPolicy: Always ports: - containerPort: 80 Deployments 描述 Pod 和 ReplicaSet 建立一個名為 static-site-deployment 的 Deployment (以 .metadata.name) 會以這個名稱為基礎 建立 ReplicaSet 和 Pod 此 Deployment 建立一個 ReplicaSet 會由三個 (.spec.replicas) Pod 副本 .spec.selector 描述了 ReplicaSet 如何尋找要管理的 Pod 在上面的範例中選擇 Pod 中定義的標籤(app: static-site) Note: .spec.selector.matchLabels 欄位是 &#123;key,value&#125; 鍵值對映射。在 matchLabels 映射中的每個 &#123;key,value&#125; 映射等效於 matchExpressions 中的一個元素， 即其 key 字段是 “key”，operator 為 “In”，values 數組僅包含 “value”。在 matchLabels 和 matchExpressions 中給出的所有條件都必須滿足才能匹配。 template 自斷包含 Pod 使用 .metadata.labels 欄位打上 app: nginx 標籤 Pod 範本規約（即 .template.spec 欄位）指示 Pod 執行 static-site 容器 建立容器並使用 .spec.template.spec.containers[0].name 欄位將其命名為 static-site 建立一個 static-site-service.yaml 檔案 12345678910111213141516171819apiVersion: v1kind: Servicemetadata: name: static-site-service namespace: react-site annotations: service.beta.kubernetes.io/linode-loadbalancer-throttle: &quot;4&quot; labels: app: static-sitespec: type: LoadBalancer ports: - name: http port: 80 protocol: TCP targetPort: 80 selector: app: static-site sessionAffinity: None Kubernetes 中 Service 的一個關鍵目標是讓你無需修改現有應用程式以使用某種不熟悉的服務發現機制。 你可以在 Pod 集合中運行程式碼，無論程式碼是為雲端原生環境設計的， 還是被容器化的舊應用程式 你可以使用 Service 讓一組 Pod 在網路上訪問，這樣客戶端就能與之互動 上面的範例建立了一個 static-site-service 的服務 Port 是 80 Note: Service 能夠將任意入站 port 對應到某個 targetPort。預設情況下，出於方便考慮，targetPort 會被設定為與 port 欄位相同的值 也可以有另外一種範例 123456789101112131415161718192021222324252627apiVersion: v1kind: Podmetadata: name: nginx labels: app.kubernetes.io/name: proxyspec: containers: - name: nginx image: nginx:stable ports: - containerPort: 80 name: http-web-svc---apiVersion: v1kind: Servicemetadata: name: nginx-servicespec: selector: app.kubernetes.io/name: proxy ports: - name: name-of-service-port protocol: TCP port: 80 targetPort: http-web-svc 在上述範例中 targetPort 指定是 http-web-svc 會指定到 Pod 的 port 80","tags":["DevOps","IThome2023","Docker","Kubernetes"],"categories":["IThome2023鐵人賽"]},{"title":"Day-03-Container","path":"/2023/09/18/Day-03-Static-Site-Container/","content":"Create React App是一個自動化建立一個簡單的 React 的工具 利用這個工具產生一個靜態的檔案 再利用 docker 打包成 Image 並且以 container 跑起來 可以利用網頁瀏覽器瀏覽 Initial React Project1234$ npx create-react-app lke-example$ cd lke-example$ npm install$ npm start DockerfileDockerfile 12345678910111213FROM node:18.0-slim as FrontendWORKDIR /appCOPY . /appRUN npm installRUN npm run buildFROM nginx:stable-alpineRUN mv /usr/share/nginx/html/index.html /usr/share/nginx/html/old-index.htmlCOPY --from=Frontend /app/build/ /usr/share/nginx/html/EXPOSE 80 昨天有解釋一些參數 今天又多了一些新的參數 FROM node:18.0-slim as Frontend 這一個 image 基於 node:18.0-slim 產生後命名為 Frontend COPY --from=Frontend /app/build/ /usr/share/nginx/html/ 將 Frontend 的 image 複製 /app/build/ 的檔案到 Nginx 的 /usr/share/nginx/html/ Build Image1$ docker build -t lke-example . 成功後會有多一個 lke-example 的 image Run a Container From lke-example1$ docker run -p 8080:80 -d lke-example localhost 這時候就可以看到頁面 Push 到 Docker Hub12$ docker login # 登入$ docker push lke-example ## 這時候可能會錯誤 Trouble shottingdenied: requested access to the resource is denied 如果看到這個錯誤 要給予這個 image 一個 tag 1$ docker tag lke-example $&#123;docker hub name&#125;/lke-example:v1.0.0 之後再做 push 就可以了 推上去之後 明天再來處理 deploy 到 k8s 上","tags":["DevOps","IThome2023","Docker","Kubernetes"],"categories":["IThome2023鐵人賽"]},{"title":"Day-02-Express與Docker","path":"/2023/09/15/Day-02-Express與Docker/","content":"Express Hello worldExpress 4.x 1234$ express --no-view helloworlddemo$ cd helloworlddemo$ npm install$ npm start 檔案結構123456789101112131415.├── app.js├── bin│ └── www├── package-lock.json├── package.json├── public│ ├── images│ ├── index.html│ ├── javascripts│ └── stylesheets│ └── style.css└── routes ├── index.js └── users.js 以這個範例實作 Dockerfile 123456FROM node:18.0-slimWORKDIR /appCOPY . .RUN npm installEXPOSE 3000CMD [&quot;node&quot;, &quot;app.js&quot;] FROM 宣告基本的 Docker Image 環境 node:18.0-slim 詳情 以 Debian:11-slim 為基礎 Nodejs 版本 為 18 的環境 WORKDIR 設定工作的資料夾位置 COPY 將檔案複製到 Docker Image 內的 WORKDIR 資料夾內 COPY SOURCE TARGET Note: COPY和ADD二個的功用都一樣，就是將檔案複製進去image裡，COPY只能複製本機端的檔案或目錄，ADD能增加遠端url的檔案到docker image，ADD能順手將本機端複製進去的tar檔解開(遠端的tar不行！)。在實例上並不建議使用ADD來抓取網路上的檔案，會使用RUN curl or wget的方式。原因是使用一次ADD指令會增加docker image layers一次，原則上layers越多，docker image size就會越大！ RUN 建立image內部再跑的指令，是跑在Linux裡面的，跟ENTRYPOING與CMD最大的不同就是，他不是作為Image的「啟動指令」，而是作為image的「建造指令」 EXPOSE 很多人以為加上EXPOSE 3000，docker run起來後，就可以從本機端連得到container的 3000 port。 EXPOSE概念上比較像是在告訴使用這個image的人，服務是在那個port。 123$ docker pull nginx$ docker inspect nginx$ docker run -p 8888:3000 -d nginx CMD 在 Container 運行的時候 執行此命令 Note: ENTRYPOINT是Dockerfile 定義的一個指令，他的作用類似於CMD，都是在container 啟動時會自動執行的指令，你可以不定義CMD，然後改成定義ENTRYPOINT，你的container 照樣能夠啟動，如同你之前將命令寫在CMD 一樣","tags":["DevOps","IThome2023","Docker","Kubernetes"],"categories":["IThome2023鐵人賽"]},{"title":"Day-01-Docker簡介","path":"/2023/09/15/Day-01-Docker簡介/","content":"簡介Docker 大致上可以分為 Image, Container, Registry 三個基本概念 Image - 是一個唯讀的完整操作系統環境，裡面僅僅安裝了必要的應用程序和支援程式． 它是一個模板 Container - 容器，鏡像運行時的實體，可以用一個image去啟動多個container，這些container是獨立的，互相不會干涉，我們對任何一個container做的改變，只會對那個container造成影響。 Registry - 如果是熟悉Git的，其實這裡說的Registry就是Git所說的Repository，只是跟Git repository不同的，Git repository是存放原始碼的，但是Docker registry是存放Docker images的．Docker跟Git的指令也有相似之處，譬如說push和pull，可以把 images 從Docker registry上傳或下載，概念是這樣，先有個大概的認識，之後就可以慢慢來實作了。 Docker Wiki 過往在做部署的時候總是一台 機器會架設多個服務， 服務之間的環境設定 或是套件 服務的版本會有所衝突 常常造成一些奇怪的問題 Docker 可以將環境單純化 盡量降低因為環境因素影響服務運行","tags":["DevOps","IThome2023","Docker","Kubernetes"],"categories":["IThome2023鐵人賽"]},{"title":"React Native-fastlane-Android","path":"/2020/12/26/ReactNative-fastlane-Android/","content":"Fastlane Install1234$ bundle config set path &#x27;vendor/bundle&#x27;$ cd android$ bundle install$ bundle exec fastlane init Build AndroidFastFile 1234567891011121314151617181920default_platform(:android)platform :android do desc &quot;Runs all the tests&quot; lane :test do gradle(task: &quot;test&quot;) end desc &quot;Submit a new Beta Build to Crashlytics Beta&quot; lane :beta do gradle(task: &quot;clean assembleRelease&quot;) # crashlytics gradle( task: &#x27;assemble&#x27;, build_type: &#x27;Release&#x27; ) # sh &quot;your_script.sh&quot; # You can also use other beta testing services here endend 可能會有錯誤 Expiring Daemon because JVM heap space is exhausted Solution~&#x2F;.gradle&#x2F;gradle.properties 123org.gradle.daemon=trueorg.gradle.configureondemand=trueorg.gradle.jvmargs=-Xmx4g -XX:MaxPermSize=2048m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 .&#x2F;android&#x2F;app&#x2F;build.gradle 1234567...android &#123; dexOptions &#123; javaMaxHeapSize &quot;3g&quot; &#125;&#125;... Distribution with firebaseinstall plugin1$ bundle exec fastlane add_plugin firebase_app_distribution login1$ bundle exec fastlane run firebase_app_distribution_login 修改 Fastfile1234567891011121314151617181920212223default_platform(:android)platform :android do desc &quot;Runs all the tests&quot; lane :test do gradle(task: &quot;test&quot;) end desc &quot;Submit a new Beta Build to Crashlytics Beta&quot; lane :beta do gradle(task: &quot;clean assembleRelease&quot;) # crashlytics gradle( task: &#x27;assemble&#x27;, build_type: &#x27;Release&#x27; ) firebase_app_distribution( app: &quot;firebase app project id&quot;, groups: &quot;firebase test groups&quot; ) endend 1$ bundle exec fastlane beta 參考資料Expiring Daemon because JVM heap space is exhausted","tags":["Javascript","React Native"],"categories":["React Native"]},{"title":"React-Native-Fastlane-IOS","path":"/2020/10/12/React-Native-Fastlane-IOS/","content":"Setting Up fastlaneInstall Homebrew1234$ /usr/bin/ruby -e \\&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;$ brew update &amp;&amp; brew install ruby$ brew link --overwrite ruby 重新啟動 Terminal 123456$ sudo gem install bundler$ xcode-select --install$ sudo gem install -n /usr/local/bin fastlane --verbose$ brew cask install fastlane$ npx react-native init rndemo$ cd rndemo/ios add to .zshrc 12export LC_ALL=en_US.UTF-8export LANG=en_US.UTF-8 Gemfile 123source &quot;https://rubygems.org&quot;gem &quot;fastlane&quot; 12$ sudo gem install bundler$ bundle exec fastlane init screenshots distribution to beta testing services automate the App Store release process setup code signing with fastlane 依據上述的 tutorial 就可以完成相對應的工作","tags":["Javascript","React Native"],"categories":["React Native"]},{"title":"React-create-rxdb-example","path":"/2020/10/09/React-create-rxdb-example/","content":"Install and Initial12$ npx create-react-app rxdbdemo$ npm install --save concurrently moment pouchdb-adapter-http pouchdb-adapter-idb pouchdb-server react-toastify rxdb rxjs serve package.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;name&quot;: &quot;rxdbdemo&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: &#123; &quot;@testing-library/jest-dom&quot;: &quot;^4.2.4&quot;, &quot;@testing-library/react&quot;: &quot;^9.3.2&quot;, &quot;@testing-library/user-event&quot;: &quot;^7.1.2&quot;, &quot;concurrently&quot;: &quot;^5.3.0&quot;, &quot;moment&quot;: &quot;^2.29.1&quot;, &quot;pouchdb-adapter-http&quot;: &quot;^7.2.2&quot;, &quot;pouchdb-adapter-idb&quot;: &quot;^7.2.2&quot;, &quot;pouchdb-server&quot;: &quot;^4.2.0&quot;, &quot;react&quot;: &quot;^16.13.1&quot;, &quot;react-dom&quot;: &quot;^16.13.1&quot;, &quot;react-scripts&quot;: &quot;3.4.3&quot;, &quot;react-toastify&quot;: &quot;^6.0.9&quot;, &quot;rxdb&quot;: &quot;^9.6.0&quot;, &quot;rxjs&quot;: &quot;^6.6.3&quot;, &quot;serve&quot;: &quot;^11.3.2&quot; &#125;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;concurrently \\&quot;npm run server\\&quot; \\&quot;react-scripts start\\&quot;&quot;, &quot;server&quot;: &quot;pouchdb-server -d ./db&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;, &quot;eslintConfig&quot;: &#123; &quot;extends&quot;: &quot;react-app&quot; &#125;, &quot;browserslist&quot;: &#123; &quot;production&quot;: [ &quot;&gt;0.2%&quot;, &quot;not dead&quot;, &quot;not op_mini all&quot; ], &quot;development&quot;: [ &quot;last 1 chrome version&quot;, &quot;last 1 firefox version&quot;, &quot;last 1 safari version&quot; ] &#125;&#125; 1$ yarn start 會開啟一個本地的 db 可以透過 pounch-db Create Schemasrc&#x2F;Schema.js 123456789101112131415161718const schema = &#123; title: &#x27;Anonymous chat schema&#x27;, description: &#x27;Database schema for an anonymous chat&#x27;, version: 0, type: &#x27;object&#x27;, properties: &#123; id: &#123; type: &#x27;string&#x27;, primary: true &#125;, message: &#123; type: &#x27;string&#x27; &#125; &#125;, required: [&#x27;message&#x27;]&#125;export default schema; App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import React, &#123; useEffect, useRef, useState &#125; from &quot;react&quot;;import logo from &quot;./logo.svg&quot;;import &quot;./App.css&quot;;import &#x27;react-toastify/dist/ReactToastify.css&#x27;;import &#123; ToastContainer, toast &#125; from &quot;react-toastify&quot;;import * as moment from &quot;moment&quot;;import * as RxDB from &quot;rxdb&quot;;import schema from &quot;./Schema&quot;;let localdb = null;const dbName = &quot;test&quot;;const syncURL = &quot;http://localhost:5984/&quot;;RxDB.addRxPlugin(require(&quot;pouchdb-adapter-idb&quot;));RxDB.addRxPlugin(require(&quot;pouchdb-adapter-http&quot;));const createDatabase = async () =&gt; &#123; try &#123; const db = await RxDB.createRxDatabase(&#123; name: dbName, adapter: &quot;idb&quot;, password: &quot;12345678&quot;, &#125;); db.waitForLeadership().then(() =&gt; &#123; document.title = &quot;♛ &quot; + document.title; &#125;); const messagesCollection = await db.collection(&#123; name: &quot;messages&quot;, schema: schema, &#125;); messagesCollection.sync(&#123; remote: syncURL + dbName + &quot;/&quot; &#125;); console.log(&quot;createDatabase -&gt; messagesCollection&quot;, messagesCollection); return db; &#125; catch (error) &#123; console.log(&quot;createDatabase -&gt; error&quot;, error); &#125;&#125;;const addMessage = async (message, setNewMessage) =&gt; &#123; console.log(&quot;addMessage -&gt; localdb&quot;, localdb) const id = Date.now().toString(); const newMessage = &#123; id, message &#125;; await localdb.messages.insert(newMessage); setNewMessage(&quot;&quot;);&#125;;const renderMessages = (messages) =&gt; messages.map((&#123; id, message &#125;) =&gt; &#123; const date = moment(id, &#x27;x&#x27;).fromNow(); return ( &lt;div key=&#123;id&#125;&gt; &lt;p&gt;&#123;date&#125;&lt;/p&gt; &lt;p&gt;&#123;message&#125;&lt;/p&gt; &lt;hr /&gt; &lt;/div&gt; ) &#125;);function App() &#123; let dbRef = useRef(null); const [messages, setMessages] = useState([]); const [subs, setSubs] = useState([]); const [newMessage, setNewMessage] = useState(&quot;&quot;); useEffect(() =&gt; &#123; createDatabase().then((db) =&gt; &#123; localdb = db; const sub = db.messages .find() .sort(&#123; id: 1 &#125;) .$.subscribe((msgs) =&gt; &#123; if (!msgs) return; toast(&quot;Reloading messages&quot;); setMessages(msgs); &#125;); setSubs([...subs, sub]); &#125;); return () =&gt; &#123; subs.forEach((sub) =&gt; sub.unsubscribe()); &#125;; &#125;, []); return ( &lt;div className=&quot;App&quot;&gt; &lt;ToastContainer autoClose=&#123;3000&#125; /&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;div&gt;&#123;renderMessages(messages)&#125;&lt;/div&gt; &lt;div id=&quot;add-message-div&quot;&gt; &lt;h3&gt;Add Message&lt;/h3&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Message&quot; value=&#123;newMessage&#125; onChange=&#123;(env) =&gt; setNewMessage(env.target.value)&#125; /&gt; &lt;button onClick=&#123;() =&gt; addMessage(newMessage, setNewMessage)&#125;&gt; Add message &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default App;","tags":["Javascript","React Native"],"categories":["React"]},{"title":"React-Native-Cache-PartII","path":"/2020/10/07/React-Native-Cache-PartII/","content":"建立雙向鍊表的 Class123456789101112131415161718192021222324252627282930313233343536373839class Node &#123; constructor(data) &#123; this.data = data; this.prev = null; this.next = null; &#125;&#125;class DoubleLinklist &#123; constructor() &#123; this.head = null; this.tail = null; this.length = 0; &#125; append(data)&#123; const newNode = new Node(data); console.log(&#x27;this.length&#x27;, this.length); console.log(&#x27;this&#x27;, this); if (this.length === 0) &#123; this.tail = newNode; this.head = newNode; &#125; else &#123; newNode.prev = this.tail; this.tail.next = newNode; this.tail = newNode; &#125; this.length += 1; &#125;;&#125;let list = new DoubleLinklist();list.append(&#x27;aaa&#x27;);list.append(&#x27;bbb&#x27;);list.append(&#x27;ccc&#x27;);console.log(list); 情境一 情境二 結果 next prev 完整範例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173class Node &#123; constructor(data) &#123; this.data = data; this.prev = null; this.next = null; &#125;&#125;class DoubleLinklist &#123; constructor() &#123; this.head = null; this.tail = null; this.length = 0; &#125; toString() &#123; return this.backwardString(); &#125; forwardString() &#123; let current =this.tail; let resultString = &quot;&quot;; while (current) &#123; resultString += current.data + &quot;--&quot;; current = current.prev; &#125; return resultString; &#125; backwardString() &#123; let current = this.head; let resultString = &quot;&quot;; while (current) &#123; resultString += current.data + &quot;--&quot;; current = current.next; &#125; return resultString; &#125; indexOf(data)&#123; let current = this.head; let index = 0; while(current)&#123; if (current.data == data) &#123; return index; &#125; current = current.next; index += 1; &#125; return -1; &#125; removeAt(position)&#123; if (position &lt; 0 || position &gt;= this.length) &#123; return null; &#125; let current = this.head; if (this.length == 1) &#123; this.head = null; this.tail = null; &#125; else&#123; if (position == 0) &#123; this.head.next.prev = null; this.head = this.head.next; &#125;else if(position == this.length - 1)&#123; current = this.tail; this.tail.prev.next = null; this.tail = this.tail.prev; &#125;else&#123; let index = 0; while(index++ &lt; position)&#123; current = current.next; &#125; current.next.prev = current.prev; current.prev.next = current.next; &#125; &#125; this.length -= 1; return current.data; &#125; remove(data) &#123; const index = this.indexOf(data); return this.removeAt(index); &#125; isEmpty()&#123; return this.length == 0; &#125; size() &#123; return this.length; &#125; getHead()&#123; return this.head.data; &#125; getTail ()&#123; return this.tail.data; &#125; insert(position, data) &#123; if (position &lt; 0 || position &gt; this.length) return false let newNode = new Node(data); if (this.length == 0) &#123; this.head = newNode; this.tail = newNode; &#125;else &#123; if (position == 0) &#123; this.head.prev = newNode; newNode.next = this.head; this.head = newNode; &#125; else if(position == this.length)&#123; this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; &#125;else&#123; let current = this.head; let index = 0; while(index++ &lt; position)&#123; current = current.next; &#125; newNode.next = current; newNode.prev = current.prev; current.prev.next = newNode; current.prev = newNode; &#125; &#125; this.length += 1; return true; &#125; append(data)&#123; const newNode = new Node(data); console.log(&#x27;this.length&#x27;, this.length); console.log(&#x27;this&#x27;, this); if (this.length === 0) &#123; this.tail = newNode; this.head = newNode; &#125; else &#123; newNode.prev = this.tail; this.tail.next = newNode; this.tail = newNode; &#125; this.length += 1; &#125;;&#125;let list = new DoubleLinklist();list.append(&#x27;a&#x27;)list.append(&#x27;b&#x27;)list.append(&#x27;c&#x27;)list.append(&#x27;d&#x27;)console.log(list.remove(&#x27;a&#x27;));console.log(list);console.log(list.isEmpty());console.log(list.size());console.log(list.getHead());console.log(list.getTail());","tags":["Javascript","React Native"],"categories":["React Native"]},{"title":"React Native Cache PartI","path":"/2020/10/07/React-Native-Cache-PartI/","content":"LRU CacheCache 是兩個存取速度差異的硬體 同步兩者資料的架構 LRU 是 Least Recently Used 的縮寫 表示最近較少使用的會優先被替換掉 實作邏輯LRU 快取是一個固定容量的 map 如果快取是滿的時候 仍需要插入一個新的元素 找出最近最少使用的元素來替換 而不會增加 Cache 的容量大小 需要一個類似hashmap 的架構 一種將所有元素按照訪問順徐來儲存，有效率的移動元素可以藉由雙向連結 需要有兩個操作 #.set #.get 可以參考 lru github 1234567891011121314151617181920212223const LRU = require(&#x27;lru&#x27;);const cache = new LRU(2), evictedcache.on(&#x27;evict&#x27;,function(data) &#123; evicted = data &#125;);cache.set(&#x27;foo&#x27;, &#x27;bar&#x27;);cache.get(&#x27;foo&#x27;); //=&gt; barcache.set(&#x27;foo2&#x27;, &#x27;bar2&#x27;);cache.get(&#x27;foo2&#x27;); //=&gt; bar2cache.set(&#x27;foo3&#x27;, &#x27;bar3&#x27;); // =&gt; evicted = &#123; key: &#x27;foo&#x27;, value: &#x27;bar&#x27; &#125;cache.get(&#x27;foo3&#x27;); // =&gt; &#x27;bar3&#x27;cache.remove(&#x27;foo2&#x27;) // =&gt; &#x27;bar2&#x27;cache.remove(&#x27;foo4&#x27;) // =&gt; undefinedcache.length // =&gt; 1cache.keys // =&gt; [&#x27;foo3&#x27;]cache.clear() // =&gt; it will NOT emit the &#x27;evict&#x27; eventcache.length // =&gt; 0cache.keys // =&gt; [] 雙向鍊表雙向鍊表 既可以從頭到尾訪問，也可以從尾到頭訪問 一個節點會有前面的 ref 也會有一個向後的 ref 雙向鍊表不僅有 head 指向第一個節點，而且有 tail 指向最後一個節點 每一個節點由三部分組成：item儲存數據、prev指向前一個節點、next指向後一個節點 雙向鍊表的第一個節點的 prev 指向null 雙向鍊表的最後一個節點的 next 指向null 雙向鍊錶常見的操作: append（element） 雙向鍊表尾部添加一個新的元素 inset（position，element） 雙向鍊表的特定位置插入一個新的元素 get（element） 獲取對應位置的元素 indexOf（element） 返回元素在鍊錶中的 index，如果雙向鍊表中沒有元素就返回 -1 update（position，element） 修改某個位置的元素 removeAt（position） 從雙向鍊表的特定位置移除一項 isEmpty（） 如果雙向鍊表中不包含任何元素，返回trun，如果雙向鍊表長度大於 0 則返回 false size（） 返回雙向鍊表包含的元素個數，與 陣列 的length屬性類似 toString（） 由於雙向鍊表中需要重寫繼承自JavaScript對象默認的toString方法，只輸出元素的值 forwardString（） 返回正向訪問節點字符串形式 backwordString（） 返回反向訪問的節點的字符串形式","tags":["Javascript","React Native"],"categories":["React Native"]},{"title":"React-Native-Notification-Android","path":"/2020/10/04/React-Native-Notification-Android/","content":"AndroidInitial React Native App1$ react-native init rn_notification Install1$ yarn add @react-native-firebase/app @react-native-firebase/messaging FirebaseDownload GoogleService-Info.plist configure Android index.js 12345678910111213141516171819202122232425import &#123;AppRegistry&#125; from &#x27;react-native&#x27;;import App from &#x27;./App&#x27;;import &#123;name as appName&#125; from &#x27;./app.json&#x27;;import messaging from &#x27;@react-native-firebase/messaging&#x27;;async function requestUserPermission() &#123; try &#123; const messageinstance = messaging(); const authStatus = await messageinstance.requestPermission(); const enabled = authStatus === messaging.AuthorizationStatus.AUTHORIZED || authStatus === messaging.AuthorizationStatus.PROVISIONAL; if (enabled) &#123; await messageinstance.registerDeviceForRemoteMessages(); const token = await messageinstance.getToken(); console.log(&#x27;token:&#x27;, token); &#125; &#125; catch(error) &#123; console.log(&quot;requestUserPermission -&gt; error&quot;, error) &#125;&#125;requestUserPermission();AppRegistry.registerComponent(appName, () =&gt; App); APNS Servicewiki Apns Service Next - Android push notification 參考資訊react-native-permissions issue issue2 firebase","tags":["Javascript","React Native"],"categories":["React Native"]},{"title":"React-Native-Notification-IOS","path":"/2020/10/04/React-Native-Notification-IOS/","content":"IOSInitial React Native App1$ react-native init rn_notification Install12$ yarn add @react-native-firebase/app @react-native-firebase/messaging$ cd ios &amp;&amp; pod install &amp;&amp; cd .. FirebaseDownload GoogleService-Info.plist podFile 12345require_relative &#x27;../node_modules/react-native/scripts/react_native_pods&#x27;require_relative &#x27;../node_modules/@react-native-community/cli-platform-ios/native_modules&#x27;$FirebaseSDKVersion = &#x27;6.29.0&#x27;... other settings AppDelegate.m 1234...import#import &lt;Firebase.h&gt;... others settings index.js 12345678910111213141516171819202122232425import &#123;AppRegistry&#125; from &#x27;react-native&#x27;;import App from &#x27;./App&#x27;;import &#123;name as appName&#125; from &#x27;./app.json&#x27;;import messaging from &#x27;@react-native-firebase/messaging&#x27;;async function requestUserPermission() &#123; try &#123; const messageinstance = messaging(); const authStatus = await messageinstance.requestPermission(); const enabled = authStatus === messaging.AuthorizationStatus.AUTHORIZED || authStatus === messaging.AuthorizationStatus.PROVISIONAL; if (enabled) &#123; await messageinstance.registerDeviceForRemoteMessages(); const token = await messageinstance.getToken(); console.log(&#x27;token:&#x27;, token); &#125; &#125; catch(error) &#123; console.log(&quot;requestUserPermission -&gt; error&quot;, error) &#125;&#125;requestUserPermission();AppRegistry.registerComponent(appName, () =&gt; App); APNS Servicewiki Apns Service Demo Next - Android push notification 參考資訊react-native-permissions issue issue2 firebase","tags":["Javascript","React Native"],"categories":["React Native"]},{"title":"Socketcluster-client-AuthorizationEngine","path":"/2020/09/22/Socketcluster-client-AuthorizationEngine/","content":"需求處理 JWT 的時候如果在瀏覽器可以將 token 存在 localStorage 中的 socketcluster.authToken 但是如果在 React Native 中沒有 localStorage 的模組 可以使用 jest-localstorage-mock 來處理這個問題 但是這樣很醜 希望可以自己控制 Authorization 流程 所以去爬了一下 source code 資訊在參考資料 這部分文件沒有寫得很清楚 所以花了一個篇幅來記錄一下如何客製化 Authorization Serverserver.js 在 agOptions 中加入 authKey: SCC_AUTH_KEY 這時候就會把這個參數帶入 agServer.signatureKey 所有對外的服務可以放入同樣的 authKey 彼此就可以共用同樣的 token Login123456789expressApp.get(&#x27;/login&#x27;, async (req, res) =&gt; &#123; const signedTokenString = await agServer.auth.signToken( myTokenData, agServer.signatureKey ) res.status(200).json(&#123; token: signedTokenString, &#125;)&#125;) Websocket flow12345678910111213141516171819202122232425262728agServer.setMiddleware( agServer.MIDDLEWARE_INBOUND, async (middlewareStream) =&gt; &#123; for await (let action of middlewareStream) &#123; let authToken = action.socket.authToken if (isEmpty(authToken)) &#123; const notAllowError = new Error(&#x27;not allow&#x27;) notAllowError.name = &#x27;InvalidActionError&#x27; action.block(notAllowError) action.request.error(notAllowError) console.log(&#x27;AL: action.request.error&#x27;, action.request.error) return &#125; try &#123; await agServer.auth.verifyToken(bearerToken, agServer.signatureKey) &#125; catch (error) &#123; const notAllowError = new Error(&#x27;not allow&#x27;) notAllowError.name = &#x27;InvalidActionError&#x27; action.block(notAllowError) action.request.error(notAllowError) console.log(&#x27;AL: action.request.error&#x27;, action.request.error) return &#125; action.allow() &#125; &#125;) websocket 連線上之前可以在 inbound 的 middleware 中做檢查 HTTP flow因為 API 每個 Route 希望可以更彈性的來處理驗證問題 可以依據 Express 的一般驗證模式 1234567891011121314151617181920const jwtverify = async (req, res, next) =&gt; &#123; try &#123; const bearerHeader = req.headers[&#x27;authorization&#x27;] if (!bearerHeader) throw new Error(&#x27;unauthorization&#x27;) const bearer = bearerHeader.split(&#x27; &#x27;) const bearerToken = bearer[1] req.user = await agServer.auth.verifyToken( bearerToken, agServer.signatureKey ) next() &#125; catch (error) &#123; return res.status(400).json(&#123; message: error.message &#125;) &#125;&#125;expressApp.get(&#x27;/health-check&#x27;, jwtverify, (req, res) =&gt; &#123; res.status(200).send(&#x27;OK&#x27;)&#125;) 可以在需要驗證的 route 加入 驗證的 Middleware ClientBrowser最簡單的方式 1localStorage.setItem(&#x27;socketcluster.authToken&#x27;, token) 另外也可以 AuthEngine 可以自訂 source code 在參考資料中可以參考 1234567891011121314151617181920212223let socket = socketClusterClient.create(&#123; secure: false, authTokenName: &quot;socketcluster.authToken&quot;, authEngine: &#123; _internalStorage: &#123; &quot;socketcluster.authToken&quot;: $&#123;token&#125; &#125;, isLocalStorageEnabled: true, saveToken: (name, token, options) =&gt; &#123; this._internalStorage[name] = token; return Promise.resolve(token); &#125;, removeToken: function(name) &#123; const loadPromise = this.loadToken(name); delete this._internalStorage[name]; return loadPromise; &#125;, loadToken: function(name) &#123; const token = this._internalStorage[name] || null; return Promise.resolve(token); &#125; &#125;,&#125;); secure 是否要使用 wss authTokenName 設定 _internalStorage[name] 的 name authEngine 可以自行定義針對 authToken 的行為 React Native因為在 React Native 沒有 localStorage 所以無法利用 localStorage 處理 但是可以利用 jest-localstorage-mock 來建立 但是這個做法比較不優 所以會選用 AuthEngine 來處理 1234567891011121314151617181920212223242526272829303132let socket = SocketClusterClient.create(&#123; hostname: hostname(ip), port: 1234, secure: false, authTokenName: &#x27;socketcluster.authToken&#x27;, authEngine: &#123; _internalStorage: &#123; &#x27;socketcluster.authToken&#x27;: token, &#125;, isLocalStorageEnabled: true, saveToken: (name, token, options) =&gt; &#123; this._internalStorage[name] = token return Promise.resolve(token) &#125;, removeToken: function (name) &#123; const loadPromise = this.loadToken(name) delete this._internalStorage[name] return loadPromise &#125;, loadToken: function (name) &#123; const token = this._internalStorage[name] || null return Promise.resolve(token) &#125;, &#125;,&#125;);(async () =&gt; &#123; let myChannel = socket.channel(&#x27;myChannel&#x27;) for await (let data of myChannel) &#123; console.log(&#x27;forawait -&gt; data&#x27;, data) &#125;&#125;)() 這時候會發生這個問題 12TypeError: Invalid attempt to iterate non-iterable instance.In order to be iterable, non-array objects must have a [Symbol.iterator]() method. oh!shit! 所以跑去研究了 Symbol.iterator 結果是因為 array like 的問題 所以找不到 [Symbol.iterator]() method 解決方案只要用 Array.from 轉換型態就可以了 所以變成 1234567891011121314151617181920212223242526272829303132333435363738394041const connectSocketCluster = async () =&gt; &#123; try &#123; let socket = SocketClusterClient.create(&#123; hostname: hostname(ip), port: 1234, secure: false, authTokenName: &#x27;socketcluster.authToken&#x27;, authEngine: &#123; _internalStorage: &#123; &#x27;socketcluster.authToken&#x27;: token, &#125;, isLocalStorageEnabled: true, saveToken: (name, token, options) =&gt; &#123; this._internalStorage[name] = token return Promise.resolve(token) &#125;, removeToken: function (name) &#123; const loadPromise = this.loadToken(name) delete this._internalStorage[name] return loadPromise &#125;, loadToken: function (name) &#123; const token = this._internalStorage[name] || null return Promise.resolve(token) &#125;, &#125;, &#125;) ;(async () =&gt; &#123; const errorChannel = socket.listener(&#x27;error&#x27;) try &#123; for await (let &#123; error &#125; of Array.from(errorChannel)) &#123; &#125; &#125; catch (error) &#123;&#125; &#125;)() &#125; catch (error) &#123; console.log(&#x27;connectSocketCluster -&gt; error.message&#x27;, error.message) &#125;&#125;connectSocketCluster() 終於可以連上了 以及可以做基本的驗證 只要同一個 token 就可以在各個服務中聯繫 如果還要開其他的 broker 只要注意 SSC_AUTH_KEY 的一致性 就可以基本上保證彼此之間的 token 共用 參考資料socketcluster authengine auth.js iterable","tags":["Nodejs","SocketCluster"],"categories":["Nodejs"]},{"title":"SocketCluster-scc","path":"/2020/09/21/SocketCluster-scc/","content":"SCC GuideSCC 是服務的集合 讓你可以快速的將 SocketCluster 快速的部屬到多台機器上 讓彼此可以任意溝通 並且可以利用 Kubernetes 上面優化運行 SCC 基本上可以分成幾個服務 scc-worker (SocketCluster) https://github.com/SocketCluster/socketcluster scc-broker https://github.com/SocketCluster/scc-broker scc-state https://github.com/SocketCluster/scc-state scc-ingress (Kubernetes only) Scc-worker可以建立多個數量的 service 必須指定一個 scc-state service 做連結 Scc-broker可以建立多個數量的 service 必須指定一個 scc-state service 做連結 這是特殊的後端 service 和 scc-worker 最大的不同是 scc-broker 主要是在與多個前端做訊息的溝通 所有的 sub/pub channels 可以平均的在 scc-broker 平均分配流量 Scc-state一個 Cluster 應該只會有一個 Scc-state service 主要在管理各個 Service 的狀態 讓他們可以自動 重新啟動或是服務管理 當有新的 Scc-broker 加入的時候 Scc-state 會通知所有的 Scc-worker 這樣就可以重新平衡流量 當 Scc-state 關閉或是不可用的時候 SCC可以繼續運行而不會中斷服務 k8s 未來會補充 部屬順序 scc-state &gt;&gt; scc-worker &gt;&gt; scc-broker 參考資源SCC Guide","tags":["Nodejs","SocketCluster"],"categories":["Nodejs"]},{"title":"SociekCluster-Storage","path":"/2020/09/21/SocketCluster-Storage/","content":"Mongodb以 Mongodb 為範例 1234$ git clone git@github.com:SocketCluster/scc-broker.git scc-mongo-broker &amp;&amp; cd scc-mongo-broker$ yarn install$ yarn add mongoose dotenv$ mkdir models models&#x2F;tankModel.js 123456789101112131415161718const mongoose = require(&#x27;mongoose&#x27;);const &#123; Schema &#125; = mongoose;const schema = new mongoose.Schema(&#123; name: &#x27;string&#x27;, size: &#x27;string&#x27; &#125;);const Tank = mongoose.model(&#x27;Tank&#x27;, schema);// Tank.create(&#123; size: &#x27;small&#x27; &#125;, function (err, small) &#123;// if (err) return handleError(err);// // saved!// &#125;);Tank.find().then(result =&gt; &#123; console.log(&#x27;AL: result&#x27;, result)&#125;).catch(error =&gt; &#123; console.log(&#x27;AL: error&#x27;, error)&#125;)module.exports = Tank; server.js 1234567891011const dotenv = require(&#x27;dotenv&#x27;);dotenv.config();const mongoose = require(&#x27;mongoose&#x27;);const uri = &#x27;mongodb://localhost:27017/test?poolSize=4&#x27;;mongoose.connect(uri, &#123;useNewUrlParser: true, useUnifiedTopology:true&#125;);// mongoose.createConnection(uri, &#123;useUnifiedTopology: true&#125;);const Tank = require(&#x27;./models/tankModel&#x27;);dotenv.config(); 參考資料mongoose scc-broker sc-redis sc-rabbitmq sc-error","tags":["Nodejs","SocketCluster"],"categories":["Nodejs"]},{"title":"Redux-Part-III","path":"/2020/09/18/Redux-Part-III/","content":"前情提要角色 生產者 - 產出任務 store.dispatch 消費者 - 消費任務 saga function channel - 暫存任務的地方 Redux-Saga 的組成 createMiddleware effects Channel createMiddleware基於 redux 所以要建立一個 sagaMiddleware createMiddleware 會回傳一個 sagaMiddleware sagaMiddleware在 sagaMiddleware 有一個 run 的參數 他是之前說過的 Generator Runner sagaRunner 在這個 Function 中 會利用 saga 產生 iterator Channel之前在生產者產生 task 之後需要有一個 channel 來暫存 這就是暫存的地方 預設會有一個 channel(之後有機會再說) 自己產生的話就可以用 actionChannel watcher.js1234567891011import types from &quot;../constants/actionTypes&quot;;import &#123; take, call, takeLatest, actionChannel &#125; from &#x27;redux-saga/effects&#x27;;import &#123; loginSaga, logoutSaga &#125; from &#x27;./authSaga&#x27;;export function* watchLogin() &#123; yield takeLatest(types.LOGIN, loginSaga);&#125;export function* watchLogout() &#123; yield takeLatest(types.LOGOUT, logoutSaga);&#125; 一般需要使用動併發的時候可以這樣處理 但是因為使用的是 takeLatest 所以當有重複的 Action 的時候 他會取消上一個 Action 但是如果我們希望可以一個一個處理 所有還沒處理到的 Action 先暫存一個地方 希望能有一個 queue 的機制 這時候可以利用 actionChannel new watcher.js123456789101112131415import types from &quot;../constants/actionTypes&quot;;import &#123; take, call, takeLatest, actionChannel &#125; from &#x27;redux-saga/effects&#x27;;import &#123; loginSaga, logoutSaga &#125; from &#x27;./authSaga&#x27;;export function* watchLogin() &#123; const requestChan = yield actionChannel(types.LOGIN); while(true) &#123; const actionObject = yield take(requestChan); yield call(loginSaga, actionObject); &#125;&#125;export function* watchLogout() &#123; yield takeLatest(types.LOGOUT, logoutSaga);&#125; 上述的是利用 channel 暫存 task 由於使用 call 來做強制執行完之後 再由 while(true) 會重複執行下一個新的 task Container1234567891011121314151617181920import types from &#x27;~/constants/actionTypes&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import LoginScreen from &#x27;./view&#x27;;const loginAction = payload =&gt; (&#123; type: types.LOGIN, payload&#125;);const mapStateToProps = (&#123; auth &#125;) =&gt; (&#123; auth&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; handleLogin: payload =&gt; &#123; dispatch(loginAction(payload)) &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(LoginScreen); 在 container 有描述 dispatch 產生新的 task 再由 saga 進行消費 參考資料createMiddleware Recipes RNSkelton","tags":["React","Redux"],"categories":["React"]},{"title":"Redux-Part-II","path":"/2020/09/17/Redux-Part-II/","content":"Thunk經過上一篇了解了 Redux 和如何實做 Middleware 之後 再來看看 Thunk 到底做了什麼事情呢？ What is Thunk?Thunk 是一個 Function 主要功用是將結果延遲到需要的時候再執行這個 Function 來獲取這份資料 12345function foo() &#123; return 1 + 2;&#125;const x = 1 + 2; 這是最簡單的一個 Thunk 這時候來看一下 React Thunk 到底在 applyMiddleware 做了什麼事情？ React Thunk它其實是多包了一層 Function 來暫時阻止 action 進入 Store 來達到有機會完成非同步的 Action 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import React, &#123;useState, useEffect&#125; from &#x27;react&#x27;;import thunk from &#x27;redux-thunk&#x27;;import &#123; View, Text &#125; from &#x27;react-native&#x27;;const counter = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case &#x27;INCREMENT&#x27;: return state + 1; case &#x27;DECREMENT&#x27;: return state - 1; default: return state; &#125;&#125;;const store = createStore(counter, applyMiddleware(thunk));function increment() &#123; console.log(&#x27;increment&#x27;); return &#123; type: &#x27;INCREMENT&#x27;, &#125;;&#125;function incrementAsync() &#123; console.log(&#x27;incrementAsync&#x27;); return (dispatch) =&gt; &#123; setTimeout(() =&gt; &#123; // Yay! Can invoke sync or async actions with `dispatch` dispatch(increment()); &#125;, 1000); &#125;;&#125;const LoginScreen = () =&gt; &#123; const [value, setValue] = useState(null); useEffect(() =&gt; &#123; incrementAsync()(store.dispatch); const unsubscribe = store.subscribe(() =&gt; &#123; const v = store.getState(); console.log(&#x27;LoginScreen -&gt; v&#x27;, v) setValue(v); &#125;) return () =&gt; unsubscribe(); &#125;, []) return ( &lt;View style=&#123;&#123;flex: 1&#125;&#125;&gt; &lt;Text&gt;&#123;String(value)&#125;&lt;/Text&gt; &lt;/View&gt; );&#125;; thunk 的 middleware 會多包覆一層 傳送 dipspatch 所以在執行 Action 的當下 Reducer 不會收到通知 而是在在中間曾發送 Action 來達到通知 Reducer 修改 Store 的效果 另外也可以做一些變形 讓這一層可以統一執行 範例 在 middleware 中有一個 promiseMiddleware.js 專門處理非同步事件 讓 Action 可以很單純的回傳一個物件 覺的是一種不錯的作法 SagaSaga PatternSaga Pattern 並不是 Redux 產生的 各個程式語言都可以去實做這個 Pattern 這個 Pattern 想解決的是 LLT (Long Live Transaction) 的問題 尚未解決的是當產生了一個 Transaction 的同時也應該會產出一個 Compensation 在 Redux Saga 使用的2是 Generator Function 而不是 Async&#x2F; Await Function 所以要先了解這兩個的差異性 Async&#x2F;Await And Gernerator Redux Saga如何透過 Generator 管理任務一個一般的 function 依序列出 step1 step2 step3 1234567function work() &#123; console.log(&#x27;step1&#x27;); console.log(&#x27;step2&#x27;); console.log(&#x27;step3&#x27;);&#125;work(); 但是如果是要用 Generator Function 來實做的話 12345678910function* generatorWork() &#123; yield console.log(&#x27;step1&#x27;); yield console.log(&#x27;step2&#x27;); yield console.log(&#x27;step3&#x27;);&#125;const work = generatorWork();work.next(); //step1work.next();//step2work.next();//step3 當每次呼叫 next 會回傳一個 &#123;done: false, value: &#39;step1&#39;&#125; 的物件 done 是一個 Boolean 代表是否完成 Generator Runner123456789101112131415161718192021222324252627import axios from &quot;axios&quot;;function runner(genFn) &#123; const itr = genFn(); function next(arg) &#123; let result = itr.next(arg); if (result.done) &#123; return arg; &#125; else &#123; return Promise.resolve(result.value).then(next); &#125; &#125; return next();&#125;function* genFn() &#123; const USER_URI = &quot;https://reqres.in/api/users&quot;; let res = yield axios.get(USER_URI); const userId = res.data.data[0].id; yield axios.get(`$&#123;USER_URI&#125;/$&#123;userId&#125;`);&#125;const result = runner(genFn);Promise.resolve(result).then(res =&gt; console.log(res.data)); Redux-Saga 是這樣來管理每一個任務 它可以執行的對象相當豐富 effect iterator promise 一般的程式碼 Producer And ConsumerRedux-saga 其實背後的原理是 Producer 和 Consumer 但是不知道是歷史因素還是什麼原因 如果你閱讀 redux-saga 的原始碼 你會看到 channel 是用來管理非同步任務的緩衝區 (Buffer) 裡面提供了 produce 與 consume 的函式 channel.take() 生產者 (Producer): 把任務放到 channel 中 channel.put() 消費者 (Consumer): 呼叫了 store.dispatch() 後執行的函式，會從 channel 中選擇符合 pattern 的任務執行 WTF take建立一個 Effect 描述 指示 middleware 在 Store 等待指定的 action Generator 會暫停 直到一個符合 pattern 的 action 被 dispatch 簡單來說 take 是用來註冊處理非同步的函式 take 會 將處理非同步的函式所生成的 iterator 用 generator runner 包裝起來 最後呼叫 channel.take(cb) 以 callback 的形式儲存在 channel 中 在 redux-saga 的實作中 被儲存在 channel 中的 callback 稱作 taker 這些原理講得有點抽象 下個章節來看一下 Redux-saga 的 Source code 吧","tags":["React","Redux"],"categories":["React"]},{"title":"Redux-Part-I","path":"/2020/09/16/Redux-Part-I/","content":"ReduxReact ReduxFlux 的實作之一 有一個共同的 Store 儲存資料 透過 Middleware 來控制工作流 發起 Action 來通過工作流之後 透過 Reducer 來修改 Store 內的資料 再藉由 Store 的資料來顯示 Screen 搭配的 Package 有很多種不同的配合與實現 redux-thunk redux-saga 主要都是在處理 Async Actions redux-thunk skelton redux-saga skelton 兩個骨架範例 基本上每一個 Async Action 都是單一的 Promise 但是不代表只能夠有一個 Promise 也可以多個 Promise 但是需要使用 Promise.all 做群組 有清楚的成功與失敗 所以建立一個非同步的 Action 應該會有三個 action types Request - 顯示 loading Success - 成功 (關閉 loading) Error - 失敗 (關閉 loading) 不要跳脫一個完整的週期 在一個 Action 內 在發送另外一個 非同步 Action Install And SetupBasic Usage1$ yarn add redux 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123;createStore&#125; from &#x27;redux&#x27;;import React, &#123;useState, useEffect&#125; from &#x27;react&#x27;;import &#123;Navigation&#125; from &#x27;react-native-navigation&#x27;;import &#123; View, Text, Button, StyleSheet, Icon &#125; from &#x27;react-native&#x27;;const counter = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case &#x27;INCREMENT&#x27;: return state + 1; case &#x27;DECREMENT&#x27;: return state - 1; default: return state; &#125;&#125;;const store = createStore(counter);const LoginScreen = () =&gt; &#123; const [value, setValue] = useState(null); useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; store.dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;) // 1 store.dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;) // 2 store.dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;) // 1 &#125;, 2000) const unsubscribe = store.subscribe(() =&gt; &#123; const v = store.getState(); console.log(&#x27;LoginScreen -&gt; v&#x27;, v) setValue(v); &#125;) return () =&gt; unsubscribe(); &#125;, []) return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text&gt;&#123;String(value)&#125;&lt;/Text&gt; &lt;Button title=&#x27;Login&#x27; color=&#x27;#710ce3&#x27; onPress=&#123;() =&gt; Navigation.setRoot(mainRoot)&#125; /&gt; &lt;/View&gt; );&#125;; counter 是 Reducer Reducer 都是一個函式 會修改 Store 裡面的某一個部分的值 再把修改結果回傳 但是這樣最基本的 Redux 只能同步的修改 Store 的資料 &#123; type: &#39;INCREMENT&#39; &#125; 是 Action Object Middleware但是上述的流程只能處理同步的 Action 非同步的需要多做一點點事情 這時候需要 Middleware 的幫助 Middleware 概念就是一個一個的生產線 每一個 Function 都是處理某些細節 再利用這個 Middleware 排定順序 Composeredux compose 12345const compose = (...fns) =&gt; (...payload) =&gt; &#123; if(fns.length === 0) return payload; if(fns.length === 1) return fns[0](...payload); return funcs.reduce((a, b) =&gt; (...payload) =&gt; a(b(...payload)))&#125; compose 與 pipe 是 Middleware 的其中兩種應用 針對 Dispatch 做擴充目前 dispatch 只能做同步 Action 但是並不符合我們的需求 Monkeypatching 12345678910111213141516export default (...middlewares) =&gt; (reducer, initialState) =&gt; &#123; const store = createStore(reducer, initialState); const next = store.dispatch; const middlePayload = &#123; getState: store.getState, dispatch: (action, ...args) =&gt; dispatch(action, ...args) &#125;; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); const dispatch = compose(...chain)(store.dispatch); return &#123; ...store, dispatch &#125;&#125;; 可以一步一步慢慢了解 Redux 如何形成 Middleware 的過程 最後可以看到這個範例 The Final Approach 接下來了解如何實做 Redux 中的 Middleware 之後 再來看看加入 Thunk , Saga 概念的 Data flow 參考資源Nodejs 範例Middleware","tags":["React","Redux"],"categories":["React"]},{"title":"React-Native-Navigation","path":"/2020/09/15/React-Native-Navigation/","content":"React-Native-NavigationInstall依據以下動作即可完成Install Basic Usage12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// In index.js of a new projectconst &#123; Navigation &#125; = require(&#x27;react-native-navigation&#x27;);const React = require(&#x27;react&#x27;);const &#123; View, Text, StyleSheet &#125; = require(&#x27;react-native&#x27;);const HomeScreen = (props) =&gt; &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;/View&gt; );&#125;;//可以直接在 options 設定參數HomeScreen.options = &#123; topBar: &#123; title: &#123; text: &#x27;Home&#x27;, color: &#x27;white&#x27; &#125;, background: &#123; color: &#x27;#4d089a&#x27; &#125; &#125;&#125;Navigation.registerComponent(&#x27;Home&#x27;, () =&gt; HomeScreen);Navigation.events().registerAppLaunchedListener(async () =&gt; &#123; Navigation.setRoot(&#123; root: &#123; stack: &#123; children: [ &#123; component: &#123; name: &#x27;Home&#x27; &#125; &#125; ] &#125; &#125; &#125;);&#125;);const styles = StyleSheet.create(&#123; root: &#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27;, backgroundColor: &#x27;whitesmoke&#x27; &#125;&#125;); :::infoNavigation.registerComponent 會建立一個 uniqueId CompoenntId 這個 Id 會是換頁的主要依據::: 導頁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// In index.js of a new projectconst &#123; Navigation &#125; = require(&#x27;react-native-navigation&#x27;);const React = require(&#x27;react&#x27;);const &#123; View, Text, StyleSheet &#125; = require(&#x27;react-native&#x27;);const &#123; Button &#125; = require(&#x27;react-native&#x27;);const HomeScreen = (props) =&gt; &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title=&#x27;Push Settings Screen&#x27; color=&#x27;#710ce3&#x27; onPress=&#123;() =&gt; Navigation.push(props.componentId, &#123; component: &#123; name: &#x27;Settings&#x27;, options: &#123; topBar: &#123; title: &#123; text: &#x27;Settings&#x27; &#125; &#125; &#125; &#125; &#125;)&#125;/&gt; &lt;/View&gt; );&#125;;const SettingScreen = (props) =&gt; &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text&gt;Setting Screen&lt;/Text&gt; &lt;/View&gt; );&#125;;HomeScreen.options = &#123; topBar: &#123; title: &#123; text: &#x27;Home&#x27;, color: &#x27;white&#x27; &#125;, background: &#123; color: &#x27;#4d089a&#x27; &#125; &#125;&#125;Navigation.registerComponent(&#x27;Home&#x27;, () =&gt; HomeScreen);Navigation.registerComponent(&#x27;Settings&#x27;, () =&gt; SettingScreen);Navigation.events().registerAppLaunchedListener(async () =&gt; &#123; Navigation.setRoot(&#123; root: &#123; stack: &#123; children: [ &#123; component: &#123; name: &#x27;Home&#x27; &#125; &#125; ] &#125; &#125; &#125;);&#125;);const styles = StyleSheet.create(&#123; root: &#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27;, backgroundColor: &#x27;whitesmoke&#x27; &#125;&#125;); App Theme使用的 Style Framwork 是 react-native-elements 裡面也有 Theme React Native Navigation 也可以設定 Theme 12345678910111213141516Navigation.setDefaultOptions(&#123; statusBar: &#123; backgroundColor: &#x27;#4d089a&#x27; &#125;, topBar: &#123; title: &#123; color: &#x27;white&#x27; &#125;, backButton: &#123; color: &#x27;white&#x27; &#125;, background: &#123; color: &#x27;#4d089a&#x27; &#125; &#125;&#125;); Tab Stack一般的App 都會有 Bottom 的 Tap navigation 在 React Native Navigation 中 把剛剛的 Home Settings 頁面換成兩個 Tab Statck 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const &#123; Navigation &#125; = require(&#x27;react-native-navigation&#x27;);const React = require(&#x27;react&#x27;);const &#123; View, Text, Button, StyleSheet &#125; = require(&#x27;react-native&#x27;);const HomeScreen = (props) =&gt; &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text&gt;Hello React Native Navigation 👋&lt;/Text&gt; &lt;Button title=&#x27;Push Settings Screen&#x27; color=&#x27;#710ce3&#x27; onPress=&#123;() =&gt; Navigation.push(props.componentId, &#123; component: &#123; name: &#x27;Settings&#x27; &#125; &#125;)&#125; /&gt; &lt;/View&gt; );&#125;;HomeScreen.options = &#123; topBar: &#123; title: &#123; text: &#x27;Home&#x27; &#125; &#125;, bottomTab: &#123; text: &#x27;Home&#x27; &#125;&#125;;const SettingsScreen = () =&gt; &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text&gt;Settings Screen&lt;/Text&gt; &lt;/View&gt; );&#125;SettingsScreen.options = &#123; topBar: &#123; title: &#123; text: &#x27;Settings&#x27; &#125; &#125;, bottomTab: &#123; text: &#x27;Settings&#x27; &#125;&#125;Navigation.registerComponent(&#x27;Home&#x27;, () =&gt; HomeScreen);Navigation.registerComponent(&#x27;Settings&#x27;, () =&gt; SettingsScreen);Navigation.setDefaultOptions(&#123; statusBar: &#123; backgroundColor: &#x27;#4d089a&#x27; &#125;, topBar: &#123; title: &#123; color: &#x27;white&#x27; &#125;, backButton: &#123; color: &#x27;white&#x27; &#125;, background: &#123; color: &#x27;#4d089a&#x27; &#125; &#125;, bottomTab: &#123; fontSize: 14, selectedFontSize: 14 &#125;&#125;);Navigation.events().registerAppLaunchedListener(async () =&gt; &#123; Navigation.setRoot(&#123; root: &#123; bottomTabs: &#123; children: [ &#123; stack: &#123; children: [ &#123; component: &#123; name: &#x27;Home&#x27; &#125; &#125;, ] &#125; &#125;, &#123; stack: &#123; children: [ &#123; component: &#123; name: &#x27;Settings&#x27; &#125; &#125; ] &#125; &#125; ] &#125; &#125; &#125;);&#125;);const styles = StyleSheet.create(&#123; root: &#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27;, backgroundColor: &#x27;whitesmoke&#x27; &#125;&#125;); Bottom Tab 會有 Home 和 Settings 但是在 Home 會有 Button 點擊後還是會 push Settings 進入 Home Stack 這是一般的 App Navigation 的邏輯 Replace RootNavigation 也提供了覆蓋 Root Stack 的 function Navigation.setRoot($&#123;rootObject&#125;) 執行這個 function 會將 Root 整個覆蓋 範例如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137const &#123; Navigation &#125; = require(&#x27;react-native-navigation&#x27;);const React = require(&#x27;react&#x27;);const &#123; View, Text, Button, StyleSheet &#125; = require(&#x27;react-native&#x27;);const LoginScreen = () =&gt; &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Button title=&#x27;Login&#x27; color=&#x27;#710ce3&#x27; onPress=&#123;() =&gt; Navigation.setRoot(mainRoot)&#125; /&gt; &lt;/View&gt; );&#125;;const HomeScreen = (props) =&gt; &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text&gt;Hello React Native Navigation 👋&lt;/Text&gt; &lt;Button title=&#x27;Push Settings Screen&#x27; color=&#x27;#710ce3&#x27; onPress=&#123;() =&gt; Navigation.push(props.componentId, &#123; component: &#123; name: &#x27;Settings&#x27; &#125; &#125;)&#125; /&gt; &lt;/View&gt; );&#125;;HomeScreen.options = &#123; topBar: &#123; title: &#123; text: &#x27;Home&#x27; &#125; &#125;, bottomTab: &#123; text: &#x27;Home&#x27; &#125;&#125;;const SettingsScreen = () =&gt; &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text&gt;Settings Screen&lt;/Text&gt; &lt;/View&gt; );&#125;SettingsScreen.options = &#123; topBar: &#123; title: &#123; text: &#x27;Settings&#x27; &#125; &#125;, bottomTab: &#123; text: &#x27;Settings&#x27; &#125;&#125;Navigation.registerComponent(&#x27;Login&#x27;, () =&gt; LoginScreen);Navigation.registerComponent(&#x27;Home&#x27;, () =&gt; HomeScreen);Navigation.registerComponent(&#x27;Settings&#x27;, () =&gt; SettingsScreen);const mainRoot = &#123; root: &#123; bottomTabs: &#123; children: [ &#123; stack: &#123; children: [ &#123; component: &#123; name: &#x27;Home&#x27; &#125; &#125;, ] &#125; &#125;, &#123; stack: &#123; children: [ &#123; component: &#123; name: &#x27;Settings&#x27; &#125; &#125; ] &#125; &#125; ] &#125; &#125;&#125;;const loginRoot = &#123; root: &#123; component: &#123; name: &#x27;Login&#x27; &#125; &#125;&#125;;Navigation.setDefaultOptions(&#123; statusBar: &#123; backgroundColor: &#x27;#4d089a&#x27; &#125;, topBar: &#123; title: &#123; color: &#x27;white&#x27; &#125;, backButton: &#123; color: &#x27;white&#x27; &#125;, background: &#123; color: &#x27;#4d089a&#x27; &#125; &#125;, bottomTab: &#123; fontSize: 14, selectedFontSize: 14 &#125;&#125;);Navigation.events().registerAppLaunchedListener(async () =&gt; &#123; Navigation.setRoot(loginRoot);&#125;);const styles = StyleSheet.create(&#123; root: &#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27;, backgroundColor: &#x27;whitesmoke&#x27; &#125;&#125;); 基本上定義了一個 loginRoot 和 mainRoot 在登入的時候如果成功則切換到 mainRoot 登出的時候則再度切換回 loginRoot 來簡單的實現了登入登出機制 但是在實際的產品中這樣卻是不足的 因為會先看到 LoginScreen 如果是登入狀態 加上在 React Native 讀取 AsyncStorage 的資料都是非同步的 會看到閃一下 再跳到 MainRoot 在使用者體驗上會很糟糕 所以會需要做一些調整來避免這個狀況 但是這篇篇幅太多 留著後面再說吧","tags":["React Native"],"categories":["React Native"]},{"title":"React-Native-connect-server","path":"/2020/09/15/React-Native-connect-server/","content":"Initial React Native1$ npx react-native init imapp &amp;&amp; cd imapp Run on ios1$ npx react-native-run-ios Install SocketCluster Client1$ yarn add socketcluster-client Initial SocketApp.js 12345678import SocketClusterClient from &#x27;socketcluster-client&#x27;;let socket = SocketClusterClient.create(&#123; hostname: &#x27;localhost&#x27;, port: 8000&#125;);socket.transmit(&#x27;foo&#x27;, 123); Server 可以收到 data 基本上已經可以確認接通了 SocketCluster Server 與 Client 之後就可以準備其他事情 參考資料socketcluster-Client","tags":["Nodejs","React Native","React","SocketCluster","ithome 12"],"categories":["SocketCluster"]},{"title":"Java-Spring-Boot-variable","path":"/2020/09/11/Java-Spring-Boot-variable/","content":"Spring Boot之前在 Java 已經處理了 route, method 的問題 接下來要處理使用 API 溝通時要傳遞參數的時候要如何實作？ Path Variable Query String Variable Request Body Variable Path Variable123456789101112131415161718package com.example.demo.springbootdemo.web;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.Map;@RestController@RequestMapping(&quot;/api&quot;)public class HelloController &#123; @GetMapping(&quot;/books/&#123;id&#125;&quot;) public Object getOne(@PathVariable long id) &#123; Map&lt;String, Object&gt; book = new HashMap&lt;&gt;(); book.put(&quot;id&quot;, id); book.put(&quot;name&quot;, &quot;new book&quot;); book.put(&quot;number&quot;, &quot;123jkda&quot;); return book; &#125;&#125;","tags":["Java","spring-boot"],"categories":["Java"]},{"title":"Java-Spring-Boot-Initial","path":"/2020/09/11/Java-Spring-Boot-Initial/","content":"Initial project And Hello worlddownload IntelliJ IDEA 建立一個新的 spring demo 安裝好之後可以建立一個新的 Controller src -&gt; main -&gt; java -&gt; {packagename} -&gt; web -&gt; HelloController.java 1234567891011package com.example.demo.springbootdemo.web;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/api&quot;)public class HelloController &#123; @RequestMapping(value=&quot;/say&quot;, method = RequestMethod.GET) public String helloGET() &#123; return &quot;Hello World GET&quot;; &#125;&#125; 這樣就可以直接新增了一個 http://loclahost:8081/api/say 的 api @RestController 代表這是一個 Restful API class @RequestMapping(&quot;route&quot;) 來處理 url route 問題 value: route method: method [GET, POST, PUT, PATCH, DELETE]","tags":["Java","spring-boot"],"categories":["Java"]},{"title":"SocketCluster-Consumer","path":"/2020/09/09/SocketCluster-Consumer/","content":"Chennel之前有聊到 Chennel 但是當訊息量越來越大的時候 可以有一些機制來做傳遞與管理 在前端 Subscribe Channel 123456(async () =&gt; &#123; let channel = socket.subscribe(&quot;foo&quot;); for await (let data of channel) &#123; console.log(&quot;forawait -&gt; data&quot;, data); &#125;&#125;)(); 在多個前端可以 subscribe 同一個 channel 代表各個前端可以互相溝通 ConsumersSocketCluster 有多個函式可以針對 Channel 做控制 socket.listener socket.receiver socket.procedure socket.channel 上述的 function 都會回傳 async iterables 代表可以透過這個方式來取得 data 12345678910(async () =&gt; &#123; for await (let &#123; socket &#125; of agServer.listener(&quot;connection&quot;)) &#123; (async () =&gt; &#123; for await (let data of socket.receiver(&#x27;foo&#x27;)) &#123; console.log(&quot;forawait -&gt; data&quot;, data) &#125; &#125;)(); &#125;&#125;)(); 這個可以建立很多個不同的 並行 loop 在同一個 stream 上 但是有可能會需要更加有彈性的作法 或是需要有一些緩衝區域 再慢慢消耗的數據 WritableConsumableStream repo 可以參考這個做法 WritableConsumableStream for-await-of loop 可以利用 ConsumableStream class ConsumableStream class Example 可以自定義 socket consumer 12345678910111213141516171819const connectionConsumerA = agServer.listener(&#x27;connection&#x27;).createConsumer();const connectionConsumerB = agServer.listener(&#x27;connection&#x27;).createConsumer();(async () =&gt; &#123; for await (let &#123;socket&#125; of connectionConsumerA) &#123; console.log(`Consumer $&#123;connectionConsumerA.id&#125; handled connection: $&#123;socket.id&#125;`); &#125;&#125;)();(async () =&gt; &#123; for await (let &#123;socket&#125; of connectionConsumerB) &#123; console.log(`Consumer $&#123;connectionConsumerB.id&#125; handled connection: $&#123;socket.id&#125;`); &#125;&#125;)();setTimeout(() =&gt; &#123; // Kill only connectionConsumerA. connectionConsumerA.kill();&#125;, 1000); 上述範例會建立兩個 stream 當一個 socket 連上也會同時連上兩個 consumer 兩個的 socket.id 也會是一致的 而在一秒後會把 connectionConsumerA 的 socket 關閉 所以一秒後只會有 connectionConsumerB 可以連上 這樣可以更加彈性的控制 socket 的連線 可以在執行之前做一些事情1234567891011121314(async () =&gt; &#123; for await (let &#123;socket&#125; of agServer.listener(&#x27;connection&#x27;)) &#123; (async () =&gt; &#123; console.log(&#x27;doSomethingWhichTakesAFewSeconds&#x27;, socket.id) for await (let data of socket.receiver(&#x27;foo&#x27;)) &#123; console.log(&quot;forawait -&gt; data&quot;, data) // ... &#125; &#125;)(); &#125;&#125;)(); 在每個連線之前都可以執行一段程式碼 共用邏輯可以放置在這邊 特殊情境backend 123456789101112131415161718192021const sleep = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;doSomethingWhichTakesAFewSeconds&#x27;); resolve(); &#125;, 1000) &#125;);&#125;(async () =&gt; &#123; for await (let &#123;socket&#125; of agServer.listener(&#x27;connection&#x27;)) &#123; (async () =&gt; &#123; await sleep(); for await (let data of socket.receiver(&#x27;foo&#x27;)) &#123; console.log(&quot;forawait -&gt; data&quot;, data) &#125; &#125;)(); &#125;&#125;)(); frondend 12345let socket = socketClusterClient.create();for await (let event of socket.listener(&#x27;connect&#x27;)) &#123; socket.transmit(&#x27;foo&#x27;, 123);&#125; 上述程式碼執行的時候 Backend 會因為 await sleep(); 非同步問題 socket.receiver(&#39;foo&#39;) 在非同步之後 會無法執行到 console.log(&quot;forawait -&gt; data&quot;, data) 所有的情境都會造成訊息的丟失 所以需要做一些調整 調整後如果只是調整順序的話並不能解決問題 Backend Bad 123456789101112131415161718(async () =&gt; &#123; for await (let &#123;socket&#125; of agServer.listener(&#x27;connection&#x27;)) &#123; (async () =&gt; &#123; // This will not work because the iterator is not yet created at this point. let fooStream = socket.receiver(&#x27;foo&#x27;); // If any messages arrive during this time, they will be ignored! await doSomethingWhichTakesAFewSeconds(); // The iterator gets created (and starts buffering) here! for await (let data of fooStream) &#123; // ... &#125; &#125;)(); &#125;&#125;)(); Backend Good 1234567891011121314151617(async () =&gt; &#123; for await (let &#123;socket&#125; of agServer.listener(&#x27;connection&#x27;)) &#123; (async () =&gt; &#123; // This will create a consumable which will start buffering messages immediately. let fooStreamConsumable = socket.receiver(&#x27;foo&#x27;).createConsumer(); await sleep(); // This loop will start from the beginning of the buffer. for await (let data of fooStreamConsumable) &#123; console.log(&quot;forawait -&gt; data&quot;, data) &#125; &#125;)(); &#125;&#125;)(); 下一個章節再來繼續處理一下 API 相關問題 參考資料Consumer","tags":["Nodejs","SocketCluster"],"categories":["Nodejs"]},{"title":"SocketCluster Cluster initial.md","path":"/2020/09/09/Socketcluster-Cluster-initial/","content":"Basic InstallInstallnvm 123456789$ nvm install 14.9.0$ nvm use 14.9.0$ npm install -g socketcluster@16.0.1$ socketcluster --help$ socketcluster create helloworld$ cd helloworld$ yarn start // yarn start$ socketcluster run // run on docker$ curl http://localhost:8000/health-check // will get OK 也可以試著 使用瀏覽器打開 http://localhost:8000/index.html 預設會有一個簡單的頁面連線 websocket 初始化之後會有一個基礎的骨架來處理 http request 與 socket connections HTTP Request Handler12345;(async () =&gt; &#123; for await (let requestData of httpServer.listener(&#x27;request&#x27;)) &#123; expressApp.apply(null, requestData) &#125;&#125;)() http 的部分不需要再增加程式碼 可以直接使用 Socket connections123456;(async () =&gt; &#123; for await (let &#123; socket &#125; of agServer.listener(&#x27;connection&#x27;)) &#123; console.log(&#x27;forawait -&gt; socket.id&#x27;, socket.id) // Handle socket connection. &#125;&#125;)() Listen custom Event in socketServer123456789101112131415161718192021// SocketCluster/WebSocket connection handling loop.;(async () =&gt; &#123; for await (let &#123; socket &#125; of agServer.listener(&#x27;connection&#x27;)) &#123; console.log( &#x27;forawait -&gt; socket.id&#x27;, socket.id )( // Handle socket connection. async () =&gt; &#123; // Set up a loop to handle remote transmitted events. for await (let data of socket.receiver(&#x27;helloworld&#x27;)) &#123; try &#123; console.warn(&#x27;forawait -&gt; helloworld -&gt; data&#x27;, data) &#125; catch (error) &#123; console.log(&#x27;forawait -&gt; error.message&#x27;, error.message) &#125; &#125; &#125; )() &#125;&#125;)() 可以再加上 try catch 來處理 Error Client123setTimeout(() =&gt; &#123; socket.transmit(&#x27;helloworld&#x27;, 123)&#125;, 1000) 也可以透過 procedure 回傳一些資訊Server12345678910111213141516;(async () =&gt; &#123; // Set up a loop to handle and respond to RPCs. for await (let request of socket.procedure(&#x27;customProc&#x27;)) &#123; try &#123; if (request.data &amp;&amp; request.data.bad) &#123; let badCustomError = new Error(&#x27;Server failed to execute the procedure&#x27;) badCustomError.name = &#x27;BadCustomError&#x27; throw badCustomError &#125; request.end(&#x27;Success&#x27;) &#125; catch (error) &#123; console.log(&#x27;forawait -&gt; customProc -&gt; error.message&#x27;, error.message) request.error(error) &#125; &#125;&#125;)() 也可以利用 request.error(error) 來處理回傳錯誤 Client 也可以利用 try catch 來接收到錯誤 Subscribe and Publish另外也可以建立 channel 來處理 subscribe 與 publish 在 Client 中加上 123456(async () =&gt; &#123; let channel = socket.subscribe(&#x27;foo&#x27;); for await (let data of channel) &#123; // ... Handle channel data. &#125;&#125;)(); 就可以在開始聽取 foo 的頻道 接受該頻道的訊息 不只是 Server 的訊息會接收 其他 Client 也可以透過這些頻道彼此溝通 Client不需要 acknowledgment 的訊息 1socket.transmitPublish(&#x27;foo&#x27;, &#x27;This is some data&#x27;); 需要 acknowledgment 的訊息 1await socket.invokePublish(&#x27;foo&#x27;, &#x27;This is some more data&#x27;); Server不需要 acknowledgment 的訊息 1agServer.exchange.transmitPublish(&#x27;foo&#x27;, &#x27;This is some data&#x27;); 需要 acknowledgment 的訊息 1await agServer.exchange.invokePublish(&#x27;foo&#x27;, &#x27;This is some more data&#x27;); 不管是 Client 或是 Server 如果是需要 acknowledmgment 的訊息需要配合 Consumers 的配合 參考資料Basic Usage","tags":["Nodejs","SocketCluster"],"categories":["Nodejs"]},{"title":"SocketCluster-Authorization","path":"/2020/09/09/SocketCluster-Authorization/","content":"Authorization在 SocketCluster 預設使用 JWT 處理驗證問題 在AGServer 之中有一個參數 authKey 是一個字串，提供 JWT 的 token 建立與驗證使用 Client 也可以使用 socket.authenticate 因為可能一個服務或多個服務 同時會有 HTTP 與 Websocket 所以會希望同一個 token 可以在各服務內使用 做使用者的驗證 建立 JWT TokenHTTP最基本的使用方式是透過 Express 來建立 token 然後再將此 token 送到客戶短提供使用 客戶端獲得這個 token 的之後必須要加到 socketcluster.authToken 中 這是 SocketCluster 的預設 JWT localStorage token 建立新連線的時候或是重新連線時 SocketCluster 會自動在 localStorage 取得 JWT Server新增一個 Express 的 route 因為是 demo 所以先用 GET 來測試 123456789101112131415expressApp.get(&#x27;/login&#x27;, async (req, res) =&gt; &#123; const myTokenData = &#123; username: &#x27;bob&#x27;, language: &#x27;English&#x27;, company: &#x27;Google&#x27;, groups: [&#x27;engineering&#x27;, &#x27;science&#x27;, &#x27;mathematics&#x27;] &#125;; let signedTokenString = await agServer.auth.signToken(myTokenData, agServer.signatureKey); res.status(200).json(&#123; token: signedTokenString &#125;);&#125;); 之後在瀏覽器測試可以取得 token 123&#123; &quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImJvYiIsImxhbmd1YWdlIjoiRW5nbGlzaCIsImNvbXBhbnkiOiJHb29nbGUiLCJncm91cHMiOlsiZW5naW5lZXJpbmciLCJzY2llbmNlIiwibWF0aGVtYXRpY3MiXSwiaWF0IjoxNTk5NTczMzA1fQ.TBwhqJlhVlpEwCcqsv9-JT5Vx7Z32D4YpCUebEDZSHQ&quot;&#125; Websocket利用 WebSocket 建立 token 的範例 Server12345678910111213141516171819202122(async () =&gt; &#123; for await (let request of socket.procedure(&#x27;login&#x27;)) &#123; try &#123; console.log(&quot;forawait -&gt; request.data&quot;, request.data) //chgeck use done socket.setAuthToken(&#123;username: request.data.username&#125;); request.end(); return; &#125; catch(error) &#123; console.log(&quot;forawait -&gt; error&quot;, error) let loginError = new Error(`Could not find a $&#123;request.data.username&#125; user`); console.log(&quot;forawait -&gt; loginError&quot;, loginError) loginError.name = &#x27;LoginError&#x27;; request.error(loginError); return; &#125; &#125; &#125;)(); Client12345678910111213141516(async () =&gt; &#123; try &#123; // Invoke a custom &#x27;login&#x27; procedure (RPC) on our server socket // then wait for the socket to be authenticated. const [, authResult] = await Promise.all([ socket.invoke(&quot;login&quot;, credentials), socket.listener(&quot;authenticate&quot;).once(), ]); console.log(&quot;authResult&quot;, JSON.stringify(authResult)) &#125; catch (error) &#123; console.log(&quot;error&quot;, error) // showLoginError(err); return; &#125; &#125;)(); Client 可以拿到的 Resonse 是 12345678&#123;\t&quot;signedAuthToken&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFsaWNlMTIzIiwiaWF0IjoxNTk5NTc2MDkyLCJleHAiOjE1OTk2NjI0OTJ9.fccJ4zBdCqpoXrHW-NWxEK9r5ykMYyA0aokQRZitUmw&quot;,\t&quot;authToken&quot;: &#123; &quot;username&quot;: &quot;alice123&quot;, &quot;iat&quot;: 1599576092, &quot;exp&quot;: 1599662492\t&#125;&#125; 驗證 JWT Token在 SocketCluster 中不論是 HTTP 和 WebSocket 的驗證方式都是一樣的 但是在這之前要先了解 SocketClsuter 的 Middleware 的使用方式 MiddlewareSocketCluster 中可以註冊 Middleware 支援的類別總共四種 agServer.MIDDLEWARE_HANDSHAKE agServer.MIDDLEWARE_INBOUND_RAW agServer.MIDDLEWARE_INBOUND from client -&gt; server agServer.MIDDLEWARE_OUTBOUND from server -&gt; client 註冊 Middleware123456789101112131415161718192021222324252627agServer.setMiddleware(agServer.MIDDLEWARE_INBOUND, async (middlewareStream) =&gt; &#123; for await (let action of middlewareStream) &#123; console.log(&quot;forawait -&gt; action.type&quot;, action.type) if (action.type === action.TRANSMIT) &#123; if (!action.data) &#123; let error = new Error( &#x27;Transmit action must have a data object&#x27; ); error.name = &#x27;InvalidActionError&#x27;; action.block(error); continue; &#125; &#125; else if (action.type === action.INVOKE) &#123; if (!action.data) &#123; let error = new Error( &#x27;Invoke action must have a data object&#x27; ); error.name = &#x27;InvalidActionError&#x27;; action.block(error); continue; &#125; // token 的物件 console.log(&quot;forawait -&gt; action.data&quot;, action.data) &#125; action.allow(); &#125;&#125;); 利用註冊 IN_BOUIND 與 OUT_BOUND 的註冊 middleware 來達成驗證 JWT token 參考資料Authorization","tags":["Nodejs","SocketCluster"],"categories":["Nodejs"]},{"title":"React Native-ExportComponentUI","path":"/2019/12/06/ReactNative-ExportComponentUI/","content":"Setup123react-native init CounterAppcd CounterAppreact-native run-ios App.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React from &#x27;react&#x27;;import &#123; StyleSheet, View, Text, TouchableOpacity,&#125; from &#x27;react-native&#x27;;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; increment = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity style=&#123;[styles.wrapper, styles.border]&#125; onPress=&#123;this.increment&#125; &gt; &lt;Text style=&#123;styles.button&#125;&gt; &#123;this.state.count&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: &quot;stretch&quot; &#125;, wrapper: &#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;, border: &#123; borderColor: &quot;#eee&quot;, borderBottomWidth: 1 &#125;, button: &#123; fontSize: 50, color: &quot;orange&quot; &#125;&#125;);export default App; How to expose a Swift UI Component to JS建立一個 Swift ViewManager File → New → File… (or CMD+N) Select Swift File Name your file CounterViewManager In the Group dropdown, make sure to select the group CounterApp, not the project itself. !select CounterApp Configure the Objective-C Bridging Header1After you create the Swift file, you should be prompted to choose if you want to configure an Objective-C Bridging Header. Select “Create Bridging Header”. configure Objective-C Bridging Header 如果您還沒有標題，請立即添加其中兩個標題 1234// CounterApp-Bridging-Header.h#import &quot;React/RCTBridgeModule.h&quot;#import &quot;React/RCTViewManager.h&quot; CounterViewManager.swift 123456789@objc(CounterViewManager)class CounterViewManager: RCTViewManager &#123; override func view() -&gt; UIView! &#123; let label = UILabel() label.text = &quot;Swift Counter&quot; label.textAlignment = .center return label &#125;&#125; 新增一個 Obj-C 檔案 File → New → File… (or CMD+N) Select Objective-C File Name your file CounterViewManager CounterViewManager.m 12345#import &quot;React/RCTViewManager.h&quot;@interface RCT_EXTERN_MODULE(CounterViewManager, RCTViewManager)@end Access your Component from JS現在你可以使用 requireNativeComponent 來使用 建立 swiftUICounterViewManager.swift 12345678910@objc(CounterViewManager)class CounterViewManager: RCTViewManager &#123; override static func requiresMainQueueSetup() -&gt; Bool &#123; return true &#125; override func view() -&gt; UIView! &#123; return CounterView() &#125;&#125; CounterView.swift 123456789101112131415161718192021222324252627282930import UIKitclass CounterView: UIView &#123; @objc var count = 0 &#123; didSet &#123; button.setTitle(String(describing: count), for: .normal) &#125; &#125; override init(frame: CGRect) &#123; super.init(frame: frame) self.addSubview(button) increment() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; lazy var button: UIButton = &#123; let b = UIButton.init(type: UIButton.ButtonType.system) b.titleLabel?.font = UIFont.systemFont(ofSize: 50) b.autoresizingMask = [.flexibleWidth, .flexibleHeight] b.addTarget( self, action: #selector(increment), for: .touchUpInside ) return b &#125;() @objc func increment() &#123; count += 1 &#125;&#125; How to send props to a Swift Component可以透過 RCT_EXPORT_VIEW_PROPERTY 來 export props 在這個範例中 將 count export CounterViewManager.m 12345#import &quot;React/RCTViewManager.h&quot;@interface RCT_EXTERN_MODULE(CounterViewManager, RCTViewManager) RCT_EXPORT_VIEW_PROPERTY(count, NSNumber)@end Important: you have to use Obj-C types for variables exposed to React Native CounterView.swift 123456789101112131415161718192021222324252627282930import UIKitclass CounterView: UIView &#123; @objc var count: NSNumber = 0 &#123; didSet &#123; button.setTitle(String(describing: count), for: .normal) &#125; &#125; override init(frame: CGRect) &#123; super.init(frame: frame) self.addSubview(button) increment() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; lazy var button: UIButton = &#123; let b = UIButton.init(type: UIButton.ButtonType.system) b.titleLabel?.font = UIFont.systemFont(ofSize: 50) b.autoresizingMask = [.flexibleWidth, .flexibleHeight] b.addTarget( self, action: #selector(increment), for: .touchUpInside ) return b &#125;() @objc func increment() &#123; count = count.intValue + 1 as NSNumber &#125;&#125; App.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React from &#x27;react&#x27;;import &#123; StyleSheet, View, Text, TouchableOpacity, requireNativeComponent,&#125; from &#x27;react-native&#x27;;const CounterView = requireNativeComponent(&quot;CounterView&quot;);class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; increment = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity style=&#123;[styles.wrapper, styles.border]&#125; onPress=&#123;this.increment&#125; &gt; &lt;Text style=&#123;styles.button&#125;&gt; &#123;this.state.count&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;CounterView style=&#123; styles.wrapper &#125; count=&#123;2&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: &quot;stretch&quot; &#125;, wrapper: &#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;, border: &#123; borderColor: &quot;#eee&quot;, borderBottomWidth: 1 &#125;, button: &#123; fontSize: 50, color: &quot;orange&quot; &#125;&#125;);export default App; Expose a Component Event Emitter接下來使用一個 function 來讓 native 使用 CounterView.swift 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import UIKitclass CounterView: UIView &#123; @objc var onUpdate: RCTDirectEventBlock? @objc var count: NSNumber = 0 &#123; didSet &#123; button.setTitle(String(describing: count), for: .normal) &#125; &#125; override init(frame: CGRect) &#123; super.init(frame: frame) self.addSubview(button) increment() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; lazy var button: UIButton = &#123; let b = UIButton.init(type: UIButton.ButtonType.system) b.titleLabel?.font = UIFont.systemFont(ofSize: 50) b.autoresizingMask = [.flexibleWidth, .flexibleHeight] b.addTarget( self, action: #selector(increment), for: .touchUpInside ) let longPress = UILongPressGestureRecognizer( target: self, action: #selector(sendUpdate(_:)) ) b.addGestureRecognizer(longPress) return b &#125;() @objc func sendUpdate(_ gesture: UILongPressGestureRecognizer) &#123; if gesture.state == .began &#123; if onUpdate != nil &#123; onUpdate!([&quot;count&quot;: count]) &#125; &#125; &#125; @objc func increment() &#123; count = count.intValue + 1 as NSNumber &#125;&#125; If you have to send any data to a RCTDirectEventBlock method, you must return a [AnyHashable:Any] structure. This means that you can’t pass a String or Int directly, you have to put them in a Dictionary. CounterViewManager.m 123456#import &quot;React/RCTViewManager.h&quot;@interface RCT_EXTERN_MODULE(CounterViewManager, RCTViewManager) RCT_EXPORT_VIEW_PROPERTY(count, NSNumber) RCT_EXPORT_VIEW_PROPERTY(onUpdate, RCTDirectEventBlock)@end 在 header 也要增加一行 Expose methods on the ViewManagerCounterApp-Bridging-Header.h 1234#import &quot;React/RCTBridgeModule.h&quot;#import &quot;React/RCTViewManager.h&quot;#import &quot;React/RCTEventEmitter.h&quot;#import &quot;React/RCTUIManager.h&quot; CounterViewManager.swift 1234567891011121314151617181920@objc(CounterViewManager)class CounterViewManager: RCTViewManager &#123; override static func requiresMainQueueSetup() -&gt; Bool &#123; return true &#125; override func view() -&gt; UIView! &#123; return CounterView() &#125; @objc func updateFromManager(_ node: NSNumber, count: NSNumber) &#123; DispatchQueue.main.async &#123; // 2 let component = self.bridge.uiManager.view( // 3 forReactTag: node // 4 ) as! CounterView // 5 component.update(value: count) // 6 &#125; &#125;&#125; CounterView.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import UIKitclass CounterView: UIView &#123; @objc var onUpdate: RCTDirectEventBlock? @objc var count: NSNumber = 0 &#123; didSet &#123; button.setTitle(String(describing: count), for: .normal) &#125; &#125; override init(frame: CGRect) &#123; super.init(frame: frame) self.addSubview(button) increment() &#125; static func requiresMainQueueSetup() -&gt; Bool &#123; return true &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; lazy var button: UIButton = &#123; let b = UIButton.init(type: UIButton.ButtonType.system) b.titleLabel?.font = UIFont.systemFont(ofSize: 50) b.autoresizingMask = [.flexibleWidth, .flexibleHeight] b.addTarget( self, action: #selector(increment), for: .touchUpInside ) let longPress = UILongPressGestureRecognizer( target: self, action: #selector(sendUpdate(_:)) ) b.addGestureRecognizer(longPress) return b &#125;() @objc func update(value: NSNumber) &#123; count = value &#125; @objc func sendUpdate(_ gesture: UILongPressGestureRecognizer) &#123; if gesture.state == .began &#123; if onUpdate != nil &#123; onUpdate!([&quot;count&quot;: count]) &#125; &#125; &#125; @objc func increment() &#123; count = count.intValue + 1 as NSNumber &#125;&#125; App.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * Sample React Native App * https://github.com/facebook/react-native * * @format * @flow */import React from &#x27;react&#x27;;import &#123; StyleSheet, View, Text, UIManager, TouchableOpacity, requireNativeComponent,&#125; from &#x27;react-native&#x27;;const CounterView = requireNativeComponent(&quot;CounterView&quot;);class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; increment = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; update = e =&gt; &#123; this.setState(&#123; count: e.nativeEvent.count &#125;) &#125; _onUpdate = event =&gt; &#123; if (this.props.onUpdate) &#123; this.props.onUpdate(event.nativeEvent); &#125; &#125;; updateNative = () =&gt; &#123; UIManager.dispatchViewManagerCommand( findNodeHandle(this.counterRef), // 1 UIManager[&quot;CounterView&quot;].Commands.updateFromManager, // 2 [this.state.count] // 3 ); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity style=&#123;[styles.wrapper, styles.border]&#125; onPress=&#123;this.increment&#125; &gt; &lt;Text style=&#123;styles.button&#125;&gt; &#123;this.state.count&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;CounterView style=&#123; styles.wrapper &#125; count=&#123;this.state.count&#125; onUpdate=&#123;this._onUpdate&#125; ref=&#123;ref =&gt; this.ref = ref&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: &quot;stretch&quot; &#125;, wrapper: &#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;, border: &#123; borderColor: &quot;#eee&quot;, borderBottomWidth: 1 &#125;, button: &#123; fontSize: 50, color: &quot;orange&quot; &#125;&#125;);export default App; 參考文章Swift in React Native","tags":["Javascript","React Native"],"categories":["React Native"]},{"title":"Moleculer-Start","path":"/2019/06/04/Moleculer-Start/","content":"UsageCreate your first microservicedemo.js 123456789101112131415161718const &#123; ServiceBroker &#125; = require(&quot;moleculer&quot;);const broker = new ServiceBroker();broker.createService(&#123; name: &quot;math&quot;, actions: &#123; add(ctx) &#123; return Number(ctx.params.a) + Number(ctx.params.b); &#125; &#125;&#125;);broker.start() // Call service .then(() =&gt; broker.call(&quot;math.add&quot;, &#123; a: 5, b: 3 &#125;)) .then(res =&gt; console.log(&quot;5 + 3 =&quot;, res)) .catch(err =&gt; console.error(`Error occured! $&#123;err.message&#125;`)); 1234567891011[2019-06-03T07:54:26.366Z] INFO ********/BROKER: Moleculer v0.13.9 is starting...[2019-06-03T07:54:26.369Z] INFO ********/BROKER: Node ID: ********[2019-06-03T07:54:26.370Z] INFO ********/BROKER: Namespace: &lt;not defined&gt;[2019-06-03T07:54:26.370Z] INFO ********/REGISTRY: Strategy: RoundRobinStrategy[2019-06-03T07:54:26.372Z] INFO ********/BROKER: Serializer: JSONSerializer[2019-06-03T07:54:26.373Z] INFO ********/BROKER: Registered 10 internal middleware(s).[2019-06-03T07:54:26.390Z] INFO ********/REGISTRY: &#x27;$node&#x27; service is registered.[2019-06-03T07:54:26.392Z] INFO ********/REGISTRY: &#x27;math&#x27; service is registered.[2019-06-03T07:54:26.394Z] INFO ********/BROKER: ServiceBroker with 2 service(s) is started successfully.5 + 3 = 8[2019-06-03T07:54:26.400Z] INFO ********/BROKER: ServiceBroker is stopped. Good bye. 看到上方範例會啟用一個 microservice 計算出 5 + 3 &#x3D; 8 之後結束這個程式 Create a Moleculer projectInstall Nats需要先安裝 Nats 如果您是選擇其他的 transporters 也需要安裝其他的套件 目前有提供的 Nats - 推薦使用 MQTT Redis NATS streaming (試驗) Kafka (試驗) Mac1$ brew install gnatsd GoInitial Project有提供一個 Cli tool install moleculer-cli 1$ npm i moleculer-cli -g create a new project 1$ moleculer init project moleculer-demo client 會提供幾個選項讓你選擇 12345678910? Add API Gateway (moleculer-web) service? // 是否使用 api gateway? Would you like to communicate with other nodes? // 是否需要和其他 nodes 溝通? Select a transporter NATS (recommended) // 使用哪一種 transporter 工具? Would you like to use cache? 是否要使用 cache? Select a cacher solution ? Add Docker files? 是否要使用 Docker? Use ESLint to lint your code? 是否使用 ESLint? Setup unit tests with Jest? Unitest frameworkCreate &#x27;moleculerdemo&#x27; folder...? Would you like to run &#x27;npm install&#x27;? 可以依據個人的需求選擇 然後就可以得到一個專案 123456789101112131415.├── README.md├── moleculer.config.js├── package-lock.json├── package.json├── public│ ├── banner.png│ ├── favicon.ico│ └── index.html├── services│ ├── api.service.js│ └── greeter.service.js└── test └── unit └── greeter.spec.js 1$ yarn dev // 啟動一個 service BrokerServiceBroker 是 Moleculer 中主要的 component 他會處理幾件 nodes 之間溝通的事情 actions emits events communicates Ping對遠端的 nodes 使用 broker.ping 來確認遠端 nodes 的狀態 回傳值是一個 Promise Exampleping 一個 node 並設定 1S 的 timeout 1broker.ping(&quot;node-123&quot;, 1000).then(res =&gt; broker.logger.info(res)); output 12345&#123; nodeID: &#x27;node-123&#x27;, elapsedTime: 16, timeDiff: -3 &#125; 1timeDiff 是兩個節點之間系統時間的誤差值 也可以同時 ping 多個 nodes 1broker.ping([&quot;node-100&quot;, &quot;node-102&quot;]).then(res =&gt; broker.logger.info(res)); output 123456789101112&#123; &quot;node-100&quot;: &#123; nodeID: &#x27;node-100&#x27;, elapsedTime: 10, timeDiff: -2 &#125;, &quot;node-102&quot;: &#123; nodeID: &#x27;node-102&#x27;, elapsedTime: 250, timeDiff: 850 &#125; &#125; ping 所有的 nodes 1broker.ping().then(res =&gt; broker.logger.info(res)); output 123456789101112131415161718&#123; &quot;node-100&quot;: &#123; nodeID: &#x27;node-100&#x27;, elapsedTime: 10, timeDiff: -2 &#125; , &quot;node-101&quot;: &#123; nodeID: &#x27;node-101&#x27;, elapsedTime: 18, timeDiff: 32 &#125;, &quot;node-102&quot;: &#123; nodeID: &#x27;node-102&#x27;, elapsedTime: 250, timeDiff: 850 &#125; &#125; broker properties broker methods ServicesServices 代表 Moleculer 中的微服務 可以定義多個 action 並且訂閱 ‘event’ 建立新的 service 必須先定義好 schema 這些 schema 類似 component of Vuejs name version settings methods events Actions基本的 schema 1234&#123; name: &quot;posts&quot;, version: 1&#125; 定義多個 actions 123456789101112&#123; name: &quot;math&quot;, actions: &#123; add(ctx) &#123; return Number(ctx.params.a) + Number(ctx.params.b); &#125;, sub(ctx) &#123; return Number(ctx.params.a) - Number(ctx.params.b); &#125; &#125;&#125; name 是必須要定義的參數 當你呼叫這個 api 時，是第一部分的 route 組成元素 12345// 可以在設定中 disable service name prefix&#123; $noServiceNamePrefix: true&#125; version 不是必要的參數 可以讓同樣的 service 跑不同的 version 做 api 版本控制 可以是 Number 和 String 1234567&#123; name: &quot;posts&quot;, version: 2, actions: &#123; find() &#123;...&#125; &#125;&#125; 在上方的範例中若是要呼叫這隻 API route 為 GET /v2/posts/find Settingssettings 是一個 store 你可以在裡面做各種設定 使用 this.settings 取得你的 setting object setting options MixinsMixins 是一個可以在 Moleculer 中可以重複使用的 function Service 的 constructor 會自動合併這些 mixins 123456789101112131415const ApiGwService = require(&quot;moleculer-web&quot;);module.exports = &#123; name: &quot;api&quot;, mixins: [ApiGwService] settings: &#123; // Change port setting port: 8080 &#125;, actions: &#123; myAction() &#123; // Add a new action to apiGwService service &#125; &#125;&#125; 合併的規則 Lifecycle events當 service 生命週期各自會 trigger 的 function startd stopped created Dependencies當你的 service 有依賴到其他 service 的時候 可以利用 Dependencies 來做處理(待捕) Hot reloading services在開發過程中需要使用 hot reloading 的機制有兩種方式 12345const broker = new ServiceBroker(&#123; hotReload: true&#125;);broker.loadService(&quot;./services/test.service.js&quot;); 或是 command 1$ moleculer-runner --hot ./services/test.service.js Local variables如果你需要一些 Local variables 可以在 created 中宣告 12345678910111213141516171819202122232425262728293031const http = require(&quot;http&quot;);module.exports = &#123; name: &quot;www&quot;, settings: &#123; port: 3000 &#125;, created() &#123; // Create HTTP server this.server = http.createServer(this.httpHandler); &#125;, started() &#123; // Listening... this.server.listen(this.settings.port); &#125;, stopped() &#123; // Stop server this.server.close(); &#125;, methods() &#123; // HTTP handler httpHandler(req, res) &#123; res.end(&quot;Hello Moleculer!&quot;); &#125; &#125;&#125; ES6 classses1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const Service = require(&quot;moleculer&quot;).Service;class GreeterService extends Service &#123; constructor(broker) &#123; super(broker); this.parseServiceSchema(&#123; name: &quot;greeter&quot;, version: &quot;v2&quot;, meta: &#123; scalable: true &#125;, dependencies: [ &quot;auth&quot;, &quot;users&quot; ], settings: &#123; upperCase: true &#125;, actions: &#123; hello: this.hello, welcome: &#123; cache: &#123; keys: [&quot;name&quot;] &#125;, params: &#123; name: &quot;string&quot; &#125;, handler: this.welcome &#125; &#125;, events: &#123; &quot;user.created&quot;: this.userCreated &#125;, created: this.serviceCreated, started: this.serviceStarted, stopped: this.serviceStopped, &#125;); &#125; // Action handler hello() &#123; return &quot;Hello Moleculer&quot;; &#125; // Action handler welcome(ctx) &#123; return this.sayWelcome(ctx.params.name); &#125; // Private method sayWelcome(name) &#123; this.logger.info(&quot;Say hello to&quot;, name); return `Welcome, $&#123;this.settings.upperCase ? name.toUpperCase() : name&#125;`; &#125; // Event handler userCreated(user) &#123; this.broker.call(&quot;mail.send&quot;, &#123; user &#125;); &#125; serviceCreated() &#123; this.logger.info(&quot;ES6 Service created.&quot;); &#125; serviceStarted() &#123; this.logger.info(&quot;ES6 Service started.&quot;); &#125; serviceStopped() &#123; this.logger.info(&quot;ES6 Service stopped.&quot;); &#125;&#125;module.exports = GreeterService;","tags":["Nodejs","Microservies"],"categories":["Nodejs"]},{"title":"React Native-Platform","path":"/2019/02/24/RN-Platform/","content":"PlatformPlatform Specific Code在初期的時候可以利用檔案模式來做整合 可以將檔案名稱命名為 .ios.js 和 .android.js 然後在不同的平台上 require 不同的檔案 Example12BigButton.ios.jsBigButton.android.js 然後就可以在你想要的地方 import 檔案 1import BigButton from &#x27;./BigButton&#x27;; 因為 React Native 是跨平台的 Framework 畢竟 IOS Android 之間還是有相當的不同之處 可以利用 Platform 這個模組來統一的整理 12345import &#123;Platform, StyleSheet&#125; from &#x27;react-native&#x27;;const styles = StyleSheet.create(&#123; height: Platform.OS === &#x27;ios&#x27; ? 200 : 100,&#125;); Platform module 會依據平台來執行相對應的程式碼 如果是 ios 的話 height 是 200 如果是 android 的話 height 是 100 另外也有 Platform.select 可以使用 123456789101112131415import &#123;Platform, StyleSheet&#125; from &#x27;react-native&#x27;;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, ...Platform.select(&#123; ios: &#123; backgroundColor: &#x27;red&#x27;, &#125;, android: &#123; backgroundColor: &#x27;blue&#x27;, &#125;, &#125;), &#125;,&#125;); 上述程式碼中使用到 container Style 的都會有 flex: 1 的參數 但是在 ios 中會是紅色 在 android 中會是藍色的背 景色 123456789101112131415161718192021222324252627import React from &#x27;react&#x27;;import &#123; StyleSheet, Text, View, Platform &#125; from &#x27;react-native&#x27;;const SpecificPlatformComponent = Platform.select(&#123; ios: () =&gt; &lt;Text&gt;I am use IOS&lt;/Text&gt;, android: () =&gt; &lt;Text&gt;I am use Android&lt;/Text&gt;,&#125;);export default class App extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt; &lt;SpecificPlatformComponent /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: &#x27;#fff&#x27;, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27;, &#125;,&#125;); 或是像是這樣也可以依據不同的平台引用 component OS Version12345678910111213141516171819202122232425262728293031323334import React from &#x27;react&#x27;;import &#123; StyleSheet, Text, View, Platform &#125; from &#x27;react-native&#x27;;const SpecificPlatformComponent = Platform.select(&#123; ios: () =&gt; &lt;Text&gt;I am use IOS&lt;/Text&gt;, android: () =&gt; &lt;Text&gt;I am use Android&lt;/Text&gt;,&#125;);const SpecificPlatformVersionComponent = Platform.select(&#123; ios: () =&gt; &lt;Text&gt;my Iphone Version is &#123;Platform.Version&#125;&lt;/Text&gt;, android: () =&gt; &lt;Text&gt;my Android Version is &#123;Platform.Version&#125;&lt;/Text&gt;,&#125;);export default class App extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt; &lt;SpecificPlatformComponent /&gt; &lt;SpecificPlatformVersionComponent /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: &#x27;#fff&#x27;, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27;, &#125;,&#125;);","tags":["Javascript","React Native","React"],"categories":["React Native"]},{"title":"Truffle-pet-user-interface","path":"/2019/02/07/Truffle-pet-user-interface/","content":"Truffle pet demo延續 建立一個前端介面上一篇初始化的程式中也包含了前端的程式碼 但是只有一部分 需要做一些補全 打開 /src/js/app.js app.js 裡面已經有 一個物件叫做 App 控制我們的前端 init() 負責 load data initWeb3() web3 lib他可以取回使用者帳號的資訊，發送交易需求 移除 initWeb3() 中的註解 加上下面這段程式碼 12345678910111213141516171819initWeb3: async function() &#123; if(window.ethereum) &#123; App.web3Provider = window.ethereum; try &#123; await window.ethereum.enable(); &#125; catch (error) &#123; console.error(&quot;User denied account access&quot;) &#125; &#125; else if(window.web3) &#123; App.web3Provider = window.web3.currentProvider; &#125; else &#123; App.web3Provider = new Web3.providers.HttpProvider(&#x27;http://localhost:7545&#x27;); &#125; web3 = new Web3(App.web3Provider); return App.initContract(); &#125;, 先檢查瀏覽器中是否有 ethereum provider 如果有的話就建立自己的 web3 物件來取得帳號資訊，但是依舊要呼叫 ethereum.enable() 如果 ethereum 不存在，檢查 window.web3 是否存在來引用舊版的 provider 如果沒有的話就是測試使用 localhost:7545 Instantiating the contract處理好 web3 的初始化之後 現在需要來解決一下如何實際在前端取得合約的資料 truffle 有一個 lib 可以協助處理這件事情: truffle-contract 他會在 有新的 migrations 同步合約上的資訊 所以你不用修改合約的位址 /src/js/app.js 中有 initContract 的函式 123456789101112initContract: function() &#123; $.getJSON(&#x27;Adoption.json&#x27;, function(data) &#123; const AdoptionArtifact = data; App.contracts.Adoption = TruffleContract(AdoptionArtifact); App.contracts.Adoption.setProvider(App.web3Provider); return App.markAdopted(); &#125;); return App.bindEvents();&#125;, 先檢索在鏈上的合約文件，AdoptionArtifact 是合約的內容資訊，包含位址 DApp 接口(ABI) 一但我們取得 Artifact 會將他 pass 給 TruffleContract(). 他會產生一個新的物件，這個物件會提供一下 method 讓我們可以跟合約溝通 產生的 實例會設定給 App.web3Provider 以方便 web3使用 然後呼叫 APP 的 markAdopted() function 封裝這個是因為方便在合約改變的時候可以同時改變 UI 12Note: ABI: Application Binary Interface 應用程式機器碼介面ABI 是一個 Javascript 對象，用來定義如何跟合約相互溝通的接口 Getting The Adopted Pets and Updating The UI在 /src/js/app.js 中移除 markAdopted 中的註解並填入下述程式碼 12345678910111213141516markAdopted: function(adopters, account) &#123; let adoptionInstance; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; return adoptionInstance.call(); &#125;).then(function(adopters) &#123; for(i=0; i&lt;adopters.length; i++) &#123; if(adopters[i] !== &#x27;0x0000000000000000000000000000000000000000&#x27;) &#123; $(&#x27;.panel-pet&#x27;).eq(i).find(&#x27;button&#x27;).text(&#x27;Success&#x27;).attr(&#x27;disabled&#x27;, true); &#125; &#125; &#125;).catch(function(error) &#123; console.log(error.message) &#125;);&#125;, 這一段程式碼中闡述了 同意部署 Adoption 合約，然後呼叫 getAdopters() 在這個實例中 因為宣告了adoptionInstance 在最外面，所以在之後可以呼叫他 call() 可以讓我們讀取資料而不用發送一個交易，代表我們不用花費任何乙太幣 呼叫 getAdopters() 使用一個迴圈訪問所有的 pet 確定是否已經有了位址，因為以太使用 16 個位元的初始值，而不是用 null 如果找到有相對應位址的就禁用按鈕並將按鈕的文字改為 成功 以便使用者了解這些資訊 所有的錯誤都會顯示在 console Handling the adopt() Function依舊是在 /src/js/app.js 中，移除 handleAdopt 函式中的註解，替換為下列程式碼 12345678910111213141516171819202122232425handleAdopt: function(event) &#123; event.preventDefault(); let petId = parseInt($(event.target).data(&#x27;id&#x27;)); let adoptionInstance; web3.eth.getAccounts(function(error, accounts) &#123; if(error) &#123; console.log(error); &#125; let account = accounts[0]; App.contracts.Adoption.deployed() .then(function(instance) &#123; adoptionInstance = instance; return adoptionInstance.adopt(petId, &#123;from: account&#125;); &#125;).then(function(result) &#123; return App.markAdopted(); &#125;).catch(function(error) &#123; console.log(error.message); &#125;); &#125;);&#125; 利用 web3 取得使用者帳號列，含有 error 檢查是否錯誤，若無誤 取第一個帳號 在這裡已經取得部署成功的合約，將它 指定給 adoptionInstance 這個變數，這一次我們會發送一個交易請求而且必須要有 from 這個位址，這個動作會產生一些費用，在乙太中 這個費用叫做 gas，這是一種手續費用，在你儲存或是計算的時候需要付出部分 gas adopt() 中含有 寵物的 ID 和一個物件，這些資訊會被儲存在 account中 發送交易後的結果是一個物件，如果沒有錯誤的話會呼叫 markAdopted() 來同步 UI 和儲存的資訊 最簡單的方式是透過 MetaMask 這個在 chrome 和 firefox 都有相關的擴充套件 安裝 MetaMask 點擊同意 在 MetaMask 中選擇 New RPC URL 並且輸入 http://127.0.0.1:7545 Installing and configuring lite-server可以起一個 local 的 service 來看看結果 編輯 bs-config.json 改為下述程式碼 12345&#123; &quot;server&quot;: &#123; &quot;baseDir&quot;: [&quot;./src&quot;, &quot;./build/contracts&quot;] &#125;&#125; 1$ npm run dev Result","tags":["Truffle","Sodility"],"categories":["Block Chain"]},{"title":"RN-JestInReactNative","path":"/2019/01/08/RN-JestInReactNative/","content":"Initial project我又重新來接觸一次 React Native 但是修改的部分太多了 重新做了一次部署架構 發現又多了一些問題 紀錄一下過程 一開始一定是先 initial project helloworld 123456789101112$ react-native init helloworld$ yarn test&gt; helloword@0.0.1 test /Users/linweiqin/Projects/helloword&gt; jestNo tests foundIn /Users/linweiqin/Projects/helloword 645 files checked. testMatch: **/__tests__/**/*.js?(x),**/?(*.)+(spec|test).js?(x) - 1 match testPathIgnorePatterns: /node_modules/ - 7 matchesPattern: - 0 matchesnpm ERR! Test failed. See above for more details. 因為我是使用 redux-saga 所以建一個測試 tests&#x2F;saga.test.js 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; testSaga &#125; from &#x27;redux-saga-test-plan&#x27;;import &#123; take, put, call&#125; from &quot;redux-saga/effects&quot;;function identity(value) &#123; return value;&#125;function* mainSaga(x, y) &#123; const action = yield take(&#x27;HELLO&#x27;); yield put(&#123; type: &#x27;ADD&#x27;, payload: x + y &#125;); yield call(identity, action);&#125;const action = &#123; type: &#x27;TEST&#x27; &#125;;it(&#x27;works with unit tests&#x27;, () =&gt; &#123; testSaga(mainSaga, 40, 2) // advance saga with `next()` .next() // assert that the saga yields `take` with `&#x27;HELLO&#x27;` as type .take(&#x27;HELLO&#x27;) // pass back in a value to a saga after it yields .next(action) // assert that the saga yields `put` with the expected action .put(&#123; type: &#x27;ADD&#x27;, payload: 42 &#125;) .next() // assert that the saga yields a `call` to `identity` with // the `action` argument .call(identity, action) .next() // assert that the saga is finished .isDone();&#125;); 123$ yarn add redux-saga$ yarn add -D redux-saga-test-plan$ yarn test 在 package.json 要加上一個設定 123456789&#123; ..., &quot;jest&quot;: &#123; &quot;preset&quot;: &quot;react-native&quot;, &quot;transform&quot;: &#123; &quot;^.+\\\\.js$&quot;: &quot;&lt;rootDir&gt;/node_modules/react-native/jest/preprocessor.js&quot; &#125; &#125;&#125; 基本上這樣可以測試一般的 但是希望可以測試 Component App.test.js 12345678910// __tests__/App.test.jsimport React from &#x27;react&#x27;;import App from &#x27;../App&#x27;;import renderer from &#x27;react-test-renderer&#x27;;test(&#x27;renders correctly&#x27;, () =&gt; &#123; const tree = renderer.create(&lt;App /&gt;).toJSON(); expect(tree).toMatchSnapshot();&#125;); React 與 React Native如果使用同一個架構的話 React 與 React Native 是大同小異的 但是基於兩個的底層是完全不同的 一個是 Web HTML 一個是 Native code 希望使用盡量一致的 Lib 來做測試似乎困難度有點高 雖然尚未有完全無違和的測試 還是可以利用 Jest + Enzyme + Jsdom 來為 React Native 模擬 mount 環境 續前章 初步使用 Jest + Enzyme 做 React Native 測試 如果要在 測試中使用 mount 的話 會顯示 document is undefined 的錯誤 所以為了彌補這個問題 我們需要做一些補充 shallow and mount 的不同shallowshallow 針對 Component 做單一的單元測試，並不會直接顯示他的 Children Component mountmount 會完整的 render 所有的 Component 包含他下層的所有 Component 123456789101112131415import React from &#x27;react&#x27;;import App from &#x27;../App&#x27;;import &#123; mount, shallow &#125; from &#x27;enzyme&#x27;;import renderer from &#x27;react-test-renderer&#x27;;test(&#x27;renders correctly&#x27;, () =&gt; &#123; const tree = renderer.create(&lt;App /&gt;).toJSON(); expect(tree).toMatchSnapshot();&#125;);test(&#x27;mount component&#x27;, () =&gt; &#123; const wrapper = shallow(&lt;App /&gt;); &#125;); 會產生這個錯誤 因為找不到 global document 1$ yarn add enzyme jest-enzyme enzyme-adapter-react-16 enzyme-react-16-adapter-setup --dev 需要再 package.json 中增加 12345678910111213&#123; ..., &quot;jest&quot;: &#123; &quot;preset&quot;: &quot;react-native&quot;, &quot;setupTestFrameworkScriptFile&quot;: &quot;./node_modules/jest-enzyme/lib/index.js&quot;, &quot;setupFiles&quot;: [ &quot;enzyme-react-16-adapter-setup&quot; ], &quot;transform&quot;: &#123; &quot;^.+\\\\.js$&quot;: &quot;&lt;rootDir&gt;/node_modules/react-native/jest/preprocessor.js&quot; &#125; &#125;&#125; 缺少了 react-dom 1$ yarn add react-dom --dev 這時候就可以執行了 但是因為 shallow 只能 render 一層 如果要完整 render 的話要使用 mount 但是這樣會造成因為找不到 global document \b要先增加 setupFile.js 1$ yarn add jsdom enzyme-adapter-react-16 react-native-mock-render --dev 123456789101112131415161718192021222324252627282930const &#123; JSDOM &#125; = require(&#x27;jsdom&#x27;);const jsdom = new JSDOM();const &#123; window &#125; = jsdom;function copyProps(src, target) &#123; const props = Object.getOwnPropertyNames(src) .filter(prop =&gt; typeof target[prop] === &#x27;undefined&#x27;) .map(prop =&gt; Object.getOwnPropertyDescriptor(src, prop)); Object.defineProperties(target, props);&#125;global.window = window;global.document = window.document;global.navigator = &#123; userAgent: &#x27;node.js&#x27;,&#125;;copyProps(window, global);import Enzyme from &quot;enzyme&quot;;import Adapter from &quot;enzyme-adapter-react-16&quot;;Enzyme.configure(&#123; adapter: new Adapter() &#125;);// Ignore React Web errors when using React Nativeconsole.error = (message) =&gt; &#123; return message;&#125;;require(&#x27;react-native-mock-render/mock&#x27;); 1$ yarn remove enzyme-react-16-adapter-setup package.json 也要做一些調整 12345678910111213141516171819202122&#123; ..., &quot;jest&quot;: &#123; &quot;preset&quot;: &quot;react-native&quot;, &quot;cacheDirectory&quot;: &quot;./cache&quot;, &quot;coveragePathIgnorePatterns&quot;: [ &quot;./app/utils/vendor&quot; ], &quot;coverageThreshold&quot;: &#123; &quot;global&quot;: &#123; &quot;statements&quot;: 80 &#125; &#125;, &quot;transformIgnorePatterns&quot;: [ &quot;/node_modules/(?!react-native|react-clone-referenced-element|react-navigation)&quot; ], &quot;transform&quot;: &#123; &quot;^.+\\\\.js$&quot;: &quot;&lt;rootDir&gt;/node_modules/react-native/jest/preprocessor.js&quot; &#125;, &quot;setupTestFrameworkScriptFile&quot;: &quot;./setupFile.js&quot; &#125;&#125;","tags":["Javascript","React Native","React"],"categories":["React Native"]},{"title":"RN-code-push","path":"/2019/01/02/RN-code-push/","content":"Initial React Native App1$ npx react-native init codepushdemo &amp;&amp; cd codepushdemo Install code push123456789101112131415# Install the CLI$ npm install -g code-push-cli$ npm install -g appcenter-cli# Register for an account via github or email (if you have code-push account you could use **code-push login**)$ code-push register# Register your app. We call it AwesomeApp.$ code-push app add codepushdemo-ios ios react-native$ code-push app add codepushdemo-android android react-native# prepare app center$ yarn add appcenter appcenter-analytics appcenter-crashes --save-exact$ cd ios &amp;&amp; pod install &amp;&amp; cd .. 12345**Note:**link 完之 IOS 會自動使用 Pod 所以在 local 端 Xcode 要開啟 `XXXXX.xcworkspace` 才能正常開發 IOSreleasing-updates Gitcode-push 官方只支援 github bitbucket 和 microsoft devops 三種版控 這次使用 bitbucket 做 Demo 要先在 bitbucket 建立一個新的 repo 參考資料來源Get started with ‘CodePush’ (React-Native) IOS Setup Android Setup","tags":["Javascript","React Native","React"],"categories":["React Native"]},{"title":"material-ui-themes","path":"/2018/11/29/material-ui-themes/","content":"sourcematerial-ui themes ContentPalette針對 Application 設定幾個基礎色 theme 中提供幾個 key 來設定基礎色 primary - 主要的顏色 secondary - 次要的顏色 error - 顯示錯誤的時候的顏色 Custom palette在 theme 有 [palette.primary](https://material-ui.com/customization/default-theme/?expend-path=$.palette.primary), [palette.secondary](https://material-ui.com/customization/default-theme/?expend-path=$.palette.secondary), [palette.error](https://material-ui.com/customization/default-theme/?expend-path=$.palette.error) 三個物件可以複寫 在上述三個物件中各有 light, main, dark, contrastText 四個參數可以提供修改 可以直接放入顏色的物件作設定 12345678import &#123; createMuiTheme &#125; from &#x27;@material-ui/core/styles&#x27;;import blue from &#x27;@material-ui/core/colors/blue&#x27;;const theme = createMuiTheme(&#123; palette: &#123; primary: blue, &#125;,&#125;); 也可以依據各個不同的狀況做設定 1234567891011121314151617181920palette: &#123; primary: &#123; light: palette.primary[300], main: palette.primary[500], dark: palette.primary[700], contrastText: getContrastText(palette.primary[500]), &#125;, secondary: &#123; light: palette.secondary.A200, main: palette.secondary.A400, dark: palette.secondary.A700, contrastText: getContrastText(palette.secondary.A400), &#125;, error: &#123; light: palette.error[300], main: palette.error[500], dark: palette.error[700], contrastText: getContrastText(palette.error[500]), &#125;,&#125;, 這個範例說明如何重新建立一個預設 palette 123456789101112131415161718import &#123; createMuiTheme &#125; from &#x27;@material-ui/core/styles&#x27;;import indigo from &#x27;@material-ui/core/colors/indigo&#x27;;import pink from &#x27;@material-ui/core/colors/pink&#x27;;import red from &#x27;@material-ui/core/colors/red&#x27;;// All the following keys are optional.// We try our best to provide a great default value.const theme = createMuiTheme(&#123; palette: &#123; primary: indigo, secondary: pink, error: red, // 提供 getContrastText() 使用的值，最大化背景之間的對比度 contrastThreshold: 3, // E.g., shift from Red 500 to Red 300 or Red 700. tonalOffset: 0.2, &#125;,&#125;); 也可以客製化自己的顏色 12345678910111213141516171819import &#123; createMuiTheme &#125; from &#x27;@material-ui/core/styles&#x27;;const theme = createMuiTheme(&#123; palette: &#123; primary: &#123; // light: will be calculated from palette.primary.main, main: &#x27;#ff4400&#x27;, // dark: will be calculated from palette.primary.main, // contrastText: will be calculated to contrast with palette.primary.main &#125;, secondary: &#123; light: &#x27;#0066ff&#x27;, main: &#x27;#0044ff&#x27;, // dark: will be calculated from palette.secondary.main, contrastText: &#x27;#ffcc00&#x27;, &#125;, // error: will use the default color &#125;,&#125;); 也有提供 color tools Type(light&#x2F;dark theme)你可以透過修改 type 改為 dark 來將佈景變暗 雖然只有改變一個參數 但是下述的 key 都會受到影響 palette.text palette.divider palette.background palette.action Typography一次太多字型 類型大小和 Style 會破壞 Layout 提供一組有限的 Style 來限制 Typography 可以使用在任何的 component 中 Typography section Font family1234567891011121314151617const theme = createMuiTheme(&#123; typography: &#123; // Use the system font instead of the default Roboto font. fontFamily: [ &#x27;-apple-system&#x27;, &#x27;BlinkMacSystemFont&#x27;, &#x27;&quot;Segoe UI&quot;&#x27;, &#x27;Roboto&#x27;, &#x27;&quot;Helvetica Neue&quot;&#x27;, &#x27;Arial&#x27;, &#x27;sans-serif&#x27;, &#x27;&quot;Apple Color Emoji&quot;&#x27;, &#x27;&quot;Segoe UI Emoji&quot;&#x27;, &#x27;&quot;Segoe UI Symbol&quot;&#x27;, ].join(&#x27;,&#x27;), &#125;,&#125;); Material-UI 的字型大小預設使用 rem 但是他會依據 &lt;html&gt; 的預設字型大小改變 一般來說預設是 16px browser 沒有提供修改的方式 所以 units 提供一個方式來修改設定提升使用者體驗 修改 font-size 為 12 預設是 14 HTML font size1234567const theme = createMuiTheme(&#123; typography: &#123; // In Japanese the characters are usually larger. fontSize: 12, htmlFontSize: 10, &#125;,&#125;); 瀏覽器計算字型大小是透過這個公式 Custom variables也可以透過 styling solution 來客製化你的 component 1234567891011121314151617181920212223242526272829303132333435363738394041import React from &#x27;react&#x27;;import Checkbox from &#x27;@material-ui/core/Checkbox&#x27;;import &#123; createMuiTheme, MuiThemeProvider, withStyles &#125; from &#x27;@material-ui/core/styles&#x27;;import orange from &#x27;@material-ui/core/colors/orange&#x27;;const styles = theme =&gt; (&#123; root: &#123; color: theme.status.danger, &#x27;&amp;$checked&#x27;: &#123; color: theme.status.danger, &#125;, &#125;, checked: &#123;&#125;,&#125;);let CustomCheckbox = props =&gt; &lt;Checkbox defaultChecked classes=&#123;&#123; root: props.classes.root, checked: props.classes.checked, &#125;&#125; /&gt;CustomCheckbox = withStyles(styles)(CustomCheckbox);const theme = createMuiTheme(&#123; status: &#123; danger: orange[500], &#125;,&#125;);function StylingComponent() &#123; return ( &lt;MuiThemeProvider theme=&#123;theme&#125;&gt; &lt;CustomCheckbox /&gt; &lt;/MuiThemeProvider&gt; );&#125;export default StylingComponent; Customizing all instances of a component type有時候要針對單一 Component 做設定的時候可以用 overrides 這個 keyword 來做複寫 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from &#x27;react&#x27;;import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123;MuiThemeProvider, createMuiTheme&#125; from &#x27;@material-ui/core/styles&#x27;;import &#123;purple, green, blue&#125; from &#x27;@material-ui/core/colors&#x27;;import Example from &#x27;./Example&#x27;;import &#123; Button, Typography &#125; from &#x27;@material-ui/core&#x27;;import ListItems from &#x27;./ListItems&#x27;;import StylingComponent from &#x27;./StylingComponent&#x27;;const theme = createMuiTheme(&#123; overrides: &#123; // Name of the component ⚛️ / style sheet MuiButton: &#123; // Name of the rule root: &#123; // Some CSS background: &#x27;linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)&#x27;, borderRadius: 3, border: 0, color: &#x27;white&#x27;, height: 48, padding: &#x27;0 30px&#x27;, boxShadow: &#x27;0 3px 5px 2px rgba(255, 105, 135, .3)&#x27;, &#125;, &#125;, &#125;,&#125;);class App extends Component &#123; render() &#123; return ( &lt;MuiThemeProvider theme=&#123;theme&#125;&gt; &lt;Button&gt;hello&lt;/Button&gt; &lt;/MuiThemeProvider&gt; ); &#125;&#125;export default App; Properties也可以傳入 properties 使用 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123;MuiThemeProvider, createMuiTheme&#125; from &#x27;@material-ui/core/styles&#x27;;import &#123;purple, green, blue&#125; from &#x27;@material-ui/core/colors&#x27;;import &#123; Button &#125; from &#x27;@material-ui/core&#x27;;const theme = createMuiTheme(&#123; props: &#123; // Name of the component ⚛️ MuiButton: &#123; // The properties to apply disableRipple: true, // No more ripple, on the whole application 💣! &#125;, &#125;&#125;);class App extends Component &#123; render() &#123; return ( &lt;MuiThemeProvider theme=&#123;theme&#125;&gt; &lt;Button&gt;hello&lt;/Button&gt; &lt;/MuiThemeProvider&gt; ); &#125;&#125;export default App; 可以看到結果 ripple 會被 disabled Accessing the theme in a component有時候會希望在某些 Component 中使用 theme 的變數 這時候可以使用 withTheme 範例如下 123456789101112131415161718192021222324252627282930313233343536import React from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;import Typography from &#x27;@material-ui/core/Typography&#x27;;import &#123; withTheme &#125; from &#x27;@material-ui/core/styles&#x27;;function WithTheme(props) &#123; const &#123; theme &#125; = props; const primaryText = theme.palette.text.primary; const primaryColor = theme.palette.primary.main; const styles = &#123; primaryText: &#123; backgroundColor: theme.palette.background.default, padding: `$&#123;theme.spacing.unit&#125;px $&#123;theme.spacing.unit * 2&#125;px`, color: primaryText, &#125;, primaryColor: &#123; backgroundColor: primaryColor, padding: `$&#123;theme.spacing.unit&#125;px $&#123;theme.spacing.unit * 2&#125;px`, color: theme.palette.common.white, &#125;, &#125;; return ( &lt;div style=&#123;&#123; width: 300 &#125;&#125;&gt; &lt;Typography style=&#123;styles.primaryColor&#125;&gt;&#123;`Primary color $&#123;primaryColor&#125;`&#125;&lt;/Typography&gt; &lt;Typography style=&#123;styles.primaryText&#125;&gt;&#123;`Primary text $&#123;primaryText&#125;`&#125;&lt;/Typography&gt; &lt;/div&gt; );&#125;WithTheme.propTypes = &#123; theme: PropTypes.object.isRequired,&#125;;export default withTheme()(WithTheme); // Let&#x27;s get the theme as a property","tags":["Css","Themes","Material-design"],"categories":["Css"]},{"title":"ReasonReact-LifeCycle","path":"/2018/11/13/ReasonReact-lifeCycle/","content":"LifeCycleReasonReact 也有類似 ReactJS 的生命週期 didMount: self &#x3D;&gt; unit willReceiveProps: self &#x3D;&gt; state shouldUpdate: oldAndNewSelf &#x3D;&gt; bool willUpdate: oldAndNewSelf &#x3D;&gt; unit didUpdate: oldAndNewSelf &#x3D;&gt; unit willUnmount: self &#x3D;&gt; unit Note 移除了所有 component 前綴 willReceiveProps 需要回傳的是 state 預設是假設你每次都要修改狀態，不然也可以直接回傳 state didUpdate, willUnmount 和 willUpdate 不可以修改 state 不支援 willMount 請用 didMount didUpdate, willUpdate 和 shouldUpdate 的 input 是 oldAndNewSelf record, 類型是 &#123;oldSelf: self, newSelf: self&#125; 如果你真的在 lifecycle 中修改 state, 請發一個 Action self.send(DidMountUpdate) retainedPropsReactJS 中有時會使用到 prevProps(componentDidUpdate) 或是 nextProps(componentWillUpdate) 這類的 API 但是 ReasonReact 中沒有這個部分, 則是要使用 retainedProps 來實現 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172type item = &#123; title: string, completed: bool&#125;;type retainedProps = &#123;message: string&#125;;module TodoItem = &#123; let component = ReasonReact.statelessComponentWithRetainedProps(&quot;TodoItem&quot;); let make = (~item, ~message, _children) =&gt; &#123; ...component, retainedProps: &#123;message: message&#125;, didUpdate: (&#123;oldSelf, newSelf&#125;) =&gt; &#123; if (oldSelf.retainedProps.message !== newSelf.retainedProps.message) &#123; Js.log(&quot;props `message` changed!&quot;) &#125; &#125;, render: (_self) =&gt; &lt;div className=&quot;item&quot;&gt; &lt;input checked=(item.completed) /* TODO make interactive */ /&gt; (ReasonReact.string(item.title)) &lt;/div&gt; &#125;;&#125;;type state = &#123;items: list(item)&#125;;type action = | AddItem;let component = ReasonReact.reducerComponent(&quot;TodoApp&quot;);let newItem = () =&gt; &#123;title: &quot;Click a button&quot;, completed: true&#125;;let make = (_children) =&gt; &#123; ...component, initialState: () =&gt; &#123; items: [ &#123;title: &quot;Write some things to do&quot;, completed: false&#125; ] &#125;, reducer: (action, &#123;items&#125;) =&gt; switch action &#123; | AddItem =&gt; ReasonReact.Update(&#123;items: [newItem(), ...items]&#125;) &#125;, render: (self) =&gt; &#123; let numItems = List.length(self.state.items); &lt;div className=&quot;app&quot;&gt; &lt;div className=&quot;title&quot;&gt; (ReasonReact.string(&quot;What to do&quot;)) &lt;button onClick=(_event =&gt; self.send(AddItem))&gt; (ReasonReact.string(&quot;Add something&quot;)) &lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; ( self.state.items |&gt; List.map((item) =&gt; &lt;TodoItem item /&gt;) |&gt; Array.of_list |&gt; ReasonReact.array ) &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; (ReasonReact.string(&quot;Nothing&quot;)) &lt;/div&gt; &lt;div className=&quot;footer&quot;&gt; (ReasonReact.string(string_of_int(numItems) ++ &quot; items&quot;)) &lt;/div&gt; &lt;/div&gt; &#125;&#125;; ReasonReact 提供了 ReasonReact.statelessComponentWithRetainedProps 和 ReasonReact.reducerComponentWithRetainedProps 這兩個方法只是讓你的 make 函數中可以多一個 retainedProps willReceiveProps1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677type item = &#123; title: string, completed: bool&#125;;type retainedProps = &#123;message: string&#125;;module TodoItem = &#123; let component = ReasonReact.statelessComponentWithRetainedProps(&quot;TodoItem&quot;); let make = (~item, ~message, _children) =&gt; &#123; ...component, retainedProps: &#123;message: message&#125;, willReceiveProps: (self) =&gt; &#123; if (self.retainedProps.message === message) &#123; Js.log(&quot;willReceiveProps&quot;); &#125;; &#125;, didUpdate: (&#123;oldSelf, newSelf&#125;) =&gt; &#123; if (oldSelf.retainedProps.message !== newSelf.retainedProps.message) &#123; Js.log(&quot;props `message` changed!&quot;) &#125; &#125;, render: (_self) =&gt; &lt;div className=&quot;item&quot;&gt; &lt;input checked=(item.completed) /* TODO make interactive */ /&gt; (ReasonReact.string(item.title)) &lt;/div&gt; &#125;;&#125;;type state = &#123;items: list(item)&#125;;type action = | AddItem;let component = ReasonReact.reducerComponent(&quot;TodoApp&quot;);let newItem = () =&gt; &#123;title: &quot;Click a button&quot;, completed: true&#125;;let make = (_children) =&gt; &#123; ...component, initialState: () =&gt; &#123; items: [ &#123;title: &quot;Write some things to do&quot;, completed: false&#125; ] &#125;, reducer: (action, &#123;items&#125;) =&gt; switch action &#123; | AddItem =&gt; ReasonReact.Update(&#123;items: [newItem(), ...items]&#125;) &#125;, render: (self) =&gt; &#123; let numItems = List.length(self.state.items); &lt;div className=&quot;app&quot;&gt; &lt;div className=&quot;title&quot;&gt; (ReasonReact.string(&quot;What to do&quot;)) &lt;button onClick=(_event =&gt; self.send(AddItem))&gt; (ReasonReact.string(&quot;Add something&quot;)) &lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; ( self.state.items |&gt; List.map((item) =&gt; &lt;TodoItem item /&gt;) |&gt; Array.of_list |&gt; ReasonReact.array ) &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; (ReasonReact.string(&quot;Nothing&quot;)) &lt;/div&gt; &lt;div className=&quot;footer&quot;&gt; (ReasonReact.string(string_of_int(numItems) ++ &quot; items&quot;)) &lt;/div&gt; &lt;/div&gt; &#125;&#125;; ReactJS 的 componentWillUpdate 中的參數 nextProps 是 make 的參數 而現在的 props (this.props) 是上面的 retainedProps，可以透過 &#123;oldSelf&#125; 得到 didUpdateReactJS 的 prevProps 可以透過 retainedProps 拿到，需要使用 oldSelf shouldUpdate和 ReactJS 的 shouldComponentUpdate 對應","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"ReasonReact-auto-deploy","path":"/2018/11/12/ReasonReact-auto-deploy/","content":"Work With Dronedrone.yml 1234567891011121314151617181920212223242526272829303132333435pipeline: scp: image: appleboy/drone-scp pull: true host: - your server ip port: 22 username: root user: root secrets: [ ssh_password ] target: /root source: - $DRONE_DIR when: branch: master ssh: image: appleboy/drone-ssh host: - your server ip username: root user: root secrets: [ ssh_password ] command_timeout: 600 script: - . /root/.nvm/nvm.sh &amp;&amp; nvm use 10.9.0 - mkdir -p Your target path - cd /root/$DRONE_DIR - yarn install - npm run webpack:production - cp -a build/* Your target path - cd /root - rm -rf /root/drone when: branch: master 這個範例代表當你的 master 有被push 的時候觸發 pipe 流程 會依序執行 問題我在 linode 的 ubuntu 16 的 server 安裝 bs-platform 的時候遇到 node: permission denied 的問題 解法 codegithub Nginx12345678910server &#123; server_name YourDomain; root /var/www/html/YourDomain; index index.html index.htm index.php; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 然後要註冊一個 domain 指向你的 IP Demodemo 這樣只要有 push 就可以自動更新上去囉","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"ReasonReact-publish-package","path":"/2018/11/11/ReasonReact-publish-package/","content":"Initial Project1$ bsb -init helloworld -theme basic-reason 移除 src/Demo.re 新增一個 src/index.re src&#x2F;index.re 1let add = (a: int, b: int): int =&gt; a + b; package.json 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;tomas-math&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;bsb -make-world&quot;, &quot;start&quot;: &quot;bsb -make-world -w&quot;, &quot;clean&quot;: &quot;bsb -clean-world&quot; &#125;, &quot;keywords&quot;: [ &quot;BuckleScript&quot; ], &quot;files&quot;: [ &quot;src/index.bs.js&quot; ], &quot;main&quot;: &quot;src/index.bs.js&quot;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: &#123; &quot;bs-platform&quot;: &quot;^4.0.7&quot; &#125;&#125; 12$ npm login$ npm publish Install yourname-math建立一個新的 project 12$ npm init$ npm install yourname-math 會看到 node_modules 123456789├── index.js├── node_modules│ └── tomas-math│ ├── README.md│ ├── package.json│ └── src│ └── index.bs.js├── package-lock.json└── package.json 因為我們指定了 公開 index.bs.js 也是我們主要引入的檔案 index.js 12const &#123;add&#125; = require(&#x27;tomas-math&#x27;);console.log(add(1, 2)); //3 很簡單吧 其實跟原本的 Nodejs 的 publish 大同小異 卻可以使用到 Reason 的形態檢查 明天再來討論如果有第三方套件該如何使用 以 lodash 為範例","tags":["Javascript","IThome2018","Reason","React"],"categories":["Reason"]},{"title":"ReasonReact-Todo-Tutorial-PartII","path":"/2018/11/10/ReasonReact-Todo-Tutorial-PartII-1/","content":"Action昨天進度到了完成了一個 Reducer 但是我們知道要修改 Reducer 只能夠透過 Action 而在 ReasonReact 如何描述一個 Action？ 12345678910111213141516171819202122232425262728293031323334353637type action = | AddItem;type item = &#123; title: string, completed: bool&#125;;type state = &#123; items: list(item)&#125;let newItem = () =&gt; &#123;title: &quot;Click a button&quot;, completed: true&#125;;let component = ReasonReact.reducerComponent(&quot;TodoApp&quot;);let make = (_children) =&gt; &#123; ...component, reducer: ((), _) =&gt; ReasonReact.NoUpdate, render: (&#123;state: &#123;items&#125;&#125;) =&gt; &#123; let numItems = List.length(items); &lt;div className=&quot;app&quot;&gt; &lt;div className=&quot;title&quot;&gt; (str(&quot;What to do&quot;)) &lt;button onClick=((evt) =&gt; AddItem) &gt; (ReasonReact.string(&quot;Add something&quot;)) &lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; (ReasonReact.string(&quot;Nothing&quot;)) &lt;/div&gt; &lt;div className=&quot;footer&quot;&gt; (ReasonReact.string(string_of_int(numItems) ++ &quot; items&quot;)) &lt;/div&gt; &lt;/div&gt; &#125;&#125; 先幫昨天的範例加上一個 button 有一個 Event onClick 點擊後會 Js.log(“didn’t add something”) 如果在 React 中這邊應該是要呼叫 this.setState 但是在 ReasonReact 中這需要兩個步驟 建立一個 Action Type 然後建立一個 Reducer 並且和 Action Type mapping Reducer And ActionDemo 1234567891011121314151617181920212223242526272829303132333435363738394041type item = &#123; title: string, completed: bool&#125;;type state = &#123;items: list(item)&#125;;type action = | AddItem;let component = ReasonReact.reducerComponent(&quot;TodoApp&quot;);let newItem = () =&gt; &#123;title: &quot;Click a button&quot;, completed: true&#125;;let make = (_children) =&gt; &#123; ...component, initialState: () =&gt; &#123; items: [ &#123;title: &quot;Write some things to do&quot;, completed: false&#125; ] &#125;, reducer: (action, &#123;items&#125;) =&gt; switch action &#123; | AddItem =&gt; ReasonReact.Update(&#123;items: [newItem(), ...items]&#125;) &#125;, render: (self) =&gt; &#123; let numItems = List.length(self.state.items); &lt;div className=&quot;app&quot;&gt; &lt;div className=&quot;title&quot;&gt; (ReasonReact.string(&quot;What to do&quot;)) &lt;button onClick=(_event =&gt; self.send(AddItem))&gt; (ReasonReact.string(&quot;Add something&quot;)) &lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; (ReasonReact.string(&quot;Nothing&quot;)) &lt;/div&gt; &lt;div className=&quot;footer&quot;&gt; (ReasonReact.string(string_of_int(numItems) ++ &quot; items&quot;)) &lt;/div&gt; &lt;/div&gt; &#125;&#125;; initialStateReact 稱為 getInitialState 在 Reason 中稱為 initialState 不需傳入參數，會回傳一個 state 類型 state 可以是任何類型 string, int, record …etc Actions and Reducer在 React 中你會透過 callback handler 來修改 state 12345678910111213141516&#123; /* ... other fields */ handleClick: function() &#123; this.setState(&#123;count: this.state.count + 1&#125;); &#125;, handleSubmit: function() &#123; this.setState(...); &#125;, render: function() &#123; return ( &lt;MyForm onClick=&#123;this.handleClick&#125; onSubmit=&#123;this.handleSubmit&#125; /&gt; ); &#125;&#125; 在 ReasonReact 你會將所有的 Function 整理在同一個地方 如果你看到 self.reduce 這是舊的 API 新的 API 是 self.send action 是使用者定義的類型，他是一個 variant 類型，描述了所有可能的 state 類型 Component 的 state 可以透過 self.state 拿到 只有一個 reducer 是 pattern-matches 會針對有可能的 action 去修改 reducer 得值 在 reducer 中 self.handler 不允許狀態的改變，你必須使用 self.send 發送一個 action 例如我們點擊了一個按鈕 會發送一個 Click 的 action 他會依據 Click 的這事件回傳一個新的 state 用 Reducer 更新狀態ReasonReact.Update 回傳一個新的 state 另外也有一些其他選擇 ReasonReact.NoUpdate - 不要更新 state ReasonReact.Update - 更新 state ReasonREact.SideEffects(self &#x3D;&gt; unit) 不需要更新 state 但是需要但是需要觸發行為 e.g.ReasonReact.SideEffects(_self =&gt; Js.log(&quot;hello!&quot;)) ReasonReact.UpdateWithSideEffects(state, self &#x3D;&gt; unit): 更新狀態並且觸發行為 重要提示 action 可以帶入參數 payload: onClick=(data =&gt; self.send(Click(data.foo))) 不要把事件本身傳遞給 action reducer 必須是 pure function, 用 SideEffects 或者 UpdateWithSideEffects 增加一個 side-effect, 這個 side-effect 會在 state 處理完之後, 下一次 render 前進行 ReactEvent.BlablaEvent.preventDefault(event) 請在 self.send 中處理它 可以自由的觸發另一個 action 在 sideeffect, e.g UpdateWithSideEffects(newState, self =&gt; self.send(Click)) 如果你僅僅只有 state, 你的 Component 僅有 self.handler而沒有用到 self.send 但是依舊要指定 reducer reducer: ((), _state) =&gt; ReasonReact.NoUpdate Tip盡量縮小你的 reducer 你可以更容易使用 ReasonReact.SideEffects 和 ReasonReact.UpdateWithSideEffects 來更新 reducer Async State updated在 ReactJs 中你可能會這樣使用 setState 1setInterval(() =&gt; this.setState(...), 1000); 但是在 ReasonReact 中會是 1Js.Global.setInterval(() =&gt; self.send(Tick), 1000)","tags":["Javascript","IThome2018","Reason","React"],"categories":["Reason"]},{"title":"ReasonReact-Todo-Tutorial-PartIII","path":"/2018/11/10/ReasonReact-Todo-Tutorial-PartII/","content":"Rendering items希望有一個區塊 Component 來顯示輸入的 items 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type item = &#123; title: string, completed: bool&#125;;module TodoItem = &#123; let component = ReasonReact.statelessComponent(&quot;TodoItem&quot;); let make = (~item, _children) =&gt; &#123; ...component, render: (_self) =&gt; &lt;div className=&quot;item&quot;&gt; &lt;input _type=&quot;checkbox&quot; checked=(item.completed) /* TODO make interactive */ /&gt; (ReasonReact.string(item.title)) &lt;/div&gt; &#125;;&#125;;type state = &#123;items: list(item)&#125;;type action = | AddItem;let component = ReasonReact.reducerComponent(&quot;TodoApp&quot;);let newItem = () =&gt; &#123;title: &quot;Click a button&quot;, completed: true&#125;;let make = (_children) =&gt; &#123; ...component, initialState: () =&gt; &#123; items: [ &#123;title: &quot;Write some things to do&quot;, completed: false&#125; ] &#125;, reducer: (action, &#123;items&#125;) =&gt; switch action &#123; | AddItem =&gt; ReasonReact.Update(&#123;items: [newItem(), ...items]&#125;) &#125;, render: (self) =&gt; &#123; let numItems = List.length(self.state.items); &lt;div className=&quot;app&quot;&gt; &lt;div className=&quot;title&quot;&gt; (ReasonReact.string(&quot;What to do&quot;)) &lt;button onClick=(_event =&gt; self.send(AddItem))&gt; (ReasonReact.string(&quot;Add something&quot;)) &lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; ( ReasonReact.array(Array.of_list( List.map((item) =&gt; &lt;TodoItem item /&gt;, self.state.items) )) ) &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; (ReasonReact.string(&quot;Nothing&quot;)) &lt;/div&gt; &lt;div className=&quot;footer&quot;&gt; (ReasonReact.string(string_of_int(numItems) ++ &quot; items&quot;)) &lt;/div&gt; &lt;/div&gt; &#125;&#125;; 我們又增加了一些東西 和一般的 JSX 有一點不一樣 &lt;TodoItem item /&gt; 他原本也是 &lt;TodoItem item=item /&gt; 的簡寫 JSX 中則會被解釋為 &lt;TodoItem item=&#123;true&#125; /&gt; 123ReasonReact.array(Array.of_list( List.map((item) =&gt; &lt;TodoItem item /&gt;, self.state.items))) 可以看到這個寫法 但是其實也可以改成 1self.state.items |&gt; List.map((item) =&gt; &lt;TodoItem item /&gt;) |&gt; Array.of_list |&gt; ReasonReact.array","tags":["Javascript","IThome2018","Reason","React"],"categories":["Reason"]},{"title":"ReasonReact-Todo-Tutorial-PartI","path":"/2018/11/10/ReasonReact-Todo-Tutorial-PartI/","content":"調整 initial 的 project之前我們有用 bsb initial 了一個 project 但是要做一些小小的調整 先新增一個 .re TodoApp.re 1234567891011121314let component = ReasonReact.statelessComponent(&quot;TodoApp&quot;);let make = (children) =&gt; &#123; ...component, render: (self) =&gt; &lt;div className=&quot;app&quot;&gt; &lt;div className=&quot;title&quot;&gt; (ReasonReact.string(&quot;What to do&quot;)) &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; (ReasonReact.string(&quot;Nothing&quot;)) &lt;/div&gt; &lt;/div&gt;&#125; index.re 1ReactDOMRe.renderToElementWithId(&lt;TodoApp /&gt;, &quot;root&quot;); index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ReasonReact Examples&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;Index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到基本的顯示 STEP1 增加一些 State宣告一些類型1234567891011121314151617181920212223type item = &#123; title: string, completed: bool&#125;;type state = &#123; items: array(item)&#125;;let component = ReasonReact.statelessComponent(&quot;TodoApp&quot;);let make = (children) =&gt; &#123; ...component, render: (_self) =&gt; &lt;div className=&quot;app&quot;&gt; &lt;div className=&quot;title&quot;&gt; (ReasonReact.string(&quot;What to do&quot;)) &lt;/div&gt; &lt;div className=&quot;items&quot;&gt; (ReasonReact.string(&quot;Nothing&quot;)) &lt;/div&gt; &lt;/div&gt;&#125; StateReaconReact 的有狀態 Component 和 React 的有狀態 Component 是類似的 只是多了 reducer 的概念 (類似 Redux) 只要把它當成狀態管理系統就好 將宣告 statefulComponent 取代 statelessComponent 使用 ReasonReact.reducerComponent(&quot;MyComponentName&quot;) 這個 API Stateful 範例index.re 1ReactDOMRe.renderToElementWithId(&lt;StatefulComponent greeting=&quot;greeting&quot; /&gt;, &quot;root&quot;); StatefulComponent.re 123456789101112131415161718192021222324252627282930313233343536type state = &#123; count: int, show: bool&#125;;type action = | Click | Toggle;let component = ReasonReact.reducerComponent(&quot;Example&quot;);let make = (~greeting, _children) =&gt; &#123; ...component, initialState: () =&gt; &#123;count: 0, show: true&#125;, reducer: (action, state) =&gt; switch (action) &#123; | Click =&gt; ReasonReact.Update(&#123;...state, count: state.count + 1&#125;) | Toggle =&gt; ReasonReact.Update(&#123;...state, show: !state.show&#125;) &#125;, render: (self) =&gt; &#123; let message = &quot;You&#x27;ve clicked this &quot; ++ string_of_int(self.state.count) ++ &quot; times(s)&quot;; &lt;div&gt; &lt;button onClick=(_event =&gt; self.send(Click))&gt; (ReasonReact.string(message)) &lt;/button&gt; &lt;button onClick=(_event =&gt; self.send(Toggle))&gt; (ReasonReact.string(&quot;Toggle greeting&quot;)) &lt;/button&gt; ( self.state.show ? ReasonReact.string(greeting) : ReasonReact.null ) &lt;/div&gt;; &#125;&#125;;","tags":["Javascript","IThome2018","Reason","React"],"categories":["Reason"]},{"title":"Reason-ExternalPromiseAPI","path":"/2018/11/04/Reason-ExternalPromiseAPI/","content":"External Mongo client12345let url = &quot;mongodb://localhost:27017&quot;;let dbName = &quot;myproject&quot;;[@bs.module &quot;mongodb&quot;] external connect: (string) =&gt; Js.Promise.t(&#x27;a) = &quot;&quot;;let connection = (url) =&gt; connect(url); connection會取得一個 Promise 的回傳值 之後只要利用它就可以用 Promise 的模式來對 MongoDB 進行控制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[@bs.module &quot;mongodb&quot;] external connect: (string) =&gt; Js.Promise.t(&#x27;a) = &quot;&quot;;let connect = (url) =&gt; connect(url);module ObjectID = &#123; type t; [@bs.send.pipe : t] external toHexString : string = &quot;&quot;; [@bs.new] [@bs.module &quot;mongodb&quot;] external from_string : string =&gt; t = &quot;ObjectID&quot;; [@bs.new] [@bs.module &quot;mongodb&quot;] external make : t = &quot;ObjectID&quot;;&#125;;module type TConfig = &#123; let url: string; let dbName: string;&#125;;module CreateConnection = (Config: TConfig) =&gt; &#123; let url = Config.url; let dbName = Config.dbName; module Db = &#123; type t; &#125;; module Client = &#123; type t; [@bs.send] external db : (t, string) =&gt; Db.t = &quot;&quot;; let db = (client, name) =&gt; db(client, name); &#125;; module Collection = &#123; type t; &#125;; let clientPromise: Js.Promise.t(Client.t) = connect(url); let createDB: string =&gt; Js.Promise.t(Db.t) = (name) =&gt; clientPromise |&gt; Js.Promise.then_((client) =&gt; &#123; Js.Promise.resolve(Client.db(client, name)); &#125;);&#125;module Config = &#123; let url = &quot;mongodb://localhost:27017&quot;; let dbName = &quot;myproject&quot;;&#125;;module Connection = CreateConnection(Config); 幾本的程式碼 其中也有一部分利用 functor 建立一個 module 但是總覺得這樣並不好 詳細要怎樣時做可能還需要一點時間處理 要準備開始 ReasonReact 了 先繼續往下走吧","tags":["Javascript","IThome2018","Reason"],"categories":["Reason"]},{"title":"ReasonReact-Component","path":"/2018/11/04/ReasonReact-Component/","content":"ComponentCreationReasonReact 不需要　class 來建立 Component 提供一個建立的 API 會回傳一個 record 他的欄位是可以覆寫的(就像 render, initialState, didMount… 之類的) ReasonReact.statelessComponent(&quot;TheComponentName&quot;) 字串是為了提供 Debuging 他就像是 React 中的 displayName 例如要建立一個新的 Greeting 的 Component 123456let component = ReasonReact.statelessComponent(&quot;Greeting&quot;);let make = (~name, _children) =&gt; &#123; ...component, render: _self =&gt; &lt;div&gt;&#123;ReasonReact.string(name)&#125;&lt;/div&gt;&#125;; make 會回傳一個 Component record Note: 不要直接使用 ReasonReact.statelessComponent直接在 make 中解構，範例如下 1234let make = _children =&gt; &#123; ...(ReasonReact.statelessComponent(&quot;Greeting&quot;)), render: self =&gt; blabla&#125; 上述範例為錯誤示範，請勿使用 PropsProps 其實就是 make function 中的 labeld arguments 也可以是有選擇性(optional)或有預設值(default value) 例如 12let make = (~name, ~age=?, ~className=&quot;box&quot;, _children) =&gt; &lt;div&gt;(ReasonReact.string(name))&lt;/div&gt; 最後的一個參數必須是 children 但是如果沒有使用到的話 可以用 _ 或是 _children 來做命名 compiler 會自動規避 props 的名字不能是 ref 或是 key 這部分和 ReactJs 一樣 上面的範例如果只傳入 name classname 會是預設的 box age 預設會是 None 有時候在 ReactJs 中會以傳入的值決定回傳的 Component 1&lt;Foo name=&quot;Reason&quot; age=&#123;this.props.age&#125; /&gt; 如果這樣傳值的話有可能會有 bug 因為 age 有可能是 Null 的 所以可以透過 varian 1234switch (myAge) &#123;| None =&gt; &lt;Foo name=&quot;Reason&quot; /&gt;| Some(nonOptionalAge) =&gt; &lt;Foo name=&quot;Reason&quot; age=nonOptionalAge /&gt;&#125; 這樣看起來有點繁雜 也可以這樣處理 1&lt;Foo name=&quot;Reason&quot; age=?myAge /&gt; 這並不是特殊的手法 詳情可以參照 Reason doc self你會在 make 中看到 self 他的角色就像是 Javascript 中的 this 它是一個 record 包含了 state, handler, send 也可以傳遞生命週期 API JSXReason 也可以接受 JSX 但是在 bsconfig.json 要給予設定資訊 &#123;&quot;reason&quot;: &#123;&quot;react-jsx&quot;: 2&#125; 更詳細的 schema Uncapitalized1&lt;div foo=&#123;bar&#125;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/div&gt; 會編譯為 1ReactDOMRe.createElement(&quot;div&quot;, ~props=ReactDOMRe.props(~foo=bar, ()), [|child1, child2|]); Javascript 會編譯為 1React.createElement(&#x27;div&#x27;, &#123;foo: bar&#125;, child1, child2) prop-less 範例 1&lt;div /&gt; 則會轉譯成 1ReactDOMRe.createElement(&quot;div&quot;, [||]); 實際的 Javascript 1React.createElement(&#x27;div&#x27;, undefined); Note: ReactDOMRe.createElement 是內部轉譯 JSX 專用，也有提供逃生出口 ReasonReact.createDomElement 詳情閱讀 children section Capitalized1&lt;MyReasonComponent key=&#123;a&#125; ref=&#123;b&#125; foo=&#123;bar&#125; baz=&#123;qux&#125;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/MyReasonComponent&gt; 會轉譯為 12345ReasonReact.element( ~key=a, ~ref=b, MyReasonComponent.make(~foo=bar, ~baz=qux, [|child1, child2|])); prop-less &lt;MyReasonComponent /&gt; 則會轉譯成 1ReasonReact.element(MyReasonComponent.make([||])); MyReasonComponent.make 中的 make 跟上一個部分講的 make 是一樣的 也要注意不要將 ref key 這類的保留自使用在 props Fragment在 ReasonReact 中也允許使用 Fragment 他可以簡化 DOM 結構 1&lt;&gt; child1 child2 &lt;/&gt;; 將會轉意成為 1ReactDOMRe.createElement(ReasonReact.fragment, [|child1, child2|]); Javascript 則會 1React.createElement(React.Fragment, undefined, null); ChildrenReasonReact 中的 children 是有完整的類型 你可以傳遞任何型態的值給它 1234&lt;MyReasonComponent&gt; &lt;div /&gt; &lt;div /&gt; &lt;/MyReasonComponent&gt;let let theChildren = [| &lt;div /&gt;, &lt;div /&gt; |];&lt;MyReasonComponent&gt; theChildren &lt;/MyReasonComponent&gt; 上面兩個範例都會轉譯為 1234let theChildren = [| &lt;div /&gt;, &lt;div /&gt; |];ReasonReact.element( MyReasonComponent.make([|theChildren|])); Reason 中的 children 也可以使用 spread 12let theChildren = [| &lt;div /&gt;, &lt;div /&gt; |];&lt;MyReasonComponent&gt; ...theChildren &lt;/MyReasonComponent&gt; 詳情可以參閱 children spread syntax 更詳細的 Children 後續會再做了解","tags":["Javascript","IThome2018","Reason","React"],"categories":["Reason"]},{"title":"ReasonReact-Helloworld","path":"/2018/11/04/ReasonReact-Helloworld/","content":"Install這部分和 Reason 一樣 只是提供了一個 react theme 123$ npm install -g bs-platform$ bsb -init reason-react-demo -theme react$ cd reason-react-demo &amp;&amp; npm install &amp;&amp; npm start npm start 僅僅是將 .re 編譯為 .js 我們還需要使用 npm run webpack 作打包的動作 另外要再開一個 web-develop-server 所以另外也還要再開一個 npm run server 這些指令在初始化的時候就會產生 工程師都是懶惰的 所以現在要利用 concurrently 來幫我們簡化一下 concurrently這個套件可以一行指令一次執行多個 process 使用上也很方便 1$ npm install -g concurrently command 1$ concurrently -n reason,webpack,server &quot;yarn start&quot; &quot;yarn webpack&quot; &quot;yarn server&quot; package.json需要使用 \\ 跳脫字元 123...,&quot;dev&quot;: &quot;concurrently -n reason,webpack,server \\&quot;yarn start\\&quot; \\&quot;yarn webpack\\&quot; \\&quot;yarn server\\&quot;&quot;,... 1$ npm run dev 檔案結構1234567891011121314151617181920212223242526272829303132333435363738.├── README.md├── bsconfig.json├── lib│ └── bs│ ├── ReactTemplate.cmi│ ├── ReactTemplate.cmj│ ├── ReactTemplate.cmt│ ├── ReactTemplate.js│ ├── ReactTemplate.mlmap│ ├── build.ninja│ └── src│ ├── Component1-ReactTemplate.cmi│ ├── Component1-ReactTemplate.cmj│ ├── Component1-ReactTemplate.cmt│ ├── Component1.mlast│ ├── Component1.mlast.d│ ├── Component2-ReactTemplate.cmi│ ├── Component2-ReactTemplate.cmj│ ├── Component2-ReactTemplate.cmt│ ├── Component2.mlast│ ├── Component2.mlast.d│ ├── Index-ReactTemplate.cmi│ ├── Index-ReactTemplate.cmj│ ├── Index-ReactTemplate.cmt│ ├── Index.mlast│ └── Index.mlast.d├── package-lock.json├── package.json├── src│ ├── Component1.bs.js│ ├── Component1.re│ ├── Component2.bs.js│ ├── Component2.re│ ├── Index.bs.js│ ├── Index.re│ └── index.html└── webpack.config.js lib 裡面放的是 BuckleScript 的檔案 這部分之後再做研究 src 中放的是 .re 檔案 以及編譯過後的 .js 檔案 webpackconfig.js 就是 webpack 的設定檔案 他會以 index.bs.js 為進入點 所以第一次要先編譯之後產生這個檔案再跑 webpack 才不會出錯 src 中主要有四個檔案 index.html Index.re Component1.re Component2.re 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ReasonReact Examples&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Component 1: &lt;div id=&quot;index1&quot;&gt;&lt;/div&gt; Component 2: &lt;div id=&quot;index2&quot;&gt;&lt;/div&gt; &lt;script src=&quot;Index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 這邊有一個比較特別的地方 以前使用 create-react-app 建立出來的都只會有一個 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 會以這個為最外層的 div 其他的 Component 都在這個 div 之下做 render 這個範例一開始建立了兩個 div 各自 render Component1 和 Component2 或許這之後會解釋這樣的實作有和優劣？ 還是只是範例而已 Component1.re 1234567891011121314151617181920212223/* This is the basic component. */let component = ReasonReact.statelessComponent(&quot;Page&quot;);/* Your familiar handleClick from ReactJS. This mandatorily takes the payload, then the `self` record, which contains state (none here), `handle`, `reduce` and other utilities */let handleClick = (_event, _self) =&gt; Js.log(&quot;clicked!&quot;);/* `make` is the function that mandatorily takes `children` (if you want to use `JSX). `message` is a named argument, which simulates ReactJS props. Usage: `&lt;Page message=&quot;hello&quot; /&gt;` Which desugars to `ReasonReact.element(Page.make(~message=&quot;hello&quot;, [||]))` */let make = (~message, _children) =&gt; &#123; ...component, render: self =&gt; &lt;div onClick=(self.handle(handleClick))&gt; (ReasonReact.string(message)) &lt;/div&gt;,&#125;; Component1.re 很簡單 先將原始的 Compoennt assign 之後做解構 但是在綁定 Event 就比較特別的是 先寫了一個 function handleClick 在 div 的 onClick 去 trigger 使用的方式是 onClick=(self.handle(handleClick)) 變數部分也改用 () 而不是以前 React 使用的 &#123;&#125; 看到這邊其實跟之前的 React 會有一些不同 先做一些調整 src&#x2F;index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ReasonReact Examples&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;Index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; App.re 123456789101112let component = ReasonReact.statelessComponent(&quot;App&quot;);let make = (_children) =&gt; &#123; ...component, render: (_) =&gt; &lt;&gt; (ReasonReact.string(&quot;Component1:&quot;)) &lt;Component1 message=&quot;Hello!&quot; /&gt; (ReasonReact.string(&quot;Component2:&quot;)) &lt;Component2 greeting=&quot;Hello!&quot; /&gt; &lt;/&gt;&#125;; Hot Reload這時候會發現當我們更新了程式碼之後還是不會自動 Reload 還是有點麻煩 其實只要稍微調整一下 webpack.config.js 1234567891011121314151617181920212223242526const path = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const outputDir = path.join(__dirname, &#x27;build/&#x27;);const isProd = process.env.NODE_ENV === &#x27;production&#x27;;module.exports = &#123; entry: &#x27;./src/Index.bs.js&#x27;, mode: isProd ? &#x27;production&#x27; : &#x27;development&#x27;, output: &#123; path: outputDir, publicPath: outputDir, filename: &#x27;Index.js&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;src/index.html&#x27;, &#125;) ], devServer: &#123; compress: true, contentBase: outputDir, port: process.env.PORT || 8000, historyApiFallback: true &#125;&#125;; 這樣就完成囉! Have fun!","tags":["Javascript","IThome2018","Reason","React"],"categories":["Reason"]},{"title":"Reason-Create-NPM-Package-PartII","path":"/2018/11/02/Reason-Create-NPM-Package-PartII/","content":"建立 Semver 的類別semver 在 Javascript 可以使用 new 關鍵字來產生物件 12const s = new semver(&quot;1.5.0&quot;);s.minor(); // 5 在 Reason 中可以使用 class type 來綁定 1234567891011121314class type semverInstance =[@bs]&#123; pub version: string; pub major: int; pub minor: int; pub patch: int; pub raw: string; pub build: array(string); pub prerelease: array(string)&#125;;type tSemver = Js.t(semverInstance); 完成了這一步先回想一下如何發布 NPM 的套件 發布 NPM 套件document 將寫完的 Reason 檔案透過上面的步驟就可以推到 NPM 上面 使用 NPM 上的 bs-express 套件1$ npm install bs-express express bsconfig.json 123&quot;bs-dependencies&quot;: [ &quot;bs-express&quot;], Demo.re 123456789101112131415161718open Express;let app = express();let onListen = e =&gt; switch (e) &#123; | exception (Js.Exn.Error(e)) =&gt; Js.log(e); Node.Process.exit(1); | _ =&gt; Js.log @@ &quot;Listening at http://127.0.0.1:3000&quot; &#125;; App.get(app, ~path=&quot;/&quot;) @@Middleware.from((next, req,) =&gt; &#123; Response.sendString(&quot;Hello world&quot;)&#125;);let server = App.listen(app, ~port=3000, ~onListen, ()); 1$ node src/Demo.bs.js Demo Url 你就可以看到 Hello World! 終於串起 Reason 和 NPM 的部分 接下來是怎麼處理 使用 Reason 讓 Javascript 使用呢？","tags":["Javascript","IThome2018","Reason"],"categories":["Reason"]},{"title":"Reason Create NPM Package Part-I","path":"/2018/11/02/Reason-Create-NPM-Package-PartI/","content":"使用 semver和之前一樣先寫一個 javascript 的版本 123456789const semver = require(&#x27;semver&#x27;);semver.valid(&#x27;1.2.3&#x27;);semver.valid(&#x27;a.b.c&#x27;);semver.clean(&#x27; =v1.2.3 &#x27;);semver.satisfies(&#x27;1.2.3&#x27;, &#x27;1.x || &gt;=2.5.0 || 5.0.0 - 7.2.3&#x27;); 如果要在 Reason 中使用 semver 的話 如何寫一個 interface 1234[@bs.module &quot;semver&quot;] [@bs.val] external clean: string =&gt; Js.nullable(string) = &quot;clean&quot;;let clean = a =&gt; clean(a) |&gt; Js.Nullable.toOption; 之前其實就有聊過這部分 Js.nullable(string) 也一種寫法代表是 Javascript 帶過來的值 意思是 string 但是也有可能是 null 得值 Jext test寫完之後來驗證一下你的型態 所以需要安裝一下 bs-jest 1$ npm install --save-dev @glennsl/bs-jest 建立一個 __tests__/semver_spec.re bsconfig.json 也要做一些調整 1234567891011121314151617181920212223242526272829// This is the configuration file used by BuckleScript&#x27;s build system bsb. Its documentation lives here: http://bucklescript.github.io/bucklescript/docson/#build-schema.json// BuckleScript comes with its own parser for bsconfig.json, which is normal JSON, with the extra support of comments and trailing commas.&#123; &quot;name&quot;: &quot;package-name&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;sources&quot;: [ &#123; &quot;dir&quot; : &quot;src&quot;, &quot;subdirs&quot; : true &#125;, &#123; &quot;dir&quot;: &quot;__tests__&quot;, &quot;type&quot;: &quot;dev&quot; &#125; ], &quot;package-specs&quot;: &#123; &quot;module&quot;: &quot;commonjs&quot;, &quot;in-source&quot;: true &#125;, &quot;suffix&quot;: &quot;.bs.js&quot;, &quot;bs-dev-dependencies&quot;: [ &quot;@glennsl/bs-jest&quot; ], &quot;warnings&quot;: &#123; &quot;error&quot; : &quot;+101&quot; &#125;, &quot;namespace&quot;: true, &quot;refmt&quot;: 3&#125; 主要是要加上 sources 和 bs-dev-dependencies 先寫個簡單的測試 1234567891011121314open Jest;describe(&quot;Expect&quot;, () =&gt; &#123; open Expect; test(&quot;toBe&quot;, () =&gt; expect(1 + 2) |&gt; toBe(3) );&#125;);describe(&quot;Expect.Operators&quot;, () =&gt; &#123; open Expect; open! Expect.Operators; test(&quot;==&quot;, () =&gt; expect(1+2) === 3);&#125;); 可以看到上例 也可以測試從外部引入的套件 1234567891011121314151617open Jest;let () = describe(&quot;semver&quot;, ExpectJs.(() =&gt; &#123; test(&quot;#clean&quot;, () =&gt; expect(Semver.clean(&quot; =1.5.0 &quot;) |&gt; (result =&gt; switch (result) &#123; | Some(v) =&gt; v | None =&gt; raise(Not_found) &#125; ), ) |&gt; toBe(&quot;1.5.0&quot;) ); &#125; ),); 更多範例 在 package.json 中加入 files 1234&quot;files&quot;: [ &quot;src/semver.re&quot;, &quot;bsconfig.json&quot; ] 可以讓 NPM 知道需要哪些檔案 也必須讓 NPM 知道這個套件和 servem 有依賴關係 1&quot;peerDependencies&quot;: &#123;&quot;semver&quot;: &quot;^5.5.0&quot;&#125;, 開始寫綁定檔案src&#x2F;semver.re 123[@bs.module &quot;semver&quot;] [@bs.val]external clean: string =&gt; Js.nullable(string) = &quot;&quot;;let clean = a =&gt; clean(a) |&gt; Js.Nullable.toOption; 簡單吧！ 可以自己再補齊其他的 API Enums of Stringsemver.cmp 需要丟入三個參數 先寫一個簡單的版本 12[@bs.module &quot;semver&quot;] [@bs.val]external cmp: (string, string, string) =&gt; bool = &quot;&quot;; 但是第二個參數因為是 operations 所以只能允許 &gt;, &lt;, &gt;=, &lt;=, ==, !== 這類的字串 如果想要更精確的描述的話 我們需要對第二個參數做更完整的定義 在 Javascript 中會是 1Semver.cmp(&quot;1.5.0&quot;, &quot;&lt;&quot;, &quot;2.3.5&quot;); 所以需要針對這個變數宣告一個類型 123456789101112131415161718192021222324252627282930type comparator = | LooseEqual | LooseNotEqual | Equal | Empty | NotEqual | Gt | Gte | Lt | Lte;let comparatorToString = comparator: string =&gt; switch (comparator) &#123; | LooseEqual =&gt; &quot;==&quot; | LooseNotEqual =&gt; &quot;!==&quot; | Equal =&gt; &quot;===&quot; | Empty =&gt; &quot;&quot; | NotEqual =&gt; &quot;!==&quot; | Gt =&gt; &quot;&gt;&quot; | Gte =&gt; &quot;&gt;=&quot; | Lt =&gt; &quot;&lt;&quot; | Lte =&gt; &quot;&lt;=&quot; &#125;;[@bs.module &quot;semver&quot;] [@bs.val]external cmp: (string, string, string) =&gt; bool = &quot;&quot;;let cmp = (a: string, c: comparator, b: string) =&gt; cmp(a, c |&gt; comparatorToString, b); 可以看到我們宣告了一個類型給第二個參數 再藉由 Fast Pipe 輸入參數時做檢查 達到 Enums 的需求","tags":["Javascript","IThome2018","Reason"],"categories":["Reason"]},{"title":"BuckleScript-Function","path":"/2018/10/29/BuckleScript-Function/","content":"MongoDB 的 CRUD昨天我們引入了 mongoDB 今天來整理一下寫一個 module 按照慣例先來一個 Javascript 版本 src/mongoManager/index.js 123456789101112131415161718192021222324252627282930313233const MongoClient = require(&#x27;mongodb&#x27;).MongoClient;const url = &#x27;mongodb://localhost:27017&#x27;;const dbName = &#x27;myproject&#x27;;class mongoDBManagerClass &#123; initialDB(&#123;url, dbName&#125;)&#123; return new Promise((resolve) =&gt; &#123; MongoClient.connect(url, &#123; useNewUrlParser: true &#125;, (err, client) =&gt; &#123; this._client = client; this._db = client.db(dbName); this._document = this._db.collection(&#x27;documents&#x27;); resolve(); &#125;); &#125;); &#125; insertManyDocument(array) &#123; return new Promise((resolve, reject) =&gt; &#123; this._document.insertMany(array,(error, result) =&gt; &#123; if(error) reject(error); else resolve(result); &#125;); &#125;) &#125; closeClient() &#123; this._client.close(); &#125;&#125;const mongoDBManager = new mongoDBManagerClass(&#123;url, dbName&#125;);module.exports = mongoDBManager; src/app.js 12345678910111213141516171819const express = require(&#x27;express&#x27;);const userRouter = require(&#x27;./routes/usersRoutes&#x27;);const mongoDBManager = require(&#x27;./mongodbManager&#x27;);const url = &#x27;mongodb://localhost:27017&#x27;;const dbName = &#x27;myproject&#x27;;mongoDBManager .initialDB(&#123;url, dbName&#125;) .then(() =&gt; &#123; return mongoDBManager.insertManyDocument([&#123;a : 1&#125;]) &#125;) .then(() =&gt; mongoDBManager.closeClient());const app = express();const port = 5000;app.use(&#x27;/user&#x27;, userRouter);app.get(&#x27;/&#x27;, (req, res) =&gt; res.send(&#x27;Hello World!&#x27;));app.listen(port, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`));","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"Express-MongoDB-PartII","path":"/2018/10/28/Express-MongoDB-PartII/","content":"在準備 MongoDBManager 的時候遇到兩個蠻大的問題 今天先補上這兩個部分的筆記 Promise Pipe Promisecallback 在之前就有範例了 但是如何在 Reason 中實作 Promise 呢？ 我們知道 Promise 最常用的是 resolve then 和 catch 這部分 BuckleScript 已經有實作支援 Js.Promise.resolve: ‘a &#x3D;&gt; Js.Promise.t(‘a) Js.Promise.then_: (‘a &#x3D;&gt; Js.Promise.t(‘b), Js.Promise.t(‘a)) &#x3D;&gt; Js.Promise.t(‘b) Js.Promise.catch: (Js.Promise.error &#x3D;&gt; Js.Promise.t(‘a), Js.Promise.t(‘a)) &#x3D;&gt; Js.Promise.t(‘a) 但是這只是表示了 JS 中 Reason 的型態 在 Reason 中新增一個 Promise 其實 BuckleScript 也有提供建立的方法 Js.Promise.make: ( ( ~resolve: (. ‘a) &#x3D;&gt; unit, ~reject: (. exn) &#x3D;&gt; unit ) &#x3D;&gt; unit ) &#x3D;&gt; Js.Promise.t(‘a) 範例123456789101112131415161718let myPromise = Js.Promise.make((~resolve, ~reject) =&gt; resolve(. 2));myPromise|&gt; Js.Promise.then_(value =&gt; &#123; Js.log(value); Js.Promise.resolve(value + 2);&#125;)|&gt; Js.Promise.then_(value =&gt; &#123; Js.log(value); Js.Promise.resolve(value + 3);&#125;)|&gt; Js.Promise.catch(err =&gt; &#123; Js.log2(&quot;Failure!!&quot;, err); Js.Promise.resolve(-2);&#125;);/*24*/ 我們要如何寫一個 function 裡面包含 Promise 呢？ 1234567const sleep = (ms = 1000) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; console.log(&#x27;wake up&#x27;), ms); &#125;);&#125;sleep(2000); 12345[@bs.val] external setTimeout: (unit =&gt; unit, int) =&gt; unit = &quot;&quot;;let sleep = (ms: int) =&gt; Js.Promise.make((~resolve, ~reject) =&gt; setTimeout(() =&gt; resolve(. () =&gt; Js.log(&quot;wake up&quot;)), ms)); 那麼上方的範例也可以更改為 12345678910111213141516171819202122let addTwoPromise = (value: int) =&gt; Js.Promise.make((~resolve, ~reject) =&gt; &#123; Js.log(value); resolve(. value + 2); &#125;);let addThreePromise = (value: int) =&gt; Js.Promise.make((~resolve, ~reject) =&gt; &#123; Js.log(value); resolve(. value + 3); &#125;);let errorHandler = (error) =&gt; Js.Promise.make((~resolve, ~reject) =&gt; &#123; Js.log2(&quot;Failure!!&quot;, error); resolve(. -2); &#125;);myPromise|&gt; Js.Promise.then_(addTwoPromise)|&gt; Js.Promise.then_(addThreePromise)|&gt; Js.Promise.catch(errorHandler); 因為我們準備做一個 MongoDBModule 所以也要試試在 module 中實作 Promise method 12345678910111213141516171819202122232425262728module MyPromiseModule &#123; let value = 2; let myPromise = Js.Promise.make((~resolve, ~reject) =&gt; resolve(. value)); let addTwoPromise = (value) =&gt; Js.Promise.make((~resolve, ~reject) =&gt; &#123; Js.log(value); resolve(. value + 2); &#125;); let addThreePromise = (value) =&gt; Js.Promise.make((~resolve, ~reject) =&gt; &#123; Js.log(value); resolve(. value + 3); &#125;); let errorHandler = (error) =&gt; Js.Promise.make((~resolve, ~reject) =&gt; &#123; Js.log2(&quot;Failure!!&quot;, error); resolve(. -2); &#125;);&#125;;MyPromiseModule.myPromise|&gt; Js.Promise.then_(MyPromiseModule.addTwoPromise)|&gt; Js.Promise.then_(MyPromiseModule.addThreePromise)|&gt; Js.Promise.catch(MyPromiseModule.errorHandler); Pipe其實上面已經有使用 Pipe 在這裡補充一下 -&gt; 是 Reason 提供的運算子 可以幫助將 b(a) 轉換為 b-&gt;a validateAge(getAge(parseData(person))) 這個 function 其實有點難以閱讀 但是經過 -&gt; 運算子之後 1234person -&gt;parseData -&gt;getAge -&gt;validateAge 可以很清楚地瞭解他的脈絡順序 a(one, two, three) 也可以寫為 one-&gt;a(two, three) 還有一些 function chain 的延伸","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"Express-MongoDB","path":"/2018/10/27/Express-MongoDB/","content":"MongoDB之前有提過如何使用 NPM 上的 package 今天來試試看串接一下 MongoDB 做最簡單的 CRUD Install1$ npm install mongodb Nodejs version12345678910111213141516171819202122232425262728const express = require(&#x27;express&#x27;);const userRouter = require(&#x27;./routes/usersRoutes&#x27;);const MongoClient = require(&#x27;mongodb&#x27;).MongoClient;const url = &#x27;mongodb://localhost:27017&#x27;;const dbName = &#x27;myproject&#x27;;MongoClient.connect(url, function(err, client) &#123; const db = client.db(dbName); const collection = db.collection(&#x27;documents&#x27;); collection.insertMany([ &#123;a : 1&#125;, &#123;a : 2&#125;, &#123;a : 3&#125; ], function(err, result) &#123; console.log(&quot;Inserted 3 documents into the collection&quot;); console.log(result); &#125;); client.close();&#125;);const app = express();const port = 5000;app.use(&#x27;/user&#x27;, userRouter);app.get(&#x27;/&#x27;, (req, res) =&gt; res.send(&#x27;Hello World!&#x27;));app.listen(port, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`)); 可以看到在 mongodb 中有一個 MongoClient 他還有一個 connect 的 function connect 有兩個參數 (string, (err, client) =&gt; unit) 以此類推 轉譯成 Reason 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* 在上面的範例中 `require` 了一個 `express` 他是一個函式 它會回傳一個 `app` 的物件然和對 `app` 的這個物件 有使用到兩個函式`listen` 和 `get`listen 會丟入一個參數(int)get 會丟入兩個參數(string, function)而在 get 中丟入的 function 會有兩個物件 `req`, `res`因為只有使用到 `res.send`大致上我們可以先宣告剛剛有提到函式 和參數的類型 */type res = &#123;. [@bs.meth] &quot;send&quot;: string =&gt; string &#125;;type nextFun = unit =&gt; string;type handler = (string, res, nextFun) =&gt; string;type expressApp = &#123;. [@bs.meth] &quot;use&quot;: handler =&gt; unit, [@bs.meth] &quot;listen&quot;: (int) =&gt; unit, [@bs.meth] &quot;get&quot;: (string, handler, handler) =&gt; string&#125;;type router = &#123;. [@bs.meth] &quot;get&quot;: (string, handler) =&gt; string, [@bs.meth] &quot;use&quot;: handler =&gt; unit&#125;;type dbErrorType = Js.t(&#123;. message: string &#125;);type jsObjectType = &#123;. &#125;;type insertManyResultType = &#123;. &#125;;type insertRespType = (dbErrorType, insertManyResultType) =&gt; unit;type collectionType = &#123;. [@bs.meth] &quot;insertMany&quot;: (array(&#123;. &quot;a&quot;: int&#125;), insertRespType) =&gt; unit&#125;;type dbType = &#123;. [@bs.meth] &quot;collection&quot;: (string) =&gt; collectionType&#125;;type clientType = Js.t(&#123;. [@bs.meth] db: string =&gt; dbType, [@bs.meth] close: unit =&gt; unit&#125;);type mongoClientType = &#123;. [@bs.meth] &quot;connect&quot;: (string, (dbErrorType, clientType) =&gt; unit) =&gt; unit&#125;;[@bs.module] external express: unit =&gt; expressApp = &quot;express&quot;;[@bs.module &quot;mongodb&quot;] external mongoClient: mongoClientType = &quot;MongoClient&quot;;[@bs.module &quot;./routes/UserRoutes.bs&quot;] external userRoutes: router = &quot;routes&quot;;let url = &quot;mongodb://localhost:27017&quot;;let dbName = &quot;myproject&quot;;mongoClient##connect(url, (error, client) =&gt; &#123; let db = client##db(dbName); let collection = db##collection(&quot;documents&quot;); let inputData = [|&#123;&quot;a&quot;: 1&#125;|]; collection##insertMany(inputData, (_, result) =&gt; &#123; Js.log(&quot;Inserted 3 documents into the collection&quot;); Js.log(result); &#125;); client##close();&#125;);let app = express();[@bs.val] external use: handler =&gt; unit = &quot;app.use&quot;;[@bs.val] external useWithString: (string, router) =&gt; unit = &quot;app.use&quot;;use((_, _, next) =&gt; &#123; Js.log(&quot;here is use function&quot;); next();&#125;);useWithString(&quot;/user&quot;, userRoutes);app##get(&quot;/&quot;, (_, _, next) =&gt; &#123; Js.log(&quot;hello next&quot;); next();&#125;, (_, res, _) =&gt; res##send(&quot;Hello World!&quot;));app##listen(5000); 再重寫的時候會複習一下之前討論過的很多資料型態 發現不夠熟練 12let list1 = [0,1];let array1 = [|0, 1|]; 這兩種的轉譯結果會是 123456789101112var list1 = /* :: */[ 0, /* :: */[ 1, /* [] */0 ]];var array1 = /* array */[ 0, 1]; 可以看到這兩個的結果和原本預計的會有所不同 1234567type obj2Type = Js.t(&#123; . a: string&#125;);let obj1: &#123;. &quot;a&quot;: string&#125; = &#123;&quot;a&quot;: &quot;a&quot;&#125;;let obj2 = &#123;&quot;a&quot;: &quot;a&quot;, &quot;b&quot;: &quot;b&quot;&#125;; 上述的範例中 obj1 如果不定長度的話會引起錯誤 obj2 可以是任意長度 (Json) 轉譯結果 12345678var obj1 = &#123; a: &quot;a&quot;&#125;;var obj2 = &#123; a: &quot;a&quot;, b: &quot;b&quot;&#125;;","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"Express-Middleware","path":"/2018/10/27/Express-Middleware/","content":"Middleware昨天有用 Reason 寫出了一個 helloworld 今天來增加一些東西 use Route Middleware 多個 Middleware Json useExpress 的 middleware 有兩種形式 一種是 app.use 他的 input 是 handler 123456789101112131415161718192021222324252627282930313233343536/* 在上面的範例中 `require` 了一個 `express` 他是一個函式 它會回傳一個 `app` 的物件然和對 `app` 的這個物件 有使用到兩個函式`listen` 和 `get`listen 會丟入一個參數(int)get 會丟入兩個參數(string, function)而在 get 中丟入的 function 會有兩個物件 `req`, `res`因為只有使用到 `res.send`大致上我們可以先宣告剛剛有提到函式 和參數的類型 */type res = &#123;. [@bs.meth] &quot;send&quot;: string =&gt; string &#125;;type nextFun = unit =&gt; string;type handler = (string, res, nextFun) =&gt; string;type expressApp = &#123;. [@bs.meth] &quot;use&quot;: handler =&gt; unit, [@bs.meth] &quot;listen&quot;: (int) =&gt; unit, [@bs.meth] &quot;get&quot;: (string, handler, handler) =&gt; string&#125;;[@bs.module] external express: unit =&gt; expressApp = &quot;express&quot;;let app = express();app##use((_, _, next) =&gt; &#123; Js.log(&quot;here is use function&quot;); next();&#125;);app##get(&quot;/&quot;, (_, _, next) =&gt; &#123; Js.log(&quot;hello next&quot;); next();&#125;, (_, res, _) =&gt; res##send(&quot;Hello World!&quot;));app##listen(3000); 當你打開瀏覽器 http://localhost:3000 之後 終端機會顯示 12here is use functionhello next 這樣就完成了 use 的使用 簡單吧!","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"Reason-BasicType-Module","path":"/2018/10/27/Reason-BasicType-Module/","content":"Module模組就像是一個小的檔案 可以用 let binding 內嵌 module 建立使用 module 這個關鍵字來宣告 12345678910module School = &#123; type profession = Teacher | Director; let person1 = Teacher; let getProfession = (person) =&gt; switch(person) &#123; | Teacher =&gt; &quot;A teacher&quot; | Director =&gt; &quot;A director&quot; &#125;;&#125;; 模組中的值(包含型別) 可以像 record 一樣使用 . 來存取 12345678910111213module School = &#123; type profession = Teacher | Director; let person1 = Teacher; let getProfession = (person) =&gt; switch(person) &#123; | Teacher =&gt; &quot;A teacher&quot; | Director =&gt; &quot;A director&quot; &#125;;&#125;;let anotherPerson: School.profession = School.Teacher;print_endline(School.getProfession(anotherPerson)); 上面的範例中使用了 School.profession 的類型來宣告變數 巢狀的 module 也是一樣的使用方式 12345678module Mymodule = &#123; module NestedModule = &#123; let message = &quot;Hello&quot;; &#125;;&#125;;let message = Mymodule.NestedModule.message;print_endline(message); open Module要一直前置加上模組名稱會很繁瑣 所以可以利用 open 來簡化 1234/* let p: School.profession = School.getProfession(School.person1); *//*上述程式碼可以修改為*/open School;let p: profession = getProfession(person1); note: 要謹慎使用 open 最好在 local scope 中使用，否則會很難了解變數來源 12345let p = &#123; open School; print_endline(&quot;hello!&quot;); getProfession(person1);&#125;; 擴充模組使用 include 讓 module 靜態擴展到另一個新的模組 這句話很難理解吧！ 看個範例 12345678910111213module BaseComponent = &#123; let defaultGreeting = &quot;Hello&quot;; let getAudience = (~excited) =&gt; excited ? &quot;hello&quot; : &quot;world&quot;;&#125;;module ActualComponent = &#123; include BaseComponent; let defaultGreeting = &quot;Hey&quot;; let render = () =&gt; defaultGreeting ++ &quot; &quot; ++ getAudience(~excited=true);&#125;;print_endline(BaseComponent.defaultGreeting); /* Hello */print_endline(ActualComponent.defaultGreeting); /* Hey */ 上述範例中 ActualComponent 因為有 include BaseComponent; 所以會擁有 BaseComponent 的特性和方法 但是也可以在下面使用 let 來複寫某些參數或方法 note: open 和 include是完全不一樣的 前者是將內容帶到你的 scope 你就不用每次都要加上模組名稱來取值，後者則是複製一份值到新的模組內 在 Reason 中每一個檔案都是一個模組 1234567/*FileA.re*/let a = 1;let b = 2;/*FileB.re*/include FileA;print_endline(a); 標記式模組的類型稱為 signature 模組的實作是 re 模組的宣告是 rei 要建立一個 signature 要使用關鍵字 module type signature 名稱必須是大寫字母開頭 可以放置在 rei 檔案內 可以放在定義的 &#123;&#125; scope 內 1234module type EstablishmentType = &#123; type profession; let getProfession: profession =&gt; string;&#125;; signature 宣告了 module 必須滿足的型態要求 使 module 和 signature 相同 形式如下: let x: int; 要求 let 繫結名稱必須是 x，型別是 int type t = someType; 要求型別欄位 t 必須與 someType 相同 type t; 要求型別欄位 t，但並不強迫任何要求於 t 的實際、具體型別。 我們不能在標記式內使用 t 於其他項目來描述關係，例如 let makePair: t =&gt; (t, t) 上述 EstablishmentType 範例中 宣告一個類型 profession 必須要有一個函式來取得 profession 的值 擴展 Module 類型就像 Module 一樣 可以利用 include 來做擴展 module type 12345678910module type BaseComponent = &#123; let defaultGreeting: string; let getAudience: (~excited: bool) =&gt; string;&#125;;module type ActualComponent = &#123; /* the BaseComponent signature is copied over */ include BaseComponent; let render: unit =&gt; string;&#125;; note: BaseComponent是 module type 而不是 module 如果你沒有宣告 module type 可以透過實際的 module 來提取 include (module type of ActualModuleName) 例如我們可以繼承 OCmal 中的公用模組 List 1234module type MyList = &#123; include (module type of List); let myListFun: list(&#x27;a) =&gt; list(&#x27;a);&#125;; 每個 rei 都是一個標記式類似 .re 定義 Reason 模組 rei 定義 Reason 模組類型 React.re 的標記式預設是暴露所有模組內欄位 因為沒有包含實作檔案 .rei 在生態圈也用來作為相對應模組的文件 紀錄開放的 API Module.re 12type state = int;let render = (str) =&gt; str; Module.rei 12type state = int;let render: string =&gt; string; 模組函式(functors)模組可以包含函式 就像在檔案裡面寫函式 但是這還是有些不一樣 因為 module 定義在不同層級 所以我們稱之為 functors functors 使用關鍵字 module 而不是 let Functors 接受一個或多個模組作為參數並傳回一個模組 Functors 必須大寫字母開頭（就像是模組&#x2F;標記式） Functors 必須註解參數 12345678910111213141516171819module type Comparable = &#123; type t; let equal: (t, t) =&gt; bool;&#125;;module MakeSet = (Item: Comparable) =&gt; &#123; /* let&#x27;s use a list as our naive backing data structure */ type backingType = list(Item.t); let empty = []; let add = (currentSet: backingType, newItem: Item.t) : backingType =&gt; if (ListLabels.exists((x) =&gt; Item.equal(x, newItem), currentSet)) &#123; currentSet; &#125; else &#123; [ newItem, ...currentSet /* prepend to the set and return it */ ] &#125;;&#125;; 上述是一個 MakeSet Functor 他接受一個 Comparable 類型的 module 會回傳一個包含此類型的新集合 Functor 也可以和函式一樣使用參數 如下例 1234567891011121314151617181920212223242526module type Comparable = &#123; type t; let equal: (t, t) =&gt; bool;&#125;;module MakeSet = (Item: Comparable) =&gt; &#123; /* let&#x27;s use a list as our naive backing data structure */ type backingType = list(Item.t); let empty = []; let add = (currentSet: backingType, newItem: Item.t) : backingType =&gt; if (ListLabels.exists((x) =&gt; Item.equal(x, newItem), currentSet)) &#123; currentSet; &#125; else &#123; [ newItem, ...currentSet /* prepend to the set and return it */ ] &#125;;&#125;;module IntPair = &#123; type t = (int, int); let equal = ((x1, y1), (x2, y2)) =&gt; x1 == x2 &amp;&amp; y1 == y2; let create = (x, y) =&gt; (x, y);&#125;;module SetOfIntPairs = MakeSet(IntPair); 模組函式類別Like with module types, functor types also act to constrain and hide what we may assume about functors. The syntax for functor types are consistent with those for function types, but with types capitalized to represent the signatures of modules the functor accepts as arguments and return values. In the previous example, we’re exposing the backing type of a set; by giving MakeSet a functor signature, we can hide the underlying data structure! 未翻譯 123456789101112131415161718192021222324252627282930313233module type Comparable = &#123; type t; let equal: (t, t) =&gt; bool;&#125;;module type MakeSetType = (Item: Comparable) =&gt; &#123; type backingType; let empty: backingType; let add: (backingType, Item.t) =&gt; backingType;&#125;;module MakeSet: MakeSetType = (Item: Comparable) =&gt; &#123; /* let&#x27;s use a list as our naive backing data structure */ type backingType = list(Item.t); let empty = []; let add = (currentSet: backingType, newItem: Item.t) : backingType =&gt; if (ListLabels.exists((x) =&gt; Item.equal(x, newItem), currentSet)) &#123; currentSet; &#125; else &#123; [ newItem, ...currentSet /* prepend to the set and return it */ ] &#125;;&#125;;module IntPair = &#123; type t = (int, int); let equal = ((x1, y1), (x2, y2)) =&gt; x1 == x2 &amp;&amp; y1 == y2; let create = (x, y) =&gt; (x, y);&#125;;module SetOfIntPairs = MakeSet(IntPair); 結論要小心的是 module 和 functor 在不同樣的語言層級 你無法輕易的將他們傳遞給 record 或 tuple 真的不得已的話一定要小心 因為很多時候只需要一個 record 或是 function 就夠了","tags":["Javascript","IThome2018","Reason"],"categories":["Reason"]},{"title":"Express-Router","path":"/2018/10/26/Express-Router/","content":"Router在上一篇中提到了 Middleware 今天會討論到更多細節的部分 但是第一步要先了解關於 Router Express 可以拿來寫 RESTful API 但是 route 要如何分類呢？ 雖然之前已經有用 app.get 來做基本的 route 但是如果大量使用的話其實會造成程式碼的雜亂跟難以維護 所以 Express 中有一個 Router 的 funciton 可以產出一個 Router 物件 然後再藉由 app.use 來做 route 的實現和管理 基本上可以這樣分類 分類方式沒有絕對答案 routes&#x2F;userRoutes.js 12345678const express = require(&#x27;express&#x27;);const router = express.Router();router.post(&#x27;/&#x27;, (req, res, _) =&gt; &#123; res.json(&#123;name: &#x27;tomas&#x27;&#125;);&#125;);module.exports = router; app.js 1234567891011const express = require(&#x27;express&#x27;);const userRouter = require(&#x27;./routes/usersRoutes&#x27;);const app = express();const port = 5000;app.use(&#x27;/user&#x27;, userRouter);app.get(&#x27;/&#x27;, (req, res) =&gt; res.send(&#x27;Hello World!&#x27;));app.listen(port, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`)); 這時候如果我們用 POST 呼叫 http://localhost:5000/user 得到的 respnose 會是 &#123;&quot;name&quot;: &quot;tomas&quot;&#125; 我想這部分應該沒什麼問題 然後我們按照之前的模式把這些程式碼改為 .re routes&#x2F;UserRoutes.re 12345678910111213141516171819202122type response = &#123;. &quot;name&quot;: string &#125;;type res = &#123;. [@bs.meth] &quot;send&quot;: string =&gt; string, [@bs.meth] &quot;json&quot;: response =&gt; string &#125;;type nextFun = unit =&gt; string;type handler = (string, res, nextFun) =&gt; string;type router = &#123;. [@bs.meth] &quot;get&quot;: (string, handler) =&gt; string, [@bs.meth] &quot;use&quot;: handler =&gt; unit&#125;;[@bs.module &quot;express&quot;] external router: unit =&gt; router = &quot;Router&quot;;let routes = router();routes##get(&quot;/&quot;, (_, res, _) =&gt; &#123; let resp = &#123;&quot;name&quot;: &quot;tomas&quot;&#125;; res##json(resp);&#125;); 123456789101112131415161718192021222324252627282930313233343536373839type res = &#123;. [@bs.meth] &quot;send&quot;: string =&gt; string &#125;;type nextFun = unit =&gt; string;type handler = (string, res, nextFun) =&gt; string;type expressApp = &#123;. [@bs.meth] &quot;use&quot;: handler =&gt; unit, [@bs.meth] &quot;listen&quot;: (int) =&gt; unit, [@bs.meth] &quot;get&quot;: (string, handler, handler) =&gt; string&#125;;type router = &#123;. [@bs.meth] &quot;get&quot;: (string, handler) =&gt; string, [@bs.meth] &quot;use&quot;: handler =&gt; unit&#125;;[@bs.module] external express: unit =&gt; expressApp = &quot;express&quot;;[@bs.module &quot;./routes/UserRoutes.bs&quot;] external userRoutes: router = &quot;routes&quot;;let app = express();[@bs.val] external use: handler =&gt; unit = &quot;app.use&quot;;[@bs.val] external useWithString: (string, router) =&gt; unit = &quot;app.use&quot;;use((_, _, next) =&gt; &#123; Js.log(&quot;here is use function&quot;); next();&#125;);useWithString(&quot;/user&quot;, userRoutes);app##get(&quot;/&quot;, (_, _, next) =&gt; &#123; Js.log(&quot;hello next&quot;); next();&#125;, (_, res, _) =&gt; res##send(&quot;Hello World!&quot;));app##listen(5000); 首先遇到幾個問題 一個是如何 require 正確的 routes/UserRoutes.bs 中的 routes? 延伸怎麼控制 export ? 只能用 Reason 預設的？ app.use 有兩種 input 格式 如何處理? 1[@bs.module &quot;./routes/UserRoutes.bs&quot;] external userRoutes: router = &quot;routes&quot;; 第一個問題基本上上述那一行就可以解決 Import And Export之前有提過如何引用共用模組 今天來談談本地的模組引用問題 在 Reason 中如何控制 export 呢？ BuckleScript 支援 CommonJS (require(‘MyFile’)) ES6 modules (import myFile from ‘MyFile’) AMD(define([‘myFile’], …) 預設的 let 綁定的值都會自動 export 所以其他檔案都可以使用 Export ES6 valueexample: student.js 1export default name = &quot;Al&quot;; teacher.js 1import studentName from &#x27;student.js&#x27;; 在 Reason 中只需要用 let 綁定 default 這個變數 就可以自動輸出 ES6 預設模組 FavoriteStudent.ml 1let default = &quot;default value&quot;; demo.js 1import studentName from &#x27;FavoriteStudent.js&#x27;; Import使用 @bs.module 12[@bs.module &quot;path&quot;] external dirname : string =&gt; string = &quot;dirname&quot;;let root = dirname(&quot;/User/chenglou&quot;); output 12var Path = require(&quot;path&quot;);var root = Path.dirname(&quot;/User/chenglou&quot;); Import Default value12[@bs.module] external leftPad : string =&gt; int =&gt; string = &quot;./leftPad&quot;;let paddedResult = leftPad(&quot;hi&quot;, 5); output 12var LeftPad = require(&quot;./leftPad&quot;);var paddedResult = LeftPad(&quot;hi&quot;, 5); Import an ES6 Default value12[@bs.module &quot;./student&quot;] external studentName : string = &quot;default&quot;;Js.log(studentName); 12const Student = require(&quot;./student&quot;);console.log(Student.default); 當你在 BuckleScript 端使用的名稱和 JS 名稱相匹配 你可以使用空字串 1[@bs.module &quot;path&quot;] external dirname : string =&gt; string = &quot;&quot;; 相同的 Function 不同的參數我們可以看到 app.use 和 router.use 中有兩種不同的輸入值 12345app.use((req, res, next) =&gt; &#123; next();&#125;);app.use(&#x27;/user&#x27;, userRouter); 如上例可以看到 相同的 app.use 卻有兩種不同的輸入值得型態 在強形態中不能將這種 視為同樣的一個 function 所以要將它分為兩種 function 型態 12345678type handler = (string, res, nextFun) =&gt; string;type router = &#123;. [@bs.meth] &quot;get&quot;: (string, handler) =&gt; string, [@bs.meth] &quot;use&quot;: handler =&gt; unit&#125;;[@bs.val] external use: handler =&gt; unit = &quot;app.use&quot;;[@bs.val] external useWithString: (string, router) =&gt; unit = &quot;app.use&quot;; 可以看到 use 的 參數是放入一個 handler 的類型 而另一個 useWithString 也是 app.use 但是參數的類型是另外的 (string, router) =&gt; unit 第一個參數是字串 第二個是 router 的類型 裡面有一個 get 和 use 的 method 當然若是要實現 RESTful API 要再增加 post, put, delete…. 不過方式也都一樣 也就不贅述了","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"Express-helloworld-API","path":"/2018/10/21/Express-helloworld-API/","content":"Express API之前聊了很多基本的型態和使用 開始來做一些實際的東西(不然有點無聊) 在 Nodejs 中似乎想到 API 都會先想到 Express 今天先用 Reason 寫一個 Express 的 hello world API 但是在這之前 我們先用最簡單的 nodejs 寫一個 Express hello world API 然後再慢慢轉為 Reason Hello world安裝 express 和開始 watch re 檔案 12$ npm install express$ yarn start app.js 1234567const express = require(&#x27;express&#x27;);const app = express();const port = 3000;app.get(&#x27;/&#x27;, (req, res) =&gt; res.send(&#x27;Hello World!&#x27;));app.listen(port); 步驟在上面的範例中 require 了一個 express 他是一個函式 它會回傳一個 app 的物件 然和對 app 的這個物件 有使用到兩個函式 listen 和 get listen 會丟入一個參數(int) get 會丟入兩個參數(string, function) 而在 get 中丟入的 function 會有兩個物件 req, res 因為只有使用到 res.send 大致上我們可以先宣告剛剛有提到函式 和參數的類型 再寫上 express 的程式 結果如下 12345678910111213141516type res = &#123;. [@bs.meth] &quot;send&quot;: string =&gt; string &#125;;type handler = (string, res) =&gt; string;type expressApp = &#123;. [@bs.meth] &quot;listen&quot;: (int) =&gt; unit, [@bs.meth] &quot;get&quot;: (string, handler) =&gt; string&#125;;[@bs.module] external express: unit =&gt; expressApp = &quot;express&quot;;let app = express();app##get(&quot;/&quot;, (_, res) =&gt; res##send(&quot;Hello World!&quot;));app##listen(3000); 有一些東西看不懂 BuckleScript - Class裡面有些東西和 BuckleScript 的 Class 有關係 先來聊聊 在 Reason 中如何使用 class new 出一個物件 @bs.new以 Date 為範例 1234type t;[@bs.new] external createDate: unit =&gt; t = &quot;Date&quot;;let date = createDate(); 上面的程式碼會編譯為 1var date = new Date(); 如果你想要用 moment 可以利用 @bs.new 和 @bs.module 並且設定回傳可以使用的 method 12345678type momentResult = &#123;. [@bs.meth] &quot;format&quot;: (string) =&gt; string&#125;;[@bs.new] [@bs.module] external moment: unit =&gt; momentResult = &quot;&quot;;let date = moment();Js.log(date##format(&quot;YYYY&quot;)); 上面的程式碼會轉為 12345var Moment = require(&quot;moment&quot;);var date = new Moment();console.log(date.format(&quot;YYYY&quot;)); /* 2018 */ 主要是因為在 moment 增加一個回傳的 momentResult 的類型 代表回傳了一個 Javascript 物件 裡面有一個 format 的函式可以使用 需要傳入一個 string 會回傳一個 string 綁定 JS ClassJS Class 其實就是 Object 和 Class 利用一些方式連接起來 OCaml 通常會增加 [@bs] 將 class 轉為 Js.t 類型 12345678910class type _moment = [@bs] &#123; pub format: (string) =&gt; string; &#125;;type momentResult = Js.t(_moment);[@bs.new] [@bs.module] external moment: unit =&gt; momentResult = &quot;&quot;;let date = moment();Js.log(date##format(&quot;YYYY&quot;)); /* 2018 */ 這個做法也是可以 結果是同樣的 但是這個做法可以使用 [@bs.meth] 來宣告非 arrow function 這些值會被視為 properties [@bs.set] 則會將這些參數視為可以更動的 (mutable) 之後要修改值的時候要使用 #= 刪除 [@bs.set] 則會變為 不可變動的(immutable) 這部分之後在 JS package 中會做更詳細的討論 Middleware先實做一個 簡單的 Middleware 12345678910111213141516171819202122type res = &#123;. [@bs.meth] &quot;send&quot;: string =&gt; string &#125;;type nextFun = unit =&gt; string;type handler = (string, res, nextFun) =&gt; string;type expressApp = &#123;. [@bs.meth] &quot;listen&quot;: (int) =&gt; unit, [@bs.meth] &quot;get&quot;: (string, handler, handler) =&gt; string&#125;;[@bs.module] external express: unit =&gt; expressApp = &quot;express&quot;;let app = express();app##get(&quot;/&quot;, (_, _, next) =&gt; &#123; Js.log(&quot;hello next&quot;); next();&#125;, (_, res, _) =&gt; res##send(&quot;Hello World!&quot;));app##listen(3000); 但是每次多一個 middleware 都要對一個 type 做一次修改 感覺很麻煩啊 今天先到這邊吧 之後再來處理 Middleware 的問題了","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"BasicType-OptionsAndSomeAndNone","path":"/2018/10/20/BasicType-OptionsAndSomeAndNone/","content":"Null 和 Undefined 和 OptionReason 並沒有 null 和 undefined 的概念 這是很棒的事情，因為可以減少很多型態的 bugs 再也看不到 undefined is not a function 或是 cannot access foo of undefined 但是 這些值其實依舊存在但是在 Reason 可以安全的存在 因為是通過 Option 來表示值是否存在 1type option(&#x27;a) = None | Some(&#x27;a); 這代表這個值得類型是 None (無) 或是實際值包含在 Some 中 範例1234567let personHasCar = false;if(personHasCar) &#123; Some(5);&#125; else &#123; None;&#125; 如果要表示一個數可能會是 None 但是可以利用另一種寫法 12345678let licenseNumber = Some(5);switch (licenseNumber) &#123; | None =&gt; print_endline(&quot;The person doesn&#x27;t have a car&quot;) | Some(number) =&gt; print_endline(&quot;The person&#x27;s license number is &quot; ++ string_of_int(number)) &#125;; 透過將數字串為選項 強迫您列舉出所有可能的選項和回應 杜絕錯誤處理或忘記處理的情況 OptionOption 其實就是等於 Some(&#39;a) 或 None 這在 Javascript 中十分常見 警告11let aaa = Some(Some(Some(5))) 這個依舊會被編譯為 let aaa = 5; 但是下面的狀況會比較麻煩 1let bbb = Some(None); 上面那一行會被編譯為 1var bbb = Js_primitive.some(undefined); 什麼是 Js_primitive ? 怎麼不直接編譯為 var bbb = undefined; 這樣就好了？ 在處理多種 Option 的型態的時候 如果沒有用一些特殊註解來標記這些值的話 很多操作上都會變得棘手 以下有幾個原則可以遵守 永遠不要內嵌 Option (Ex: Some(Some(Some(5)))) 不要指定 Option(&#39;a) 給來源是 Javascript 的值，給予準確的型態 警告2但是很多時候在 Javascript 總是會有 null 或是未定義 在這種情況下我們無法輸入這種值 因為 option 只會檢查 undefined 而不會檢查 null 解法: Js.Nullable有提供 Js.Nullable 這個模組來檢查 undefined 和 null 要建立 undefined 可以使用 Js.Nullable.undefined 當然你也可以使用 None 這並不衝突 範例1234567[@bs.module &quot;MyIdValidator&quot;] external myId: Js.Nullable.t(string) = &quot;MyID&quot;;[@bs.module &quot;MyIdValidator&quot;] external validate: Js.Nullable.t(string) =&gt; bool = &quot;validate&quot;;let personId: Js.Nullable.t(string) = Js.Nullable.return(&quot;abc123&quot;);let result = validate(personId); Js.Nullable.return 可以回傳的是一個允許他是 null 的字串 而不僅僅是單純的字串格式 None 和 Js.Nullable 是很重要的一部分 因為他補足了強形態中處理 null 和 undefined 的問題 More on Type型別是可以接受參數的 類似別種語言的(generics) 參數必須使用 &#39; 開頭 1234type intCoordinates = (int, int, int);type floatCoordinates = (float, float, float);let buddy: intCoordinates = (10, 20, 20); 這是基本的使用方法 可以改為 12345type coordidate(&#x27;a) = (&#x27;a, &#x27;a, &#x27;a);type coordidateAlias = coordidate(int);let buddy: coordidateAlias = (10, 20, 20); 其實型別會自動幫你推導 所以更簡潔的寫法是 1let buddy = (10, 20, 20); 這時候會自動推導它為 (int, int, int) 型別 1let greetings = [&quot;hello&quot;, &quot;world&quot;, &quot;how are you&quot;]; 會自動推導為 list(string) 型別也可以接受多個參數 123456789101112type result(&#x27;a, &#x27;b) = | Ok(&#x27;a) | Error(&#x27;b);type myPayload = &#123;data: string&#125;;type myPayloadResults(&#x27;errorType) = list(result(myPayload, &#x27;errorType));let payloadResults: myPayloadResults(string) = [ Ok(&#123;data: &quot;hi&quot;&#125;), Ok(&#123;data: &quot;bye&quot;&#125;), Error(&quot;Something wrong happened!&quot;)]; 相互遞迴型別12type student = &#123;taughtBy: teacher&#125;and teacher = &#123;student: list(student)&#125;; 第一行沒有分號 第二行開頭沒有 type 設計決策型別系統基本上允許階層 例如: list(int) 實際是 list 型別 中接受 int 型別 其他語言有的會稱之為泛型 遵循 The principle of least power原則 在解決方法中選擇最不複雜的一個來使用","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"BuckleScript-Object","path":"/2018/10/19/BuckleScript-Object/","content":"Bukle Script ObjectJavascript 中的物件有兩個主要的目的 像是一個雜湊表(或是字典)， Keys 可以動態的 新增&#x2F;刪除 ，值是同樣的型態 像是一個紀錄(Record)，欄位是固定的(但是也允許是選擇性的)，他的值可以是不同的形態 這部分 BuckleScript 的物件也是一樣的 雜湊表模式直到最近 Javascript 才終於有正確的支援 Map 物件使用上和 Map 可以是一樣的 前提是 可能會或是不會 新增&#x2F;刪除 參數的鰎值 值可以被 動態&#x2F;計算 鍵值 瀏覽 值得型態都是一樣 這時候可以利用 Js.Dict 來綁定這個 Javascript 物件 你可以就像 Javascript 中的 Object 來做操作 Js.Dict.keys 來取得所有的鍵值 Js.Divt.values 來取得所有的值 範例12345678910let myMap = Js.Dict.empty();Js.Dict.set(myMap, &quot;Allison&quot;, 10);[@bs.val] external studentAge: Js.Dict.t(int) = &quot;student&quot;;switch (Js.Dict.get(studentAge, &quot;Joe&quot;)) &#123;| None =&gt; Js.log(&quot;Joe can&#x27;t be found&quot;)| Some(age) =&gt; Js.log(&quot;Joe is &quot; ++ string_of_int(age));&#125;; 轉譯後的結果 12345678910111213&#x27;use strict&#x27;;var myMap = &#123; &#125;;myMap[&quot;Allison&quot;] = 10;var match = student[&quot;Joe&quot;];if (match !== undefined) &#123; console.log(&quot;Joe is &quot; + String(match));&#125; else &#123; console.log(&quot;Joe can&#x27;t be found&quot;);&#125; 你可以看到其實 Js.Dict 是基於 Javascript 的物件 整個 API 都沒有使用到 external 所以在編譯之後 整個 API 都會消失 編譯結果中你也找不到 Dict 的相關字 這很便於你將 Js 檔案轉為 BuckleScript 檔案 Record 模式如果你的 Js 物件: 有固定並且已知的欄位 包含的值有不同的型別 這時候大多數的程式語言中 你都可以使用 Record 例如:12345&#123; &quot;John&quot;: 10, &quot;Allison&quot;: 20, &quot;Jimmy&quot;: 15&#125; 和 12345&#123; name: &quot;John&quot;, age: 10, job: &quot;CEO&quot;&#125; 的不同 前者會使用 雜湊表 的型態來處理 後者會使用 Record 來處理 而在 BuckleScript 中要使用 bs.deriving abstract 功能 後者則會這樣寫 12345678[@bs.deriving abstract]type person = &#123; name: string, age: int, job: string&#125;;[@bs.val] external john: person = &quot;john&quot;; note person 並不是一個 Record 的型別 他只是看起來像是 Record 的型別 而且可以使用 Record 的形態檢查 bs.deriving abstract 就是在註解將 person 轉為 抽象型別 建立上述的抽象型別因為不是 Record 型別 所以不能直接使用型態的方式來建立 12345678[@bs.deriving abstract]type person = &#123; name: string, age: int, job: string,&#125;;let joe = person(~name=&quot;Joe&quot;, ~age=20, ~job=&quot;teacher&quot;) 轉譯後的結果 123456789101112// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE&#x27;use strict&#x27;;var joe = &#123; name: &quot;Joe&quot;, age: 20, job: &quot;teacher&quot;&#125;;exports.joe = joe;/* No side effect */ 結果對於運行並不會有成本 欄位重新命名有時候在綁定 JS object 的時候，欄位名稱在 BuckleScript&#x2F;Reason 中是無效的名稱 有兩種範例 一個是 &#123;type: &quot;foo&quot;&#125; (BS&#x2F;Reason 中的保留字) 和 &#123;&quot;aria-checked&quot;: true&#125; 可以選擇另一個有效的名稱 使用 @bs.as 來規避這個問題 1234567[@bs.deriving abstract]type data = &#123; [@bs.as &quot;type&quot;] type_: string, [@bs.as &quot;aria-checked&quot;] ariaLabel: string&#125;;let d = data(~type_=&quot;message&quot;, ~ariaLabel=&quot;hello&quot;); 輸出會是 1234567&#x27;use strict&#x27;;var d = &#123; type: &quot;message&quot;, &quot;aria-checked&quot;: &quot;hello&quot;&#125;; 可選的標籤可以建立可忽略的 欄位 123456789[[@bs.deriving abstract]type person = &#123; [@bs.optional] name: string, age: int, job: string&#125;;let joe = person(~age=19, ~job=&quot;sleep&quot;, ());Js.log(joe); 編譯後會是 12345678910111213141516171819var Js_primitive = require(&quot;bs-platform/lib/js/js_primitive.js&quot;);function joe(param) &#123; return (function (param$1) &#123; var prim = param; var prim$1 = 19; var prim$2 = &quot;sleep&quot;; var tmp = &#123; age: prim$1, job: prim$2 &#125;; if (prim !== undefined) &#123; tmp.name = Js_primitive.valFromOption(prim); &#125; return tmp; &#125;);&#125;console.log(joe); 可以看到 name 會是可選的，若是沒有也不會造成錯誤 note:bs.optional 只是將 name 改為可選，但是如果輸入 Option(string) 不會有作用 Accessors當你使用 bs.deriving abstract 隱含了 recode 的型態，你無法使用 joe.age 這樣的方式來取得值 原生會提供 getter 和 setter 來完成這個 取值每一個 bs.deriving abstract 欄位 都會有一個 getter function 在上面的範例中會有三個 getter function ，nameGet, ageGet, jobGet 他們會取得 person 的值並分別回傳 string, int, string 12345678910111213141516[@bs.deriving abstract]type person = &#123; [@bs.optional] name: string, age: int, job: string,&#125;;let joe = person(~age=20, ~job=&quot;teacher&quot;, ());let twenty = ageGet(joe);Js.log(twenty);/**也可以寫成這樣joe-&gt; ageGet-&gt; Js.log**/ 至於改值則是 123456789101112[@bs.deriving abstract]type person = &#123; [@bs.optional] name: string, mutable age: int, job: string,&#125;;let joe = person(~age=20, ~job=&quot;teacher&quot;, ());joe-&gt; ageGet-&gt; Js.log; /* 20 */joe-&gt; ageSet(21)-&gt; Js.log;joe-&gt; ageGet-&gt; Js.log; /* 21 */ note: 要記得將需要修改的參數前面加上 mutable Object Methods可以附加任何function 在類型上(任何類型的 record 不僅止於 @bs.deriving abtract) 可以參閱 Object Method 這部分之後會再討埨 可變性Test.re 12345[@bs.deriving abstract]type cord = &#123; [@bs.optional] mutable x: int, y: int,&#125;; Test.rei 12345[@bs.deriving abstract]type cord = &#123; [@bs.optional] x: int, y: int,&#125;; Object2如果上述的 Object 並不符合您的需求 也有另外一種方式可以綁定 Javascript Object 有幾個前提 你不想要預先宣告 type 你希望你的 Object 是有結構性的 Ex: 你的類型希望可以接受所有含有 age 這個參數的物件，而不是只有特定參數的物件 陷阱note: 不能使用普通的 Reason&#x2F;OCaml 的物件類型，如下 123456type person = &#123; . name: string, age: int, job: string&#125;; 你仍然可以宣告這個類型 但是無法編譯成功 因為 Reason/OCaml 的對象工作方式是不一樣的 解決方案BuckleScript 利用 Js.t 來做包裝類型 以便控制和追蹤可以編譯成 Javascript 的對象子集合 12345678910type person = Js.t(&#123; . name: string, age: int, job: string&#125;);let john = &#123;&quot;name&quot;: &quot;john&quot;, &quot;age&quot;: 11&#125;;john##name -&gt; Js.log; 從現在開始 BuckleScript 都會以 Js.t 來消除跟 一般物件 和 Javascript 物件的歧義 因為 Reason 有包覆一層語法糖 會將 Js.t(&#123;. name: string&#125;) 轉為 &#123;. &quot;name&quot;: string&#125; 訪問 與 修改取值要取得值的話方法為 ## 範例如下 1234567891011121314type person = Js.t(&#123; . name: string, age: int, job: string&#125;);let john = &#123; &quot;name&quot;: &quot;john&quot;, &quot;age&quot;: 11, &quot;job&quot;: &quot;development&quot;&#125;;let johnName = john##name; 明天再來談談 Some 和 Option 的問題","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"BuckleScript-Best-Friend","path":"/2018/10/14/BuckleScript-Best-Friend/","content":"BuckleScriptOCamlBuckleScript 的基礎 如果需要對 OCaml 有興趣可以參考 官方文件 如果對 Reason 有興趣可以參考 官方文件 ReasonOCaml 的另一種語法，對 Javascript 的開發者比較親切 OPAM官方的套件管理， 自從 BuckleScript 支援 NPM&#x2F;YARN 之後就不需要使用他了 External&#x2F;Interop&#x2F;FFI都是 BuckleScript &lt;-&gt; JavaScript 交互編譯的術語 External - 在 BuckleScript 中使用 JS 值得一種方式 Interop - interoperability 的縮寫 FFI - Foreign Function Interface 的縮寫, “external”, “wrapper” 和 “interop” 的通用術語, 基本上就是在一個語言中呼叫另一個語言的值 值 \bbs 意義 \bval [@bs.val] global value scope [@bs.scope] use names as a namespace new [@bs.new] new constructor module [@bs.module] 從某一個 mobule \b綁定其中一個值 send @bs.send function chaining send.pipe @bs.send.pipe function chaining includes parameters splice [@bs.splice] 具有不定長度參數的函式 note:這只是一小部分 使用場景 在 Reason 中直接寫 Javascript 引用 js lib 使用 (global, default, other libs) 使用現有 Bucklescript 所提供的lib 原生 Javascript12345[%%raw &quot;var a = 1, b = 2&quot;];let add = [%raw &quot;a + b&quot;];let myFunction = [%raw &quot;(a, b) =&gt; a + b&quot;]Js.log(myFunction(1)(2)); 字串 Unicode 和 template string12345Js.log(&#123;js|你好，世界|js&#125;);let world = &quot;world&quot;;let helloWorld = &#123;j|hello, $world|j&#125;; 全域變數\bnote: 先看看官方是否有先幫你完成的 API 再決定是否要自己處理 1234[@bs.val] external setTimeout/* 在 Reason 中使用的模組名稱 */: (unit =&gt; unit, int) =&gt; float = &quot;setTimeout&quot;;/* 對應到 Javascript 中的模組名稱 */let eventId = setTimeout(() =&gt; Js.log(&quot;hello setTimeout&quot;), 1000);Js.log(eventId); function chaining亦或是利用 map 和 filter 做一些陣列處理的時候 123456[@bs.send] external map: (array(&#x27;a), &#x27;a =&gt; &#x27;b) =&gt; array(&#x27;b) = &quot;&quot;;[@bs.send] external filter: (array(&#x27;a), &#x27;a =&gt; &#x27;b) =&gt; array(&#x27;b) = &quot;&quot;;let mapResult = map([|1, 2, 3|], a =&gt; a + 1);let result = filter(mapResult, a =&gt; a mod 2 === 0);Js.log(result); 上面的範例 map 和 filter 為什麼要使用 send 呢？ 也有另外一個比較漂亮的做法 1234567[@bs.send] external map: (array(&#x27;a), &#x27;a =&gt; &#x27;b) =&gt; array(&#x27;b) = &quot;&quot;;[@bs.send] external filter: (array(&#x27;a), &#x27;a =&gt; &#x27;b) =&gt; array(&#x27;b) = &quot;&quot;;[|1, 2, 3|]-&gt;map(a =&gt; a+1)-&gt;filter(a =&gt; a mod 2 === 0)-&gt;Js.log 但是這部分之後再探討 全域模組123456[@bs.val] [@bs.scope &quot;Math&quot;] external random: unit =&gt; float = &quot;random&quot;;let someNumber = random();/**//* front end demo */[@bs.val] [@bs.scope (&quot;window&quot;, &quot;location&quot;, &quot;ancestorOrigins&quot;)] external length: int = &quot;length&quot;; 可空值12let a = Some(5);let b = None; 123456let JsNullable = Js.Nullable.null;let JsUndefined = Js.Nullable.undefined;let result1: Js.Nullable.t(string) = Js.Nullable.return(&quot;hello&quot;); /* hello */let result2: Js.Nullable.t(int) = Js.Nullable.fromOption(Some(10)); /* 10 */let result3: option(int) = Js.Nullable.toOption(Js.Nullable.return(10)); /* 10 */ 這一部份在後續章節也會做更詳細的討論 模組預設輸出 ES6LeftPad.re 1let default = (name: string, age: int) =&gt; Js.log(&#123;j|$name 年紀 $age|j&#125;); Import ModuleImportModule.re 123[@bs.module &quot;./LeftPad.bs&quot;] external leftPad : (string, int) =&gt; string = &quot;default&quot;;leftPad(&quot;hello&quot;, 123); 因為 bsconfig.js 中的 suffix 設定為 .bs.js 所以當我們要 import 的時候需要加上 .bs 他編譯後的結果會是 123var LeftPadBs = require(&quot;./LeftPad.bs&quot;);LeftPadBs.default(&quot;hello&quot;, 123); 否則會找不到這個檔案 Global Module123[@bs.module &quot;path&quot;] external dirname: string =&gt; string = &quot;&quot;;Js.log(dirname(&quot;/foo/bar/baz/asdf/quux&quot;)); 123var Path = require(&quot;path&quot;);console.log(Path.dirname(&quot;/foo/bar/baz/asdf/quux&quot;)); @bs.module 會將模組引入 external 則是指定輸出的名稱 (在Reason 使用的名稱) 最後則是要引入的名稱，但是如果同名則可以設為空字串 參數長度可變使用 module path 中的 join 來做 demo 1234[@bs.module &quot;path&quot;] [@bs.splice]external join : array(string) =&gt; string = &quot;&quot;;Js.log(join([|&quot;/&quot;, &quot;hello&quot;, &quot;/&quot;, &quot;world&quot;|])); bs.module 先指定來源 path 再加上 bs.splice 來告訴 Reason 他是一個具有不固定長度參數的 function 利用 array 的 長度是彈性的優點來做彈性的多參數處理","tags":["Javascript","IThome2018","Reason","BuckleScript"],"categories":["Reason"]},{"title":"Reason-BasicTypeIII","path":"/2018/10/11/Reason-BasicTypeIII/","content":"Basic Type今天討論的東西會也很多(每天啃到天荒地老) Reason - Record Reason - Object Reason - Destructuring Reason - RecordReason - Record 很像 Javascript 的 Object 但是他有幾個特性 更輕量 預設是不可改變的 (Immutable) 欄位名稱和型別都是固定的 很快 是較嚴格的類別 基本使用123456789101112type person = &#123; age: int, name: string&#125;;let tomas = &#123; age: 35, name: &quot;Tomas Lin&quot;&#125;;let tomasName = tomas.name;print_endline(tomasName); /* Tomas Lin */ 需要明確的定義類型跟結構Record 需要先宣告一個基本的結構 (Type) 否則會報錯 如果符合則會自動型別推導 12345678910111213141516type person = &#123; age: int, name: string&#125;;let tomas: person = &#123; age: 35, name: &quot;Tomas Lin&quot;&#125;;let tomasName = tomas.name;print_endline(tomasName);let simon = &#123; age: 22, name: &quot;Simon&quot;&#125;; 上面的範例中 tomas 有指定型別是 person 但是 simon 並未指定，可是因為他的結構和 person 一樣 所以 Reason 會自動做型別推導為 person note:若是有兩個同樣型別結構的話則會依據較近的型別 你也可以將型別宣告在別的檔案中 但是需要明確的指定名稱 AnimalType.re 1type cat = &#123;color: string, call: string&#125;; Animal.re 123456let whiteCat: AnimalType.cat = &#123; color: &quot;white&quot;, call: &quot;喵!&quot;&#125;;print_endline(whiteCat.call); Spread 修改 (immutable update)因為 Record 是不可以直接修改的 可以利用 Spread 來做修改的實作 範例如下 1234567891011121314151617181920type person = &#123; age: int, name: string&#125;;let tomas: person = &#123; age: 35, name: &quot;Tomas Lin&quot;&#125;;let tomasName = tomas.name;print_endline(tomasName);let simon = &#123; age: 22, name: &quot;Simon&quot;&#125;;let tomasNextYear = &#123;...tomas, age: tomas.age + 1&#125;;Js.log(tomasNextYear.age);/* 36 */ 注意:Spread修改不能夠增加新的欄位 mutable updateReason 也保有直接修改的彈性 範例如下: 123456789101112131415161718192021type person = &#123; age: int, mutable name: string&#125;;let tomas: person = &#123; age: 25, name: &quot;Tomas Lin&quot;&#125;;let name = &quot;Simon&quot;;let simon = &#123; age: 25, name&#125;;tomas.age = tomas.age + 1;Js.log(tomas.age); /* 26 */Js.log(simon.name); /* Simon */ 也支援 punning 簡化程式碼 不能用 Record 處理的問題 Reason 中你無法宣告一個 function 他的參數傳入一個物件 這個物件中必要參數是 age 而其他參數都是可以變動的 範例如下 1234567891011121314type person = &#123;age: int, name: string&#125;;type monster = &#123;age: int, hasTentacles: bool&#125;;let getAge = (entity) =&gt; entity.age;let kraken = &#123;age: 9999, hasTentacles: true&#125;;let me = &#123;age: 5, name: &quot;Baby Reason&quot;&#125;;getAge(kraken);getAge(me); /* get Error: This has type: person But somewhere wanted: monster */ Type system 不能定義一個類型是 person 或 monster 當你有這類型需求的話 接下來介紹的 Reason - Object 可以滿足 Reason - Object有些時候 Reason - Record 無法滿足一些特殊情境的需求 所以便有了 Reason - Object 增加一些彈性 型別物件不一定要宣告型別 看起來和 Reason - Record 十分相似 除了 . 和 .. 範例如下 1234type tesla = &#123; . color: string&#125;; 開頭 . 代表這是一個閉鎖的物件 任何基於這個型別的物件都必須完全符合結構 1234type car(`a) = &#123; .. color: string&#125; as `a; 開頭 .. 則代表這是開放型的物件，所以可以包含其他值或 function 開放型的物件代表是多型 所以需要一個參數 ExampleSimple1234567891011type tesla = &#123; . color: string,&#125;;let obj: tesla = &#123; val red = &quot;Red&quot;; pub color = red;&#125;;Js.log(obj#color) /* &quot;Red&quot; */ 在這個物件中含有兩個屬性 私有屬性 red 和 color method 因為 color 是一個公開的 method 所以我們可以利用 object notation 來標記取得值 物件只導出Method，所有屬性都是Private的 Advanced123456789101112type tesla = &#123;. drive: (int) =&gt; int&#125;;let obj: tesla = &#123; val hasEnvy = ref(false); pub drive = (speed) =&gt; &#123; this#enableEnvy(true); speed; &#125;; pri enableEnvy = (envy) =&gt; hasEnvy := envy&#125;; 在這個範例中 tesla 中一個公開的 drive 也有一個私有的 enableEnvy method 私有的 method 只可以在物件內部取用 Reason 也有 this 和 Javascript 的 this 不一樣的地方在於 Reason 的 this 永遠都會指向物件本身 開放式物件的範例1234567891011121314151617181920212223type tesla(&#x27;a) = &#123; .. drive: int =&gt; int&#125; as &#x27;a;type teslaParams = &#123;. drive: int =&gt; int, doYouWant: unit =&gt; bool&#125;;let obj: tesla(teslaParams) = &#123; val hasEnvy = ref (false); pub drive = (speed) =&gt; &#123; this#enableEnvy(true); speed; &#125;; pub doYouWant = () =&gt; hasEnvy^; pri enableEnvy = (envy) =&gt; hasEnvy := envy&#125;;Js.log(obj#doYouWant());Js.log(obj#drive(11));Js.log(obj#doYouWant()); 上面的 tesla 中為開放型物件 但是需要有一個參數 teslaParams 定義所有開放的的 method 但是如果你要找由 Javascript 的物件，你需要的不是 Reason - Object 而是特別的 BukleScript - Record special Record Reason - Destructuring (解構)解構是很清楚簡單的方式來取得物件或陣列中的變數 用法下面綁定 ten = 10 和 twenty = 20 1234let someInts = (10, 20);let (ten, twenty) = someInts;Js.log(ten);Js.log(twenty); 下列綁定變數 name = &quot;Guy&quot; 和 age = 30 12345type person = &#123;name: string, age: int&#125;;let somePerson: person = &#123;name: &quot;Tomas&quot;, age: 30&#125;;let &#123;name, age&#125; = somePerson;Js.log(name);Js.log(age); 取回變數後可以重新命名 12345type person = &#123;name: string, age: int&#125;;let somePerson: person = &#123;name: &quot;Tomas&quot;, age: 30&#125;;let &#123;name: n, age: a&#125; = somePerson;Js.log(n);Js.log(a); 也可以定義型態 12345type person = &#123;name: string, age: int&#125;;let somePerson: person = &#123;name: &quot;Tomas&quot;, age: 30&#125;;let &#123;name: (n: string), age: (a: int)&#125; = somePerson;Js.log(n);Js.log(a); 當然函式的標籤式參數也可以解構 123456789101112131415161718type person = &#123; name: string, age: int&#125;;let tomas = &#123;name: &quot;Tomas&quot;, age: 25&#125;;let someFunction = (~person as &#123;name&#125;) =&gt; &#123; Js.log(name);&#125;;let otherFunction = (~person as &#123;name&#125; as thePerson) =&gt; &#123; Js.log(thePerson); Js.log(name);&#125;;someFunction(~person=tomas);otherFunction(~person=tomas); Mutable有時候我們會需要可以變更的變數 Reason 也有保留這部分的彈性 1234type total = ref(int);let x: total = ref(5);x := x^ + 1;Js.log(x); // 6 ref 只是一個語法糖 透過 := 修改 ^ 代表取出他的值 這樣就可以簡單地在 Reason 中使用 Mutation 的技巧","tags":["Javascript","IThome2018","Reason"],"categories":["Reason"]},{"title":"Reason-BasicType Part-II","path":"/2018/10/10/Reason-BasicTypeII/","content":"Basic Type上一章節已經有討論了幾種基本類型 這是今天要了解的幾種型態 Function Array Tuple List FunctionFunction 在日常 coding 是相當常見與重要的部分 Reason 中是以箭頭以及回傳表達式 以逗號隔開參數 12let greet = (hello, name) =&gt; hello ++ &quot; &quot; ++ name;Js.log(greet(&quot;Hello&quot;, &quot;Tomas&quot;)); 無參數有時候 Function 中不需要傳入參數 這裡稱為 unit 12let sayHello = () =&gt; &quot;Hello&quot;;Js.log(sayHello()); /* Hello */ 參數的標籤12345let subNumber = (x, y) =&gt; &#123; return x - y;&#125;;Js.log(subNumber(1, 2)); /* 1 */ 這裡其實很難知道哪個是 x, 哪個是 y 我們可以加上 ~ 這樣的話會變成 12345let subNumber = (~x, ~y) =&gt; &#123; return x - y;&#125;;Js.log(subNumber(~x=1, ~y=2)); 也可以利用 as 加上別名 1234567let drawCircle = (~radius as r, ~color as c) =&gt; &#123; setColor(c); startAt(r, r); /* ... */&#125;;drawCircle(~radius=10, ~color=&quot;red&quot;); 事實上，(radius) 只是 (radius as radius) 的速寫法(稱之為 雙關(punning)) Optional 參數12345678let saySomeThing = (~name, ~title) =&gt; &#123; switch title &#123; | None =&gt; &quot;Hello &quot; ++ name; | Some(t_) =&gt; t_ ++ name; &#125;;&#125;Js.log(saySomeThing(~name=&quot;Tomas&quot;)); title 並不是一定要輸入的參數 如果為空預設值是 None 利用 switch 來涵蓋相對的 回傳值 Tuple在 Javascript 中並沒有 Tuple 的概念 而被整合在 Array 之中 Reason 中的 Tuple 需要符合幾種特性 不可變(immutable) 有順序性的 一開始就已經固定長度 允許包含不同的值 tuple 長度不會是 1。若長度為 1 就是值本身。 Pair operations官方提供 fst 和 snd 來快速取得 Tuple中第一 二個值 若是要取得其他更多的值，可以多多利用解構 123456789type testTuple = (int, int, int);let test: testTuple = (1, 2, 3);let (_, second, _) = test;Js.log(second);/* 2 *//* Js.log(fst(test)); get compiler Error */type test2Tuple = (int, int); 盡量在 區域性 使用 Tuple，若是有經常傳遞的需求則可以考慮使用 record 而且 Tuple + Switch 是十分強大的應用，可以解決 category bug 因為 Reason 會強迫你列出 2*2&#x3D;4的所有可能情況而不用使用 if else 來做處理 123456switch (isWindowOpen, isDoorOpen) &#123;| (true, true) =&gt; &quot;window and door are open!&quot;| (true, false) =&gt; &quot;just window open&quot;| (false, true) =&gt; &quot;just door open&quot;| (false, false) =&gt; &quot;window and door are not open&quot;&#125; 但是總會有些時候必須要修改某個 Tuple 中的一個值 對 Reason 來說這就是一個新的 Tuple 範例如下: 123let tuple1 = (1, 2);let tuple2 = (fst(tuple1), 4);Js.log(tuple2); List特性 包含的參數需要同型態 不可變的(immutable) 在陣列前面 shift 元素會效率很好 12let myList: list(int) = [1, 2, 3];let anotherList = [0, ...myList]; myList 的值不會被改變， antherList現在是 [0, 1, 2, 3] 為什麼他的效能式常數而不是線性的? 因為在 anotherList 中的 myList 是 shared 的 note: 但是並不允許 [0, ...aList, ...bList] 你可以使用 ListLabels.concat 來實現 Reason 提供了一些基本的 API 但是在使用的時候名稱是 ListLabels 1234let myList: list(int) = [1,2,3];let anotherList = [0, ...myList];Js.log(ListLabels.length(myList)); /* 3 */Js.log(ListLabels.length(anotherList)); /* 4 */ Switch也可以搭配 pattern matching 12345678let myList: list(int) = [1, 2];let message = switch (myList) &#123; | [] =&gt; &quot;This list is Empty&quot; | [a, ...rest] =&gt; &quot;a: &quot; ++ string_of_int(a) ++ &quot; rest.length is &quot; ++ string_of_int(ListLabels.length(rest)) &#125;;Js.log(message); /* a: 1 rest.length is 1 */ Array特性 可變的 快速的任意存取和修改 原生固定長度 (Javascript 彈性長度) 前後需要使用 [| 和 |] 可以使用 Array 和 ArrayLabels 而針對 JS compiler 也可以使用 Js.Array API 1234567let arrayTest = [|&quot;hello&quot;, &quot;eeee&quot;, &quot;yo&quot;|];Js.log(arrayTest[0]);arrayTest[1] = &quot;gggg&quot;;Js.log(arrayTest[1]); /* gggg */ 如果要編譯 Javascript Reason 中的 Array 可以直接對應 Javascript 的 Array 雖然在 Reason 中無法直接修改長度，可以利用 Js.Array 來修改 範例如下 123456let array1 = [|0,2,3,4,5,6|];let array2 = Js.Array.copyWithin(~to_=3, array1);Js.log(array1);/* [ 0, 2, 3, 0, 2, 3 ] */Js.log(array2);/* [ 0, 2, 3, 0, 2, 3 ] */let array3 = Js.Array.push(1, array1);Js.log(array3);/* [ 0, 2, 3, 0, 2, 3, 1 ] */ 陣列在一般寫程式過程中扮演相當重要的一個角色 篇幅會太多 明天再來聊聊另一種基本型到 Record 和 Object","tags":["Javascript","IThome2018","Reason"],"categories":["Reason"]},{"title":"Reason-BasicType","path":"/2018/10/03/Reason-BasicType/","content":"Basic Type在每個程式語言中都會有一些基本的型態 Reason 屬於強型態的程式語言 這裡介紹的基本型態的變數型態有 Boolean 數字 字串 字元 TypeType 是 Reason 的亮點之一 let 不一定需要宣告 類型 1let score = 10; Reason 知道 score 是個 int 型別，透過其值 10 判斷出來。這個稱之為 推斷(inference) 變數宣告(Let binding)在介紹變數型態之前要先介紹一下如何宣告變數 Reason 中只有使用 let 來宣告變數 1let a: string = &quot;hello&quot;; 雖然在 Reason 中已經宣告，但是在編譯成功後依舊不會看到這個變數 因為當尚未使用到之前是不會產生在結果中 12let a: string = &quot;hello&quot;;Js.log(a); 但是當我們開始使用之後，編譯結果就會出現 Result: 123456789// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE&#x27;use strict&#x27;;var a = &quot;hello&quot;;console.log(a);exports.a = a;/* Not a pure module */ 另外 Reason 是屬於 Block Scope 12345if (displayGreeting) &#123; let message = &quot;Enjoying the docs so far?&quot;; print_endline(message)&#125;;/*這裡不能呼叫 message*/ 也可以這樣處理 1234567let message = &#123; let part1 = &quot;hello&quot;; let part2 = &quot;world&quot;; part1 ++ &quot; &quot; ++ part2&#125;;Js.log(message); 這樣在外層會無法呼叫 part1, part2 而 message 會等於 part1 ++ &quot; &quot; ++ part2 的字串組合 編譯後的結果會是 1234567&#x27;use strict&#x27;;var message = &quot;hello world&quot;;console.log(message);exports.message = message; 而且預設使用 let 宣告的變數都是 Immutable 12let a: string = &quot;hello&quot;;a = &quot;hello world&quot;; 這邊會得到一個錯誤訊息 123456789101112&gt;&gt;&gt;&gt; Start compiling[1/1] Building src/Demo-HelloWorld.cmj We&#x27;ve found a bug for you! /Users/tomas/Documents/iThome/2018/hello-world/src/Demo.re 2:1-17 1 │ let a: string = &quot;hello&quot;; 2 │ a = &quot;hello world&quot;; The value a is not an instance variable&gt;&gt;&gt;&gt; Finish compiling(exit: 1) 但是可以重複使用 let 宣告同一個變數 1234let message = &quot;hello&quot;;Js.log(message); /* Prints &quot;hello&quot; */let message = &quot;bye&quot;;Js.log(message); /* Prints &quot;bye&quot; */ Type system雖然 Reason 是屬於強型態，但是也有留一些彈性 若你沒有宣告變數型態的時候，他會自動進行型態推導 12345let a = &quot;1&quot;;let b = a ++ &quot;hello&quot;;Js.log(b); /* 1hello */ 但是如果使用數字的運算的話 12345let a = 1;let b = a ++ &quot;hello&quot;;Js.log(b); /* Error: */ 會得到了一個錯誤 訊息會相當清楚地告知是哪一個部分錯誤 對於 debug 會相當有利 Boolean布林值在各個程式語言中佔有相當重要的基本判斷依據 而且在 Javascript 中也是一項令人相當頭痛的變數型態 常常會有很多不小心造成了很多 bug 123let testNum = 1;let isZero: bool = testNum === 0;Js.log(isZero); 有趣的是編譯結果會是 123456789101112// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE&#x27;use strict&#x27;;var isZero = false;console.log(isZero);var testNum = 1;exports.testNum = testNum;exports.isZero = isZero; 他並未依據我的順序來做編譯 而是做了一些優化 因為 isZero 比較的是一個常數 所以不論怎樣執行，最後的結果一定是 false 所以他優先宣告了 var isZero = false; 然後在宣告 testNum 基本的布林運算子 &amp;&amp; - and || - or ! - not &lt;&#x3D;, &gt;&#x3D;, &lt;, &gt; &#x3D;&#x3D; - structural equal &#x3D;&#x3D;&#x3D; - referential equal !&#x3D; - structural not equal !&#x3D;&#x3D; - referential equal 運算子中比較有趣的是 == 和 === 123456789let tuple1 = (1, 2, 3);let tuple2 = (1, 2, 3);let tuple3 = tuple2;Js.log(tuple1 == tuple2); /* true */Js.log(tuple1 == tuple3); /* true */Js.log(tuple1 === tuple2); /* false */Js.log(tuple1 === tuple3); /* false */Js.log(tuple2 === tuple3); /* true */ == 是比較結構是否相等=== 是比較來源是否相同 數字1234567let zero: int = 0;let floatNumber: float = 0.1;Js.log(zero); /* 0 */Js.log(floatNumber); /* 0.1 *//* zero === floatNumber will got Error by compiler*/ int - 整數 float - 浮點數 數字的相加12345let addResult = 1 + 1;Js.log(addresult);/* 2 */let floatAddResult = 1.1 + 1.2; /* get compiler Error (WTF) */Js.log(floatAddResult); Float 的相加要使用另外一個符號 +. 12345let addResult = 1 + 1;Js.log(addresult);/* 2 */let floatAddResult = 1.1 +. 1.2; /* 2.3 */Js.log(floatAddResult); int 與 float 的比大小因為 Reason 是強型別的語言 12let twoBiggerThanOne = 2 &gt; 1;Js.log(twoBiggerThanOne); int 和 float 是不同的型別 無法直接地做比較 所以要先使用 float_of_int 將 int 轉成 float 1float_of_int(2) &gt; 1.2; /* true */ string&quot; 使用雙引號宣告的為字串 &#39; 使用單引號宣告的為字元 字元只能有一個字母 1234567let name: string = &quot;Tomas&quot;;let yourName: string = &quot;哈囉世界!&quot;;let a: char = &#x27;a&#x27;;Js.log(name);Js.log(a);Js.log(yourName); /* \\xe5\\x93\\x88\\xe5\\x9b\\x89\\xe4\\xb8\\x96\\xe7\\x95\\x8c! */ 在編譯的時候要注意的是如果是中文的話預設是 Unicode 在宣告的時候要先進行處理 而使用 j 除了處理 Unicode 也可以用變數 (類似 ES6 Template) 123456789let name: string = &quot;Tomas&quot;;let yourName: string = &#123;js|哈囉世界!|js&#125;;let world = &#123;js|世界|js&#125;;let helloWorld = &#123;j|你好，$world|j&#125;;let a: char = &#x27;a&#x27;;Js.log(name);Js.log(a);Js.log(yourName); /* 哈囉世界! */ BuckleScript 編譯前會先尋找 js 和 j 進行處理 另外字串的相加使用 ++ 123let hello = &quot;Hello&quot;;let world = &quot;World&quot;Js.log(hello ++ &quot; &quot; ++ world); /* console.log(&quot;Hello World&quot;); */ 也可此參考 Reason 的 string API文件","tags":["Javascript","IThome2018","Reason"],"categories":["Reason"]},{"title":"Reason簡介與Helloworld","path":"/2018/10/01/Reason簡介與Helloworld/","content":"What is ReasonReason 並不是一個新的語言，而是一種新的語法和工具鍊(toolchain)，Ocaml支援。並支援既有的 NPM&#x2F;YARN。 藉由 BuckleScript將 Reason 編譯為可閱讀的 Javascript Reason 的優勢 型別系統: Ocaml 型別測試具有 100% 的覆蓋率，而且保有 Javascript 的型別推導，一但編譯過型別保證正確 保有簡單和實用性: 允許 side-effect, mutable 也可以使用 immutable functional 重視效能和大小: Reason 的建置系統 bsb 建置時間小於 100ms(遞增)，產生的結果也會很小 漸進式學習 &amp; 程式碼庫轉換: 也可以在 Reason 中貼上 Javascript 的程式片段再慢慢調整為 Reason 的程式碼 基本使用 immutable and functional 但是也提供 side-effect 和 mutation 的彈性 Reason 的 build system (bsb) 建構精簡可閱讀的 Javascript code 完整的生態圈和工具鍊: 編輯器, NPM 套件, Reason-React, webpack compiler 流程當你完成一個簡單的 .re 檔案 (這是基本的 reason檔案) 會經由下圖的過程幫你編譯成 Javascript Install Reason on Mac12$ npm install -g reason-cli@latest-macos$ npm install -g bs-platform reason-cli - Reason 的環境套件 bs-platform \b- BuckleScript 和 Reason 基本套件 initial First Reason Project1$ bsb -init hello-world -theme basic-reason 第一次初始化之後會得到這樣的檔案結構 12345678.├── README.md├── bsconfig.json├── node_modules│ └── bs-platform -&gt; /usr/local/lib/node_modules/bs-platform├── package.json└── src └── Demo.re bsconfig.jsonBuckleScript 的設定 json 檔案 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;hello-world&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;sources&quot;: &#123; &quot;dir&quot; : &quot;src&quot;, &quot;subdirs&quot; : true &#125;, &quot;package-specs&quot;: &#123; &quot;module&quot;: &quot;commonjs&quot;, &quot;in-source&quot;: true &#125;, &quot;suffix&quot;: &quot;.bs.js&quot;, &quot;bs-dependencies&quot;: [ // add your dependencies here. You&#x27;d usually install them normally through `npm install my-dependency`. If my-dependency has a bsconfig.json too, then everything will work seamlessly. ], &quot;warnings&quot;: &#123; &quot;error&quot; : &quot;+101&quot; &#125;, &quot;namespace&quot;: true, &quot;refmt&quot;: 3&#125; name - 專案名稱 version - 版本 sources dir - source 的資料夾 subdirs - 是否要編譯子資料夾內的 re (Boolean or Array) package-specs module - 編譯後使用哪種 Javascript 模組 (default: commonjs) in-source - 編譯的時候是否也要輸出 suffix - 編譯後的 js 的 後綴 bs-dependencies - 列出你使用 NPM(Yarn) 安裝的第三方 套件 bs-dev-dependencies- 列出你使用 NPM(Yarn) 安裝的第三方 開發套件 namespace - name 是 package 名稱，可以選擇是否開啟命名空間 (default: false) 例如您有一個 Util.re 的檔案，如果沒有開啟命名空間，你的第三方套件也有一個 Util 的套件，他們會造成衝突，，這個參數影響的是這個 lib 的使用者，而不是自己本身 refmt - 當你使用 Reason V3 syntax 則明確指定為 3 reason - 預設是打開的，但是若有使用 ReasonReact, 設定則為 1234&#123; &quot;reason&quot;: &#123;&quot;react-jsx&quot;: 2&#125;, &quot;refmt&quot;: 3&#125; merlin在你的專案中還隱藏了一個小小的檔案 .merlin 這個檔案雖然只有短短幾行 但是扮演相當重要的角色 他會協助你的 格式檢查, autocompleate… 執行您的第一個 Hello world1$ npm run start 然後會開始編譯 12$ node src/Demo.bs.js// Hello, BuckleScript and Reason! Welcom Reason’s World","tags":["Javascript","IThome2018","Reason"],"categories":["Reason"]},{"title":"truffle pet demo","path":"/2018/05/05/Truffle-pet-demo/","content":"設定步驟 設定開發者相關環境變數 建立一個 Truffle 專案 寫一個基本的合約 編譯與部屬你的合約 測試你的合約 建立一個介面來跟你的合約溝通 放到瀏覽器開工囉 後端1. 設定開發者相關環境變數安裝基本環境Nodejs Git Ganache 個人的以太區塊鏈的測試環境 123$ npm install -g truffle$ truffle --version // 檢查是否安裝成功以及版本$ mkdir pet-shop-tutorial &amp;&amp; cd pet-shop-tutorial 2. 建立一個 Truffle 專案Truffle 有提供一些套件協助建立 DAPP Truffle Boxes 我常用 React 開發 Truffle React Box 所以這裡使用 React 作為範例 建立一個 pet-shop 的 basic project 123$ npx truffle unbox react$ npm install -g truffle$ truffle unbox react 1Truffle initial 有很多方式， `truffle init` 會幫你建立一個空的 Truffle 專案 Truffle init 檔案結構12345678910111213141516171819202122232425262728293031323334353637383940 .├── LICENSE├── box-img-lg.png├── box-img-sm.png├── bs-config.json├── build│ └── contracts│ ├── Adoption.json│ └── Migrations.json├── contracts│ ├── Adoption.sol│ └── Migrations.sol├── migrations│ └── 1_initial_migration.js├── package-lock.json├── package.json├── src│ ├── css│ │ ├── bootstrap.min.css│ │ └── bootstrap.min.css.map│ ├── fonts│ │ ├── glyphicons-halflings-regular.eot│ │ ├── glyphicons-halflings-regular.svg│ │ ├── glyphicons-halflings-regular.ttf│ │ ├── glyphicons-halflings-regular.woff│ │ └── glyphicons-halflings-regular.woff2│ ├── images│ │ ├── boxer.jpeg│ │ ├── french-bulldog.jpeg│ │ ├── golden-retriever.jpeg│ │ └── scottish-terrier.jpeg│ ├── index.html│ ├── js│ │ ├── app.js│ │ ├── bootstrap.min.js│ │ ├── truffle-contract.js│ │ └── web3.min.js│ └── pets.json├── test└── truffle-config.js \b* contracts : Solidity 的檔案，在這個範例中有一個 Migrations.sol 的範例檔案 migrations : Truffle 利用 migrations system 來處理開發環境，A migration is an additional special smart contract that keeps track of changes. test : 測試檔案 truffle.js : Truffle 的設定檔案 3. 寫一個基本的合約在 constracts 中建立一個檔案 Adoption.sol Adoption.sol 12345pragma solidity ^0.5.0;contract Adoption &#123;&#125; pragma 定義使用 solidity 編譯器的版本 變數Solidity 有一種特別的變數 adress，這是代表 Ethereum 的位址 儲存了 20 個 byte 得值， 每一個帳號和合約在 Ethereum block chain 都擁有一個 adress 這個變數是 唯一的 在 Adoption.sol 中宣告一個 adress 12345pragma solidity ^0.5.0;contract Adoption &#123; address[16] public adopters;&#125; 宣告一個變數 adopters 這是一個陣列儲存 Ethereum 的 addressArray 內有一種類型，在這裡的長度設定為 16 adopters 設定是 public， public 有 getter method 回傳一個值但是因為在這個範例 adopters 是一個陣列，所以等等會寫一個 function 回傳整個陣列 First Function: Adopting a pet12345678910111213pragma solidity ^0.5.0;contract Adoption &#123; address[16] public adopters; // Adopting a pet function adopt(uint petId) public returns (uint) &#123; require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); adopters[petId] = msg.sender; return petId; &#125;&#125; 在 Solidity 中必須要定義函式的 輸入值和回傳值的型態，在這個範例中會接收一個 petId (整數)也會回傳一個整數 在函式要保證 petId 的範圍值必須在 adopters 陣列 範圍內, Solidity 中的陣列 index 是從 0 開始，所以這個 ID 會在 0~15 之間， 我們利用 require() 來定義這個範圍 如果這個 ID 在允許的範圍內 (0 ~ 15) 之間，則新增這個人的位址到採用者的陣列 adopters 而這個人的位址則是利用 msg.sender 來取得 最後回傳 petId 提供確認 Second Function: Retrieving the adoptersarray getter 只能回傳一個值，但是但是 16 個 API 不是很實際，所以我們需要一個 API 來回傳所有的寵物列表 在 adopt() 後增加一個 getAdopters() 這個 function 123function getAdopters() public view returns (address[16] memory) &#123; return adopters;&#125; adopters已經宣告過了，可以直接回傳，但是要確認加上 memory 這個關鍵字 確認給出的是變量的位置 而 view 這個關鍵字則代表這個 function 部會修改這個合約的任何狀態值，更詳細的資訊可以查看這 memory 表示 adopters 的值存在記憶體裡 1234567891011121314pragma solidity ^0.5.0;contract Adoption &#123; address[16] public adopters; function adopt(uint petId) public returns (uint) &#123; require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); adopters[petId] = msg.sender; return petId; &#125; function getAdopters() public view returns (address[16] memory) &#123; return adopters; &#125;&#125; 在這邊我們將回傳之前宣告的 adopters 定義類型為 address[16] 編譯並部署智能合約Truffle 有一個開發者控制台， 他會生成一個開發區塊鏈，可以利用他測試部署合同 他可以直接在控制台運行，本範例大部分將會使用它完成 編譯Solidity 是一個編譯語言，所以需要一個編譯器先編譯之後才能執行， 1$ truffle compile 這時候應該會看到這些資訊 123Compiling ./contracts/Adoption.sol...Compiling ./contracts/Migrations.sol...Writing artifacts to ./build/contracts 部署資料夾內會看到 migrations/1_initial_migration.js 這個檔案，，他是一個更改 contract 狀態的部屬腳本，會避免未來重複部署同樣的 Migrations.sol 合約 現在我們需要新增一個屬於我們自己的部署 script 在 migrations 資料夾中新增一個檔案 2_deploy_contracts.js 2_deploy_contracts.js 內容 12345const Adoption = artifacts.require(&quot;Adoption&quot;);module.exports = function (deployer)&#123; deployer.deploy(Adoption);&#125; 在部署之前要先執行 Ganache 他會有一個本地的區塊鏈在 port 7575 若您尚未下載 download Ganache 然後回到終端機 1234567891011121314151617181920212223242526272829303132333435363738394041 $ truffle migrateCompiling ./contracts/Adoption.sol...Writing artifacts to ./build/contracts⚠️ Important ⚠️If you&#x27;re using an HDWalletProvider, it must be Web3 1.0 enabled or your migration will hang.Starting migrations...======================&gt; Network name: &#x27;development&#x27;&gt; Network id: 5777&gt; Block gas limit: 67219751_initial_migration.js====================== Deploying &#x27;Migrations&#x27; ---------------------- &gt; transaction hash: 0x9965bb63687936396ef9db5830b9e0a9ff36f10108b775abf944fc86f061454c &gt; Blocks: 0 Seconds: 0 &gt; contract address: 0x3216882738b0ca58BD4a2a3125Fa4bC651100C7e &gt; account: 0x10D045570AD2a69921Dc4e6b55148e071fC7484D &gt; balance: 99.99430184 &gt; gas used: 284908 &gt; gas price: 20 gwei &gt; value sent: 0 ETH &gt; total cost: 0.00569816 ETH &gt; Saving migration to chain. &gt; Saving artifacts ------------------------------------- &gt; Total cost: 0.00569816 ETHSummary=======&gt; Total deployments: 1&gt; Final cost: 0.00569816 ETH 在 \bGanache 中 blockchain\b 的狀態改變了從原本的 0 改變為 4 ，之後會再討論到交易成本 寫好第一個合約並且部署上了區塊鏈，接下來要開始測試一下你的合約 transaction hash 代表這個合約的序號 你可以透過這個序號來搜尋這個合約 回到 Terminal migrate 合約到鍊上 1$ truffle migrate 結果會是 123456789101112131415161718192021222324252627282930313233Starting migrations...======================&gt; Network name: &#x27;development&#x27;&gt; Network id: 5777&gt; Block gas limit: 67219752_deploy_contracts.js===================== Deploying &#x27;Adoption&#x27; -------------------- &gt; transaction hash: 0xac113a702da3ab7a8fde7ec8941143ff854cb8ae3f2457e1cc9251a0fa62a2b8 &gt; Blocks: 0 Seconds: 0 &gt; contract address: 0xAc30aaD46a83f8E8De3f452B0d4C175a1173a54b &gt; account: 0x10D045570AD2a69921Dc4e6b55148e071fC7484D &gt; balance: 99.98838348 &gt; gas used: 253884 &gt; gas price: 20 gwei &gt; value sent: 0 ETH &gt; total cost: 0.00507768 ETH &gt; Saving migration to chain. &gt; Saving artifacts ------------------------------------- &gt; Total cost: 0.00507768 ETHSummary=======&gt; Total deployments: 1&gt; Final cost: 0.00507768 ETH 可以打開 Ganache 之前的數值是 0 現在會變成 4，也可以看到第一個帳號原本是 100但是現在不到 100 (我的顯示是 99.99)，因為這次的 migration 花費了乙太幣，等等會討論到更多關於這個花費的問題 測試智能合約Truffle 如何測試你的合約呢？ 建立一個 TestAdoption.sol 在 test 的資料夾下 內容如下 12345678910111213pragma solidity ^0.5.0;import &quot;truffle/Assert.sol&quot;;import &quot;truffle/DeployedAddresses.sol&quot;;import &quot;../contracts/Adoption.sol&quot;;contract TestAdoption &#123; Adoption adoption = Adoption(DeployedAddresses.Adoption()); uint expectedPetId = 8; address expectedAdopter = address(this);&#125; Assert.sol: 提供 assertions 使用，判斷是否相等，大於小於等等的判斷 DeployedAddresses.sol: 側是的時後 Truffle 會在鍊上部署一個新的實例，會取得那一個的位址來使用模擬 Adoption.sol: 要測試的智能合約內容 然後再定義其他的變數 DeployedAddresses 模擬部署一個智能合約取得他的位址 expectedPetId 提供測試的寵物 ID 因為預計 TestAdoption 合約會發送交易，預期的 sneder 位址設為此，取得現在合約的 address 測試 adopt() 函式測試 adopt() 使用這個函式成功後回傳 petId 可以判斷這個 petId 的直是否正確 在 TestAdoption.sol 中的 Adoption 中增加下面的程式碼 12345function testUserCanAdoptPet() public &#123; uint returnedId = adoption.adopt(expectedPetId); Assert.equal(returnedId, expectedPetId, &quot;Adoption of the expected pet should match what is returned.&quot;);&#125; expectedPetId 是我們要認養的 寵物 ID 跟回傳的 returnedId是否相等 測試單個寵物主人的主人public 變數會有一個 getter 的 function 來取得，測試的過程中數據會持續存在 所以可以沿用 expectedPetId 在其他測試中 增加一個 function 在 TestAdoption.sol 中 12345function testGetAdopterAddressByPetId() public &#123; address adopter = adoption.adopters(expectedPetId); Assert.equal(adopter, expectedAdopter, &quot;Owner of the expected pet should be this contract&quot;);&#125; 取得 adopter 的位址 存在合約中，利用 Assert 判斷是否一致 測試所有寵物主人12345function testGetAdopterAddressByPetIdInArray() public &#123; address[16] memory adopters = adoption.getAdopters(); Assert.equal(adopters[expectedPetId], expectedAdopter, &quot;Owner of the expected pet should be this contract&quot;);&#125; 注意 adopters 屬性，因為有 memory 關鍵字代表存在記憶體中，不是存在合約的 storage 中，當 adopters 在一個陣列中，比較了陣列中的 expectedAdopter做比較 Running test123456789101112$ truffle testUsing network &#x27;development&#x27;.Compiling ./contracts/Adoption.sol...Compiling ./test/TestAdoption.sol...Compiling truffle/Assert.sol...Compiling truffle/DeployedAddresses.sol...TestAdoption ✓ testUserCanAdoptPet (75ms) ✓ testGetAdopterAddressByPetId (64ms) ✓ testGetAdopterAdderssByPetIdInArray (138ms) 參考資料Tutorial","tags":["Truffle","Sodility"],"categories":["Block Chain"]},{"title":"Javascript-High Order Function","path":"/2018/02/02/Javascript-HighOrderFunction/","content":"High Order Function是一種 接受 Funciton 回傳 Function 的 Function Map, Filter, Reduce 都是 Function 回傳一個 Function範例一 123456789//基本款const sum = x =&gt; &#123; return y =&gt; &#123; return x + y; &#125;;&#125;;//簡潔款const sum2 = x =&gt; y =&gt; x + y; applyTwice 就是一個 High Order Function123const applyTwice = func =&gt; (...args) =&gt; func(func.apply(null, args));console.log(applyTwice(x =&gt; &quot;yo!&quot; + x)(&quot;world&quot;)); 在 func 中回傳兩次呼叫的自己， 所以會收到 yo!yo!world Map實作 Map 先來看看 Array.prototype.Map 是如何使用的 123const array = [1, 2, 3, 4];array.map(item =&gt; console.log(item)); // 1,2,3,4console.log(array.map(item =&gt; item + 1)); //[2,3,4,5] 不希望使用到 prototype 實作的時候會偏向 lodash 的 Map 1234import _ from &quot;lodash&quot;;const array = [1, 2, 3, 4];_.map(array, item =&gt; console.log(item)); //1,2,3,4console.log(_.map(array, item =&gt; item + 1)); //[2,3,4,5] 真正來實作 12345678910111213const map = (array, callback) =&gt; &#123; if (array.length == 0) &#123; return []; &#125; else &#123; const x = array.pop(); map(array, callback) || []; callback(x); &#125;&#125;;const arr = [1, 2, 3, 4];map(array, item =&gt; console.log(item)); //1,2,3,4console.log(map(array, item =&gt; item + 1)); //[] 似乎需要回傳一些東西 12345678910111213const map = (array, callback) =&gt; &#123; if (array.length == 0) &#123; return []; &#125; else &#123; const x = array.pop(); const result = map(array, callback) || []; result.push(callback(x)); return result; &#125;&#125;;const arr = [1, 2, 3, 4];map(array, item =&gt; console.log(item)); //1,2,3,4console.log(map(array, item =&gt; item + 1)); //[1,2,3,4] FilterFilter 的使用範例 123const array = [1, 2, 3, 4, 5];console.log(array.filter(x =&gt; x &gt; 2)); // [3,4,5]console.log(array.filter(x =&gt; x &gt; 4)); // [ 5 ] 針對 Filter 的實作 1234567891011const array = [1, 2, 3, 4, 5];const filter = func =&gt; array =&gt; &#123; if (array.length === 0) &#123; return []; &#125; else &#123; const [x, ...xs] = array; const filterResult = func(x) ? [x] : []; return [...filterResult, ...filter(func)(xs)]; &#125;&#125;;console.log(filter(x =&gt; x &gt; 2)(array)); ZipZip 就是將兩個陣列合成一個二維陣列大小以較小的陣列為基準 輸出結果 12zip([1, 2, 3])([0, 0, 0]) = [[1, 0], [2, 0], [3, 0]]zip([1, 2, 3, 4, 5])([87]) = [[1, 87]] 123456789101112const zip = array1 =&gt; array2 =&gt; &#123; if (array1.length === 0 || array2.lenght === 0) &#123; return []; &#125; else &#123; const [x1, ...xs1] = array1; const [y1, ...ys1] = array2; const result = zip(xs1)(ys1); return [...result, [x1, y1]]; &#125;&#125;;console.log(zip([1, 2, 3])([0, 0, 0])); Quick Sort1234567891011121314const quickSort = array =&gt; &#123; if (array.length &lt; 2) &#123; return array; &#125; else &#123; const [basic, ...xs] = array; const left = xs.filter(item =&gt; item &lt; basic); const right = xs.filter(item =&gt; item &gt;= basic); return [...quickSort(left), basic, ...quickSort(right)]; &#125;&#125;;const array = [77, 1, 2, 5, 3, 2, 33, 34, 44, 66, 22];console.log(quickSort(array)); //[ 1, 2, 2, 3, 5, 22, 33, 34, 44, 66, 77 ] Reduce參數Reduce 又稱為 Fold Reduce 就與 Map 跟 Filter 不同了 Redcue 須傳入 function 與 初始值 且 Reduce 是依序接到四個變數︰ accumulator 累積值 element 當前元素 index - index array 正在執行 reduce 的陣列 Reduce 的遞迴實作 12345678910const reduce = func =&gt; acc =&gt; array =&gt; &#123; if (array.length == 0) &#123; return acc; &#125; else &#123; const [x, ...xs] = array; return reduce(func)(func(acc, x))(xs); &#125;&#125;;const reverse = reduce((acc, el) =&gt; [el, ...acc])([])([1, 2, 3]);console.log(reverse); functional 12345678910const reduce = func =&gt; acc =&gt; array =&gt; &#123; if (array.length == 0) &#123; return acc; &#125; else &#123; const [x, ...xs] = array; return reduce(func)(func(acc, x))(xs); &#125;&#125;;const reverse = reduce((acc, el) =&gt; [el, ...acc])([])([1, 2, 3]);console.log(reverse); 參考資料關於 JS 中的淺拷貝和深拷貝","tags":["Javascript","FunctionPrograming"],"categories":["Javascript"]},{"title":"Map","path":"/2018/02/02/Redux-compose/","content":"Redux 中的 compose 的 source codecompose 12345678910111213141516171819202122/** * Composes single-argument functions from right to left. The rightmost * function can take multiple arguments as it provides the signature for * the resulting composite function. * * @param &#123;...Function&#125; funcs The functions to compose. * @returns &#123;Function&#125; A function obtained by composing the argument functions * from right to left. For example, compose(f, g, h) is identical to doing * (...args) =&gt; f(g(h(...args))). */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 若是沒有參數的話就回傳一個預設的函式 若是只有一個則直接回傳 function 聊到 reduce 前 可以先談談 遞回","categories":["Javascript, React"]},{"title":"React Native import Image Error","path":"/2018/01/05/RN-JestErrorWithRNRouterFlux/","content":"\bReact Native version: 0.51.0 React version: 16.0.0 Initial React Native Project123$ react-native init myapp$ cd myapp$ jest 安裝 react-native-router-flux 和 styled-components 1$ npm install styled-components react-native-router-flux 建立資料夾 和 檔案 12$ mkdir -p src ./src/components\b$ cd src/components &amp;&amp; touch Home.js Counter.js &amp;&amp; cd - .&#x2F;src&#x2F;components&#x2F;Home.js 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from &quot;react&quot;;import styled from &quot;styled-components/native&quot;;import &#123; Text, View &#125; from &quot;react-native&quot;;import &#123; Actions &#125; from &quot;react-native-router-flux&quot;;const Container = styled.View` width: 100%; height: 100%; flex: 1; flex-direction: row; justify-content: center; align-items: center;`;const ContentText = styled.Text` font-size: 20; font-weight: 400;`;export default class Counter extends Component &#123; render() &#123; return ( &lt;Container&gt; &lt;ContentText&gt; &lt;Text onPress=&#123;Actions.counter&#125;&gt;Navigator to Counter&lt;/Text&gt; &lt;/ContentText&gt; &lt;/Container&gt; ); &#125;&#125; .&#x2F;src&#x2F;components&#x2F;Counter.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React, &#123; Component &#125; from &quot;react&quot;;import styled from &quot;styled-components/native&quot;;import &#123; Text, View, Button &#125; from &quot;react-native&quot;;import &#123; Actions &#125; from &quot;react-native-router-flux&quot;;const Container = styled.View` width: 100%; height: 100%; flex: 1; flex-direction: row; justify-content: center; align-items: center;`;const Row = styled.View` flex: 1; flex-direction: column; justify-content: center; align-items: center;`;const ContentText = styled.Text` font-size: 20; font-weight: 400;`;const CounterText = styled.Text` font-size: 16; font-weight: 400;`;export default class Counter extends Component &#123; state = &#123; count: 0 &#125;; render() &#123; return ( &lt;Container&gt; &lt;Row&gt; &lt;ContentText&gt;Counter&lt;/ContentText&gt; &lt;CounterText&gt;&#123;this.state.count&#125;&lt;/CounterText&gt; &lt;Button onPress=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125; title=&quot;+&quot; /&gt; &lt;Button onPress=&#123;() =&gt; this.setState(&#123; count: this.state.count - 1 &#125;)&#125; title=&quot;-&quot; /&gt; &lt;ContentText onPress=&#123;Actions.pop&#125;&gt;Back&lt;/ContentText&gt; &lt;/Row&gt; &lt;/Container&gt; ); &#125;&#125; .&#x2F;App.js 1234567891011121314151617import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Router, Scene &#125; from &quot;react-native-router-flux&quot;;import Home from &quot;./src/components/Home&quot;;import Counter from &quot;./src/components/Counter&quot;;export default class App extends Component&lt;&#123;&#125;&gt; &#123; render() &#123; return ( &lt;Router&gt; &lt;Scene key=&quot;root&quot;&gt; &lt;Scene path=&quot;home&quot; key=&quot;home&quot; component=&#123;Home&#125; /&gt; &lt;Scene path=&quot;counter&quot; key=&quot;counter&quot; component=&#123;Counter&#125; /&gt; &lt;/Scene&gt; &lt;/Router&gt; ); &#125;&#125; 12$ npm run run-ios //ok$ npm run test // Error import type { ^^^^^^ SyntaxError: Unexpected token import \b在package.json 中增加 transform package.json 123456789&#123; ...&quot;jest&quot;: &#123; &quot;preset&quot;: &quot;react-native&quot;, &quot;transform&quot;: &#123; &quot;^.+\\\\.jsx?$&quot;: &quot;babel-jest&quot; &#125; &#125;&#125; 在重新執行測試的時候會產生另一個錯誤\b ({\"Object.\":function(module,exports,require,__dirname,__filename,global,jest){�PNG ... 因為這是在 react-native-router-flux 中的 Navbar 中的 png 在編譯的時候產生的錯誤 解法 1$ npm install --save-dev identity-obj-proxy package.json 123456789101112131415&#123; ... &quot;jest&quot;: &#123; &quot;preset&quot;: &quot;react-native&quot;, &quot;transform&quot;: &#123; &quot;^.+\\\\.jsx?$&quot;: &quot;babel-jest&quot; &#125;, &quot;transformIgnorePatterns&quot;: [ &quot;!node_modules/react-runtime&quot; ], &quot;moduleNameMapper&quot;: &#123; &quot;.+\\\\.(png|jpg|ttf|woff|woff2)$&quot;: &quot;identity-obj-proxy&quot; &#125; &#125;&#125;","tags":["Javascript","React Native","React"],"categories":["React Native"]},{"title":"Typescript-JSX","path":"/2017/11/07/Typescript-JSX/","content":"JSXJSX 是一種類似 XML 的標記性語言，可以被轉換為合法的 Javascript 因為 React 的框架而開始流行，但是也可以，但是也可以使用在其他程式中 基本使用方式在 TypeScript 使用 JSX 必須先做兩件事情 副檔名為 tsx 開啟 jsx 的功能 TypeScript 有三種 JSX 的模式， preserve, react, react-native preserve會保留 JSX 提供後續轉換使用 react會生成 React.createElement 在使用前不需要再轉換 react-native相當於 preserve 但是輸出的檔案副檔名為 .js 可以在命令列中使用 --jsx 或是在 tsconfig.json 中指定模式 as Oprator寫一個 class 1const foo = &lt;foo&gt;bar; 因為 JSX 語法解析困難，所以在 TypeScript 禁止使用 &lt;&gt; 來宣告，所以在 tsx 中改為 1const foo = bar as foo; as 在 .ts 或是 .tsx 中都可以使用 Type Check為了理解 JSX 如何檢查類型必須要先了解原生的元件根基於值得元件有什麼不同 假如有一個元件 &lt;expr /&gt; 可能會引用 div 或是 span 這類的標籤 React HTML 標籤會自動生成 React.createElement(&#39;div&#39;) 但是自定義的元件部會生成 React.createElement(MyComponent) 原本 HTML 就有的 tag 本身支援類型檢查，但是自定義的元件則需要自己定義類型檢查 TypeScript 使用和 React 相同的規範來做區別 Intrinsic elementsIntrinsic elements 預設是 JSX.IntrinsicElements 做類型檢查，預設是 any 12345678decalre namespace JSX &#123; interface IntrinsicElements &#123; foo: any &#125;&#125;&lt;foo /&gt; // Success&lt;bar /&gt; // Error 上面範例中 foo 可以執行，但是 bar 會報錯誤訊息，因為 bar 並沒有在 JSX.IntrinsicElements 內指定 也可以指定為所有 12345declare namespace JSX &#123; interface IntrinsicElements &#123; [elemName: string]: any; &#125;&#125; 一般使用 Component 如範例 123import MyComponent from &#x27;./MyComponent&#x27;;&lt;MyComponent /&gt; // Success&lt;OtherComponent /&gt; // Error Stateless Component (SFC)範例 1234567891011interface FooProp&#123; name: string, X: number, Y: number&#125;declare function AnotherComponent(prop: &#123;name: string&#125;);function ComponentFoo(prop: FooProp) &#123; return &lt;AnotherComponent name=prop.name /&gt;;&#125;const Button = (prop: &#123;value: string&#125;, context: &#123; color: string &#125;) =&gt; &lt;button&gt; 因為 SFC 是簡單的 Function 所以可以盡量的使用 Class Component這裡需要先介紹兩個新的名詞 the element class type 和 element instance type 範例 123456789101112131415161718192021class MyComponent &#123; render() &#123;&#125;&#125;// use a construct signaturevar myComponent = new MyComponent();// element class type =&gt; MyComponent// element instance type =&gt; &#123; render: () =&gt; void &#125;function MyFactoryFunction() &#123; return &#123; render: () =&gt; &#123;&#125; &#125;;&#125;// use a call signaturevar myComponent = MyFactoryFunction();// element class type =&gt; FactoryFunction// element instance type =&gt; &#123; render: () =&gt; void &#125; element instance type 很有趣，他必須要指定給 JSX.ElementClass 否則就會報錯 預設 JSX.ElementClass 是 &#123;&#125; 1234567891011121314151617181920212223declare namespace JSX &#123; interface ElementClass &#123; render: any; &#125;&#125;class MyComponent &#123; render() &#123;&#125;&#125;function MyFactoryFunction02() &#123; return &#123; render: () =&gt; &#123;&#125; &#125;;&#125;&lt;MyComponent /&gt;; // ok&lt;MyFactoryFunction /&gt;; // okclass NotAValidComponent &#123;&#125;function NotAValidFactoryFunction() &#123; return &#123;&#125;;&#125;// &lt;NotAValidComponent /&gt;; // error// &lt;NotAValidFactoryFunction /&gt;; // error","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"TypeScript-Generic","path":"/2017/11/06/TypeScript-Generic/","content":"泛型泛型的 Hello world123function identity(arg: number): number &#123; return arg;&#125; 或是我們用 any 來宣告型態 123function identity(arg: any): any &#123; return arg;&#125; 使用 any 導致這個函式可以接受任何類型的 arg 參數，但是這樣會錯失一些訊息 我們需要一種方式讓 input 和 output 類型是一樣的 123function identity&lt;T&gt;(arg: T): T&#123; return arg;&#125; 藉由前面輸入的 T 協助接到 input 也希望和 response 是相同的，是相同的 12345function identity&lt;T&gt;(arg: T): T&#123; return arg;&#125;let output = identity&lt;string&gt;(&quot;Mystring&quot;); 使用泛型變量若是我們希望取回 arg 的長度但是並沒有指明 arg 具有 .length 這個屬性，因為這個變量是任意類型，所以傳入的可能是字串或數字 那就沒有 length 這個屬性，我們可以先宣告陣列 1234function loggingIdentity&lt;T&gt;(arg: T[]): T[]&#123; console.log(arg.length); return arg;&#125; 現在 loggingIdentity 的輸入直是包含了 T 屬性的陣列，回傳的也是包含了 T 的陣列 也可以改寫成為 1234function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125; 泛型 class在函式忠宣告泛型的方式如下 12345function identity&lt;T&gt;(arg: T): T&#123; return arg;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity; 也可以使用不同的名稱宣告，只要變數的數量吻合就可以了 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity; 也可以利用 signature 物件的方式來做宣告 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity; 上述範例可以利用 interface 來做宣告 12345678interface GenericIdentityFn&#123; &lt;T&gt;(arg: &lt;T&gt;): T;&#125;function identity&lt;T&gt;(arg: T): T&#123; return arg;&#125;let myIdentity: GenericIdentityFn = identity; 藉由上述範例使用泛型來做宣告的話，就可以把這個參數的型態作為函式的輸入值 例如: Dictionary而不是單純的 Dictionary 123456789interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 泛型類別泛型類別和泛型宣告方式是一樣的，利用 &lt;&gt; 在 class 後面 12345678class GenericNumber&lt;T&gt;&#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;et myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; GenericNumber 很片面的 class，沒什麼去限制他使用 number 你可以使用字串或其他更複雜的物件 12345let stringNumeric = new GenericNumber&lt;string&gt;();stringNumeric.zeroValue = &quot;&quot;;stringNumeric.add = function(x, y) &#123; return x + y; &#125;;alert(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;)); 就像 interface 一樣，泛型類別只是確認你使用的是同一個型態，而什麼型態則不是他們限制的 在之前 類別中有提到，類別有分兩個部分 靜態與實例層，泛型類別只負責實例層 靜態層不能使用 泛型類別 Generic Constraints之前有一個簡單的範例，如果我們傳入的類別沒有 length 這個屬性就會報錯 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // Error: T doesn&#x27;t have .length return arg;&#125; 我們不希望使用 any 來做檢查，因為這樣會沒有任何錯誤訊息，希望在傳入的屬性中一定要有一個 length 為了達到這個目的，我們宣告一個 interface 裡面有 length 的屬性，然後繼承他的屬性 1234567891011interface Lengthwise&#123; length: number;&#125;function logginIdentity&lt;T extends Lengthwise&gt;(arg: T): T&#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125;// loggingIdentity(3); // Error, number doesn&#x27;t have a .length propertyloggingIdentity(&#123;length: 10, value: 3&#125;); 這時候他就不是 any 參數，而是必須擁有 length 這個屬性","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"Typescript-Function","path":"/2017/11/05/Typescript-Function/","content":"FunctionsFunction 在 Javascript 中是很基本的型態，可以用在隱藏資訊，或攥寫模組等功用 Javascript 中基本的 Function 有兩種 12345function add(x, y)&#123; return x+y;&#125;let myAdd = function(x, y)&#123;return x+y;&#125; 在 Javascript 中的 Function 可以使用外部的變數，這個行為叫做 capture 1234let z = 100;function addToZ(x, y)&#123; return x + y + z;&#125; 使用 TypeScript 寫一個最基本的範例 12345function add (x: number, y: number): number&#123; return x + y;&#125;let myAdd = function(x: number, y: number): number&#123;return x+y;&#125;; 完整的 Function Type 範例 123let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number&#123; return x+y;&#125; 上述範例中輸入的參數可以定義類別，同時也宣告 Function 回傳的類別，並且有兩個相同的宣告類別， 但是做事在一開始就宣告完整的 Function 類別，那之後就可以省略 範例 12345let myAdd = function(x: number, y: number): number&#123; return x + y;&#125;;let myAdd2: (x: number, y: number) =&gt; number = function(x, y)&#123;return x + y;&#125;; Optional and Default Parameters在 TypeScript 中指定每個參數不代表他們不能是 null 或是 undefined 1234567function buildName(firstName: string, lastName: string)&#123; return firstName + &#x27; &#x27; + lastName;&#125;// let result1 = buildName(&quot;Bob&quot;); // error, too few parameters// let result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // ah, just right 在 Javascript 中每一個 Function 都是非必要的，當你沒有輸入的時候值都會是 undefined 在 TypeScript 有宣告的都是必要的，但是也提供一個 ? 來宣告非必要 12345678910function buildName(firstName: string, lastName?: string)&#123; if (lastName)&#123; return firstName + &quot; &quot; + lastName; &#125;else&#123; return firstName; &#125;&#125;let result1 = buildName(&quot;Bob&quot;); // works correctly now// let result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // ah, just right TypeScript 非必要參數必須要在 必要參數的後面， TypeScript 也可以提供預設值的設定 範例 12345678function buildName(firstName: string, lastName = &quot;Smith&quot;) &#123; return firstName + &quot; &quot; + lastName;&#125;let res1 = buildName(&quot;Bob&quot;); // works correctly now, returns &quot;Bob Smith&quot;let res2 = buildName(&quot;Bob&quot;, undefined); // still works, also returns &quot;Bob Smith&quot;// let res3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet res4 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // ah, just right 上面的範例中可以看到，你可以先預設值給予預設值之後就不是必要參數，因為當你沒有輸入該參數的時候也會有預設輸入不會影響程式執行 Rest Parameters在 ES6 也有一種特性 Rest 而這個特性在 TypeScript 也可以應用在 Function 之中，當你不知道之後輸入的參數值總共有幾個，可以利用這個特性將所有後面輸入的參數值組合成一個陣列 1234567function buildName4(firstName: string, ...restOfName: string[]) &#123; console.log(`firstName: $&#123;firstName&#125;`); console.log(`restOfName: $&#123;restOfName&#125;`); return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;let employeeName = buildName4(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;); this1234567891011121314151617let deck = &#123; suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), createCardPicker: function() &#123; return function() &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit); 上述範例是可以編譯的，但是在執行的時候會有錯誤 因為在執行照 createCadrPicker 的時候會找不到 suits 這個 Function 因為這是 this的作用域的問題 因為對 Javascript 來說 Function 也是物件，所以在上述範例中的 createCadrPicker 中的 this 是指這個 createCadrPicker Function 本身，但是這個 Function 並沒有 suits 這個屬性，所以他會找到 undefeind 在後面 this.suits[pickedSuit] 的時候因為 undefined 在 Javascript 並不是物件，所以就會造成這個錯誤 所以我們可以把這個範例做一些修改 123456789101112131415161718let deck = &#123; suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), createCardPicker: function() &#123; // NOTE: the line below is now an arrow function, allowing us to capture &#x27;this&#x27; right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit); 其實我們做的修改只是將 function()&#123;&#125; 修改為 () =&gt; &#123;&#125; 但是因為在 Javascript 中的 arrow function的特性 所以他找到的 this 是指 desk 這個物件，就可以指導 suits 這個屬性這個屬性 this parameters但是在上面範例中的 this 的型別依舊是 any 如果我們希望在 Function 定義 this 的型態就要將這個宣告放在 Function 的第一個參數 123function f(this: void)&#123; // ....&#125; 加上兩個 interface， Card 和 Deck 12345678910111213141516171819202122interface Card&#123; suit: string; card: number&#125;interface Deck&#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), createCardPicker: function(this: Deck)&#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125; 在 interface 中的 createCardPicker 有宣告了 this 的型態是 Deck 而不是 any 所以 --noImplicitThis 不會有錯誤 this parameters in callbacks你在 callback 中使用 this 的話依舊會產生一些錯誤，因為 this 會是 undefine 你可以宣告一個 interface 來避免這種錯誤 123interface UIElement&#123; addClickListener(onClick: (this: void, e: Event =&gt; void): void)&#125; this: void 代表 addClickListener 預計 onClick 是一個 Fucntion 並沒有 this 的類別 123456789class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used this here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! OverloadsJavascript 是一個動態繼承的程式語言，一個函式藉由輸入值得到不同的回傳值是十分常見的 1234567891011121314151617181920212223let suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];function pickCard(x): any &#123; if (typeof x == &quot;object&quot;) &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; else if (typeof x == &quot;number&quot;) &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [ &#123; suit: &quot;diamonds&quot;, card: 2 &#125;, &#123; suit: &quot;spades&quot;, card: 10 &#125;, &#123; suit: &quot;hearts&quot;, card: 4 &#125;];let pickedCard01 = myDeck[pickCard(myDeck)];console.log(&quot;card: &quot; + pickedCard01.card + &quot; of &quot; + pickedCard01.suit);console.log(`pickedCard01: $&#123;JSON.stringify(pickedCard01)&#125;`);let pickedCard02 = pickCard(15);console.log(&quot;card: &quot; + pickedCard02.card + &quot; of &quot; + pickedCard02.suit);console.log(`pickedCard02: $&#123;JSON.stringify(pickedCard02)&#125;`); pickCard 會依據我們傳進去的參數不同，回傳不同的資訊這樣的話我們該如何去定義呢？ 123456789101112131415161718192021222324let suits02 = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];function pickCard1(x: &#123; suit: string; card: number &#125;[]): number;function pickCard1(x: number): &#123; suit: string; card: number &#125;;function pickCard1(x): any &#123; if (typeof x == &quot;object&quot;) &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; else if (typeof x == &quot;number&quot;) &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits02[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck02 = [ &#123; suit: &quot;diamonds&quot;, card: 2 &#125;, &#123; suit: &quot;spades&quot;, card: 10 &#125;, &#123; suit: &quot;hearts&quot;, card: 4 &#125;];let pickedCard001 = myDeck02[pickCard1(myDeck02)];console.log(&quot;card: &quot; + pickedCard001.card + &quot; of &quot; + pickedCard001.suit);let pickedCard002 = pickCard1(15);console.log(&quot;card: &quot; + pickedCard002.card + &quot; of &quot; + pickedCard002.suit); 為了要讓 TypeScript 編譯的時候能夠選擇正確的型態，會宣告兩個不同的 PickCard1 然後分別宣告不同的 parmeter 而產生的不同的 response，然後在最後真正宣告 function pickCard1():any 設定回傳值是 any，之後再真正使用 pickCard1 的時候就會依據不同的 parmeter 檢查不同的形態和 response","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"Typescript-Classes","path":"/2017/11/04/Typescript-Classes/","content":"Classes傳統的 Javascript 使用 function 加上 protyotype-based 來繼承建立元件，但是這樣的機制對程式開發者習慣 Object-oriented 的感覺很尷尬， ECMAScript 2015 與 ECMAScript6 中允許開發者使用 object-oriented class-based approach Basic Classes最基本的 class-based 範例 1234567891011class Greeter&#123; greeting: string; constructor(messaage: string)&#123; this.greeting = message; &#125; greet()&#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;let greeter = new Greeter(&quot;world&quot;); 這樣的程式對 C# 或是 Java 的開發者應該會比較親切， 宣告了一個新的 class Greeter，這個 class 中有一個屬性是 greeting constructor 和 greet 看到有一個關鍵字 this. 之後可以呼叫這個 class 的屬性 繼承在 TypeScript 中可以直接使用 object-oriented patterns，當然也可以建立一個 class 做繼承的動作， 範例 1234567891011121314151617181920212223242526272829303132333435class Animnal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;`); &#125;&#125;class Snake extends Animnal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(&quot;Slithering...&quot;); super.move(distanceInMeters); &#125;&#125;class Horse extends Animnal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(&quot;Galloping...&quot;); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(&quot;Sammy the Python&quot;);let tom: Animnal = new Horse(&quot;Tommy the Palomino&quot;);sam.move();tom.move(34); 上述範例中以 extends 這個關鍵字來建立一個子類， Horse 和 Snake 是繼承在 class Animal 之下的子類 在子類中的 constructor 必須使用 super() 這將會執行父類的 constructor 這個範例也示範了如何覆寫父類的 Function 在 Snake 和 Horse 都有建立一個 move 的 Function 來覆寫過 Animal 的 move 執行結果後如下 1234Slithering...Sammy the Python moved 5m.Galloping...Tommy the Palomino moved 34m. Public, private 和 protected modifierspublic by default在我們的範例中可以自由地宣告屬性，但在其他語言(C#) 需要使用 public 這個關鍵字來規範屬性是不是可以被瀏覽 但是在 TypeScript 中 public 是預設值 但是你也可以使用 public 來宣告屬性 123456789class Animal&#123; public name: string; public constructor(theName: string)&#123; this.name = theName; &#125; public move(distanceInMeters: number)&#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125; 了解 private當某個屬性使用 private 來宣告，他不能來宣告，他不能被直接呼叫 123456class Animal&#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(&quot;Cat&quot;).name; // Error: &#x27;name&#x27; is private TypeScript 是一個結構型態系統，我們比較兩種不同的類別，不論他們是如何產生的 只要他們的所有屬性沒有衝突，我們就可以稱這兩個類別是相容的 123456789101112131415161718192021class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super(&quot;Rhino&quot;); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal(&quot;Goat&quot;);let rhino = new Rhino();let employee = new Employee(&quot;Bob&quot;);animal = rhino;animal = employee; // Error: &#x27;Animal&#x27; and &#x27;Employee&#x27; are not compatible 然而當兩個類別在比較的時候如果擁有 private 和 protected 屬性, 除非他們所這個 private 和 protected 繼承的是同一個父類別才會是兼容的，否則在形態上兩個都會是不同的 1234567891011121314151617181920212223242526class Animal&#123; private name: string; constructor(theName: string)&#123; thie.name = theName; &#125;&#125;class Rhino extends Animal&#123; constructor()&#123; super(&quot;Rhino&quot;); &#125;&#125;class Employee&#123; private name: string; constructor(theName: string)&#123; this.name = theName; &#125;&#125;let animal = new Animal(&quot;Goat&quot;);let rhino = new Rhino();let employee = Employee(&quot;Bob&quot;);animal = rhino;animal = employee; // Error: &#x27;Animal&#x27; and &#x27;Employee&#x27; are not compatible 在這個範例中我們有 Animal 和 Rhino 兩個 class， Rhino 是 Animal 的子類別 另外也有一個 Employee 他看起來和 Animal 十分相似，都有一個 private name: string 因為 Rhino 是繼承 Animal 所以 Animal 實體化後可以 assign 給 Rhino 的實體並不衝突 代表他們是相容的，而 Employee 即使有一樣的 private name: string 但是卻無法相容， 因為他們並不是在同一個父類的類別 了解 protectedprotected 和 private 很相似，只是當你宣告為 protected 12345678910111213141516171819202122class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);console.log(howard.getElevatorPitch());// console.log(howard.name); // error 我們沒辦法直接呼叫 name 但是可以透過 Employee instance method 來使用，因為 Employee 繼承自 Person 我們也可以將 constructor 宣告為 protected 這代表這個 class 只能用來繼承，而無法直接產生 instance 1234567891011121314151617181920212223class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee can extend Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);//let john = new Person(&quot;John&quot;); // Error: The &#x27;Person&#x27; constructor is protected Readonly modifier你可以宣告某些參數或變數是 readonly 使用 readonly 這個關鍵字來宣告，但是必須在初始化或是在 constructor 的時候進行宣告 12345678910class Octopus&#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(theName: string)&#123; this.name = theName; &#125;&#125;let dad = new Octopus(&#x27;Man with the 8 strong legs&#x27;);//dad.name = &quot;Man with the 3-piece suit&quot;; // error! name is readonly. AccessorsTypeScript 支援 getters&#x2F;setters 去對 Object 中的屬性進行取值或是修改 123456789class Employee&#123; fulllName: string;&#125;let employee = new Employee();employee.fullName = &#x27;Bob Smith&#x27;;if(employee.fullName)&#123; console.log(employee.fullName);&#125; 我們希望使用者是有足夠的安全性，所以使用 private 宣告 fullName 然後允許使用 set 來對 fullName 來做修改 12345678910111213141516171819202122let passcode = &#x27;secret passcode&#x27;;class Employee&#123; private _fulllName: string; get fullName(): string&#123; return this._fullName; &#125; set fullName(newName: string)&#123; if(passcode &amp;&amp; passcode === &#x27;secret passcode&#x27;)&#123; this._fulllName = newName; &#125;else&#123; console.log(&quot;Error: Unauthorized update of employee!&quot;); &#125; &#125;&#125;let employee = new Employee();employee.fullName = &quot;Bob Smith&quot;;if (employee.fullName) &#123; console.log(employee.fullName);&#125; command line 1$ tsc -t ES5 ./Accessors.ts 有兩點需要注意 因為必須要指定 ECMAScript 5 以上才可以使用 Accessors 如果你只有設定 get 而沒有設定 set 代表這個屬性是 readonly Static Properties在這個部分我們討論的是實體的屬性，也是靜態屬性，實體的屬性，也是靜態屬性，這個屬性只能在 class 中取得，而無法被繼承 123456789101112131415class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;; calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123; let xDist = point.x - Grid.origin.x; let yDist = point.y - Grid.origin.y; return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor(public scale: number) &#123;&#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;)); 抽象類別抽象類別就像之前的類別一樣，也許不需要實體化，使用 abstract 關鍵字來宣告抽象類別與抽象函式 123456abstract class Animal&#123; abstract makeSound(): void; move(): void&#123; console.log(&quot;roaming the earth..&quot;); &#125;&#125; abstract 中的函式並不會並不會包含在實體，也一定會使用 abstract 關鍵字來做宣告定義 123456789101112131415161718192021222324252627282930abstract class Department&#123; constructor(public name: string)&#123; &#125; printName():void&#123; console.log(&quot;Department name: &quot; + this.name); &#125; abstract printMeeting():void;&#125;class AccountingDepartment extends Department&#123; constructor()&#123; super(&quot;Accounting and Auditing&quot;); &#125; printMeeting():void&#123; console.log(&quot;The Accounting Department meets each Monday at 10am.&quot;); &#125; generateReports():void&#123; console.log(&quot;Generating accounting reports...&quot;); &#125;&#125;let department: Department; // ok to create a reference to an abstract type// department = new Department(); // error: cannot create an instance of an abstract classdepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclassdepartment.printName();department.printMeeting();// department.generateReports(); // error: method doesn&#x27;t exist on declared abstract type 抽象類別無法直接使用 new 產生物件，若是在抽象類別中並沒有宣告的類別與屬性，其子類別即使寫了也無法使用 Advanced Techniquesconstructor function在 TypeScript 中宣告一個 class 的時候，其實你已經同時執行了多個宣告 1234567891011121314class Greeter &#123; greeting: string; constructor(message: string)&#123; this.greeting= message; &#125; greet()&#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;let greeter: Greeter;greeter = new Greeter(&quot;world&quot;);console.log(greeter.greet()); 上述範例中當 let greeter: Greeter 我們將會使用 Greeter 類別的 instance 賦予 class Greeter 當我們使用 new 這個關鍵字來實體化的時候，便會執行 constructor 轉譯之後的結果如下 12345678910111213let Greeter = (function () &#123; function Greeter(message) &#123; this.greeting = message; &#125; Greeter.prototype.greet = function () &#123; return &quot;Hello, &quot; + this.greeting; &#125;; return Greeter;&#125;)();let greeter;greeter = new Greeter(&quot;world&quot;);console.log(greeter.greet()); 在 let Greeter 就會準備指定給 constructor，而看到接下來的 new 關鍵字並且開始執行 constructor 就會取得一個藉由 Gretter 這個函式實體化的一個結果 在修改一下上面的範例 12345678910111213141516171819202122232425class Greeter &#123; static standardGreeting = &quot;Hello, there&quot;; greeting: string; greet() &#123; if (this.greeting) &#123; return &quot;Hello, &quot; + this.greeting; &#125; else &#123; return Greeter.standardGreeting; &#125; &#125;&#125;let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet());let greeterMaker: typeof Greeter = Greeter;let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet());console.log(greeter1.greet());greeterMaker.standardGreeting = &quot;Hey there!&quot;;console.log(greeter2.greet());console.log(greeter1.greet()); 在這個範例中我們在 Greeter 宣告了一個靜態的屬性 standardGreeting並且給予值 Hello, there 第一步驟跟之前的範例一樣，利用 Greeter 產生了一個物件是 greeter1 然後將他的類別 assign 給 greeterMaker 並且修改了他的 standardGreeting 為 Hey there! 之後再由 greeterMaker 產生一個 greeter2 當它的 greet() 執行的時候產生的字串卻是 Hey there! 而且此時我再次執行 greeter1.greet() 的時候得到的卻也是 Hey there! 也就是當我們 可以利用 這樣的方式統一管理一個靜態屬性也會互相繼承靜態屬性","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"Typescript-Interfaces","path":"/2017/11/03/Typescript-Interfaces/","content":"Interfaces簡介TypeScript 有一種類型宣告方式，有時候這個模式叫做 duck typing 或是 structural subtyping， 或統稱為 interface 第一個 interface最簡單的的 interface 123456function printLabel(labelledObj: &#123;label: string&#125;)&#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: &#x27;Size 10 Object&#x27;&#125;;printLabel(myObj); 呼叫 printLabel 的時候會進行 type-check，而在 printLabel 中就有參數檢查， label 必須是 string, 實際上可能有更多的屬性，不只是 label, 檢查只會檢查 label 屬性是不是字串，有些狀況 TypeScript 並不寬鬆，之後會慢慢做解釋 依據上面的範例可以使用 interface 指定 label 為必要參數 12345678910interface LabelledValue&#123; label: string&#125;function printLabel(labelledObj: LabelledValue)&#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: &#x27;Size 10 Object&#x27;&#125;;printLabel(myObj); LabelledValue 是我們可以描述參數必要性的範例，代表輸入值必須要有一個 label 變數型態為字串，我們並不需要非常明確的指定 printLabel 這個 Function 的輸入參數，只要符合這個 interface 就會允許使用 Optional Properties也可以定義不一定會存在的參數 1234567891011121314151617interface Squareconfig&#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123;color: string, area: number&#125;&#123; let newSquare = &#123;color: &quot;white&quot;, area: 100&#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color: &quot;black&quot;&#125;); 唯讀有些 properties 應該只能被修改，無法整個被覆寫 1234567interface Point &#123; readonly x: number; readonly y: number;&#125;let p1: Point = &#123;x: 10, y: 20&#125;;p1.x = 5; // Error 也可以定義一個唯讀的陣列 123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; //Errorro.push(8); //Errorro.length = 100; // Errora = ro; //Error 最後一行中，當你定義為普通 ReadArray 要 assign 給一個 Array 是不允許的 readonly vs constconst 只是禁止你的物件被覆寫，而 readonly 則是設定你的物件中的參數被覆寫 Excess Property Checks在第一個範例中，雖然我們寫了一個 interface 是 &#123;size: number, label: string&#125; 但是我們真正有使用的只有 &#123;label: string&#125;, 我們在剛剛也有提到 optional properties 或是稱為 option bags 但是這兩個一起使用的話也有可能產生一些問題 12345678910interface SquareConfig&#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123;color: string, area: number&#125;&#123; //...&#125;let mySquare = createSquare(&#123;colour: &quot;red&quot;, width: 100&#125;); 上述範例中 creteSquare 中的 colour 拼錯了，正確應該是 color, 並且 TypeScript 會顯示編譯錯誤，然而你可以辯解說因為 width 是正確的， color 並不存在，但是 colour 名稱的錯誤是微不足道的 12// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;let mySquare = createSquare(&#123; colour: &quot;red&quot;, width: 100 &#125;); 這時候正規的實作方式可以是 12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; 我們將會討論 index signatures 但是在這裡可以說 SquareConfig 可以有任意數量的 properties 不論是不是 color 或是 width 他們並不在意 另外還有一種方法，你直接宣告一個 SquareOptions 物件來放入 createSquare 中也不會有錯誤出現 12let squareOptions = &#123; colour: &quot;red&quot;, width: 100 &#125;;let mySquare = createSquare(squareOptions); 請記得上述的範例，不應該讓這些檢查類別變得更加的複雜，你應該要持續檢查這些類型，因為大多數的錯誤都會造成 bugs。如果你允許 在 createSquare 中使用 color 或是 colour 這兩個參數，你應該修改 squareConfig 來顯示這兩種使用情境 Function Typesinterfaces 可以用來描述物件的輪廓，然而為了要可以描述物件的 properties 所以 interfaces 應該也是可以描述 Function types interfaces 描述一個 function type 的時候只需要定義 parameter 列表和回傳值，每一個 parameter 都需要明確的定義名稱和類別 123interface SearchFunc&#123; (source: string, subString: string): boolean;&#125; 只需要定義一次之後就可以拿這個 interface 來建立變數 123456789interface SearchFunc&#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string)&#123; let result = source.search(subString); return result &gt; -1;&#125; 在宣告 Function 的時候 parameter 的名字不一定要一樣 123456789interface SearchFunc&#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(src: string, sub: string): boolean&#123; let result = src.search(sub); return result &gt; -1;&#125; 宣告也可以只宣告一次，，之後依據同類型宣告的 Function 也會依照之前宣告的 interface 做檢查，不避在重複定義。 123456789interface SearchFunc&#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125; Indexable Types基本上我們可以用 interface 來定義 Function 也可以來定義 index 12345678interface StringArray&#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [&quot;Bob&quot;, &quot;Fred&quot;];let myStr: string = myArray[0]; 在上方的範例中， StringArray 中有宣告一個 index type 為 number。 基本上只有 兩種類型的 index， 就是 number 和 string，也可以同時支援兩種類別，但是在支援兩種類別的時候若是為 100 則必須是回傳 &#39;100&#39;，也就是兩種類別必須要統一 123456789101112class Animal&#123; name: string;&#125;class Dog extends Animal&#123; breed: string;&#125;interface NotOkay&#123; [x: number]: Animal; [x: string]: Dog;&#125; string 是非常實用的宣告 index 方式，因為 obj.property 也可以視為 obj[&#39;property&#39;] 這一個範例因為 name 的類別並不匹配，所以在檢查類別的時候會有錯誤 12345interface NumberDictionary&#123; [index: string]: number; length: number; //ok, length is a number name: string; //error name is not a subtype of the indexer&#125; 最後我們試著宣告一個唯讀的 interface 1234567interface ReadonlyStringArray&#123; readonly [index: number]: string&#125;let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];myArray[2] = &quot;Mallory&quot;; // Error Class Type實現一個 class 的 type12345678interface ClockInterface&#123; currentTime: Date;&#125;class Clock implements ClockInterface&#123; currentTime: Date; constructor(h: number, m: number)&#123;&#125;&#125; 也可以描述在 class 中的 method， 例如在 Clock 中描述一個 setTime 的 method 123456789101112interface ClockInterface&#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface&#123; currentTime: Date; setTime(d: Date)&#123; this.currentTime = d; &#125; constructor(h: number, m: number)&#123;&#125;&#125; Difference between the static and instance sides of classes當我們要使用 interface 來宣告 class 的時候，要記得 class 有兩種類型，一種是 public 一種是 static 當你要宣告一個 class 的 constructor 的時候會有錯誤 12345678interface ClockConstructor&#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor&#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 這是因為當一個 class 轉為 instance 的時候，只有 instance 這邊有做 typing-check 而再 static-side 並沒有包含這個檢查 所以在下面的這個範例，需要定義兩個 interface ，ClockContructor 是為了 constructor 而 ClockInterface 是為了實體化後的物件定義，而會了方便我們定義 constructor 所以又建立一個 createClock 來做這件事情 12345678910111213141516171819202122232425262728293031interface ClockConstructor &#123; new (hour: number, minute: number);&#125;interface ClockInterface &#123; tick();&#125;function createClock( ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(&quot;beep beep&quot;); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(&quot;tick tock&quot;); &#125;&#125;let digital = createClock(DigitalClock, 12, 18);let analog = createClock(AnalogClock, 7, 21); 因為 createClock 的第一個參數是 ClockConstructor 在 createClock(AnalogClock, 7, 21) 中檢查 Analogclock 的 constructor 是否有正確的參數類型 就像 classes 一樣 interface 可以利用繼承將他們的屬性傳給自己的 Children 1234567891011interface Shape &#123; clolor: string;&#125;interface Square extends Shape &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = &#x27;blue&#x27;;square.sideLength = 10; 也允許多重繼承，建立一個集合體 12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let s = &lt;Square&gt;&#123;&#125;;s.color = &quot;blue&quot;;s.sideLength = 10;s.penWidth = 5.0; Hybird TypeJavascript 常常會有很豐富的一個 多次繼承，也可以使用 Hybird Type 來做多個繼承 1234567891011121314151617interface Conter&#123; (start: number): string; interval: number; reset():void;&#125;function getCounter():Counter&#123; let counter = &lt;Counter&gt;function(start: number)&#123;&#125;; counter.interval = 123; counter.reset = function()&#123;&#125;; ;return counter;&#125;let c = getCounter();c(10);c.reset()c.interval = 5.0; Interfaces Extending Classes當一個 interface 繼承了一個 class 只是繼承了他的屬性而不是他的實體只是繼承了他的屬性而不是他的實體，這就是說當你要實踐這個 interface 的同時也必需繼承同一個 class 來實現他的所有屬性 當你有一個很大的繼承架構，但是又想要自訂一個程式碼專為某一個 subclass 中的某些屬性 又不希望她繼承所有的父輩繼承 12345678910111213141516171819202122232425class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123;&#125;// Error: Property &#x27;state&#x27; is missing in type &#x27;Image&#x27;.class Image implements SelectableControl &#123; state = 1; select() &#123; &#125;&#125;class Location &#123;&#125; 上述範例中 SelectableControl 包含了所有的 Control 的屬性，包含 private 的 state，這意味著之後要實現 SelectableControl 的同時只能 extends Control 一個類別去承接他的 private 的 state 在 Control 之中允許透過 SelectableControl 來取得 private state，而 SelectableControl 就像是 Control 知道他還會有一個 function select， Button 和 TextBox 是 SelectableContorl 的子類，因為他們都是繼承魚 Control 但是 Image 和 Location 則不是","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"TypeScript-VariableDecarations","path":"/2017/11/02/TypeScript-VariableDecarations/","content":"Variable Decarationslet 和 const 是兩種 Javascript 新的宣告方式， let 和 var 比較類似 const 則是定義之後禁止之後修改(常數) TypeScript 也有提供 let 和 const 的宣告方式，下個部分將會解釋為什麼會推薦使用 let 和 const var 宣告在 Javascript 中宣告一個變數常用的方式是 1var a = 10; 在上面的例子之中，你宣告了一個變數 a 為 10 你也可以再 Function 中宣告 1234function f()&#123; var message = &#x27;Hello, World!&#x27;; return message&#125; 也可以允許相同的變數在不同的 Function scope 1234567function f()&#123; var a = 10; return function g()&#123; var b = a + 1; return b; &#125;&#125; 在上方的範例中 g() 中可以取得變數 a 得值 123456789101112function f()&#123; var a = 1; a = 2; var b = g(); b = 3; return b; function g()&#123; return a; &#125;&#125;f(); // result 2 使用 var 宣告會有一些區域的規則問題 123456789function f(shouldInitialize: boolean)&#123; if(shouldInitialize)&#123; var x = 10; &#125; return x;&#125;f(true); // 10f(false); //undefined 因為 var 是在 if裡面，所以當 shouldInitialize 是 false 的話就部會執行 if裡面的程式碼 所以 x 並未宣告過，就會造成 undefined 這個規則可能會造成壹些不同種類型的錯誤，其中一種就是當你重複宣告同樣名稱的變數的時候彼此會互相覆蓋 1234567891011function sumMatrix(matrix: number[][])&#123; var sum = 0; for(var i = 0; i &lt; currentRow.length; i++)&#123; var currentRow = matrix[i]; for(var i =0;i &lt; currentRow.length; i++&gt;)&#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 上述範例就可以發現因為 i 變數在雙迴圈中會被互相覆蓋造成程式執行上的錯誤\u0010，不會依據我們預想的去執行 奇怪的問題123for(var i=0;i&lt;10;i++)&#123; setTimeout(function()&#123;console.log(i)&#125;, 100*i);&#125; 但是結過卻是 1234567891010101010101010101010 但是我們希望的是 123456789100123456789 因為每次呼叫 setTimeout 會延遲一段時間後才開始執行 Function但是迴圈會不斷覆蓋掉 i 這個變數，而在延遲時間之後呼叫到的 i 則是最後覆蓋成 10 的 i 最常見要解決這件事情的方式如下 12345for(var =0; i&lt; 10; i++)&#123; (function(i)&#123; setTimeout(function(i)&#123;console.log(i);&#125;, 100*i); &#125;)(i)&#125; 這個看起來有點奇怪的解決方式在 javascript 中卻是常見解決這個問題的方式 let現在你已經知道 var 會有一些問題，所以會有一些問題，所以為什麼需要介紹 let.let 和 var 的使用方式依樣 1let hello = &#x27;hello&#x27;; Block-scoping使用 let 宣告的時候，它的作用域市 blocking-scope。和 var 宣告的作用域不一樣，他是用大括號來做區隔 12345678function f(input: boolean)&#123; let a = 100; if(input)&#123; let b = a + 1; return b; &#125; return b; // b 並不存在&#125; 上述範例中有 a 和 b 兩個變數， a 的變數範圍在整個 f() Function 之中，而 b 只會存在 if之中 而變數使用 try catch 宣告的範例如下 1234567try&#123; throw &#x27;oh no!&#x27;;&#125;catch(e)&#123; console.log(&#x27;oh well&#x27;);&#125;console.log(e);// e not found 另外一個很重要的 blocking-scope 變數不能在宣告之前做任何動作 12a++;let a; 在 TypeScript 中對這樣的提前宣告較為寬鬆，你需要使用 try catch 來取得錯誤訊息 若是沒有使用 try catch TypeScrtip 並不會顯示這個訊息，若是在 ES2015 則會顯示這個錯誤訊息 1234567function foo()&#123; return a;&#125;foo(); //會丟出一個錯誤訊息 let a; 重複宣告和 shadowing若是使用 var 的方式來宣告的話，他不會在意你宣告過幾次 1234567function f(x)&#123; var x; var x; if(true)&#123; var x; &#125;&#125; 使用 let 宣告在同一個 scope 中只能宣告一次 12let x = 10;let x = 20; // Error 12345678function f(x)&#123; let x = 100;// Error&#125;function g()&#123; let x = 100; let x = 120;// Error&#125; 只要是在不同的 blocking-scope 就可以做同名的宣告 1234567891011function (condition, x)&#123; if(condition)&#123; let x = 100; return x; &#125; return x;&#125;f(false, 0); // returns &#x27;0&#x27;f(true, 0); // returns &#x27;100&#x27; 宣告一個新的名稱在另外一個內嵌的 block-scoping 這個行為叫做 shadowing，但是這樣的行為會造成一些 bugs 例如： 1234567891011function sumMatrix(matrix: number[][])&#123; let sum = 0; for (let i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (let i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; shadowing 在攥寫程式碼的時候應該要避免的狀況之一 Block-scoped variable capturing當我們在一個作用域中宣告一個變數與 Function ，而\u0010 Function 也是其中一個作用域，在這個 Function 使用已宣告的變數的時候，即使脫離了那個作用域，也是依舊可以使用該變數 1234567891011function theCityThatAlwaysSleeps()&#123; let getCity; if(true)&#123; let city = &#x27;Seattle&#x27;; getCity = function ()&#123; return city; &#125; &#125; return getCity(); // Seattle&#125; 因為 city 雖然是在 if 的作用域宣告的，但是可以透過 Function 記住他的指標即使脫離作用域之後也可以透過該 Function 做呼叫使用 回憶之前 setTimeout 的範例， let 有相當大程度的不同 123for(let i=0; i &lt; 10; i++&gt;)&#123; setTimeout(function()&#123;console.log(i)&#125;, i * 100);&#125; 結果為 123456789100123456789 constconst 是另外一種不同的宣告 1const numLivesForCat = 9; 雖然看起來跟 let 宣告一樣，雖然他們有相同的 block-scoping 規則，但是還是有些不同 const 宣告的變數是 immutable 的 12345678910111213141516const numLivesForCat = 9;const kitty = &#123; name: &quot;Aurora&quot;, numLives: numLivesForCat&#125;;kitty = &#123; name: &#x27;Danielle&#x27;, numLives: numLivesForCat&#125;; // Error// All OKkitty.name = &#x27;Rory&#x27;;kitty.name = &#x27;Kitty&#x27;;kitty.name = &#x27;Cat&#x27;;kitty.numLives--; 除非你要整個複寫整個物件，否則還是可以修改參數值得， 也就是此物件性質為 唯讀 的，詳情參閱 let vs. const為什麼需要兩個不同的語意卻擁有相同的 block-scoping 的宣告方式呢？ 基於 最小權限原則若之後變數都不需要修改或是物件僅僅提供修改參數的權限時，則使用 const，換句話說若是變數之後有可能會被覆寫則使用 let 來宣告 DestructuringES2015 的特性在 Typescript 中依舊可以使用 Array destructuring12345let input = [1, 2];let [first, secode] = input;console.log(first); // 1console.log(secode); // 2 這個解構也可以在 Function 中使用 123456function f([first, second]: [number, number])&#123; console.log(first); console.log(second;&#125;f([1, 2]); 也可以將大量的變數指定給某一個變數 123let [first, ...rest] = [1, 2, 3, 4];console.log(first); // 1console.log(rest); // [2, 3, 4] 當然你也可抵應某些參數 12let [first] = [1, 2, 3, 4];console.log(first); //1 也可以單存指定某些特定的參數 1let [, second, , fourth ] = [1, 2, 3, 4]; Object destructuring你也可以解構 object 1234567let o = &#123; a: &quot;foo&quot;, b: 12, c: &quot;bar&quot;&#125;let = &#123;a, b&#125; = o; 你可以單純指定 a, b 而 c 可以因為不使用而跳過 你也可以使用 ... 這個形態來指定變數 12let &#123;a, ...passthrogh&#125; = o;let total = passthrough.b + passthrogh.c.length; property renaming你可以對變數重新命名 1let &#123;a: newName1, b: newName2&#125; = o; 也可以將 a:newName1 改為 a as newName1 也是一樣的效果 在 TypeScript 也是需要宣告類型 1let &#123;a, b&#125;: &#123;a: string, b: number&#125; = o; Default vaules在你解構的時候也可以提供預設值 123function keepWholeObject(&#123;a: string, b?: number&#125;)&#123; let &#123;a, b = 1001&#125; = wholeObject;&#125; keepWholeObject 中的 b 若是有參數則指定該參數，若是 undefined 或是 null 則指定為預設值 1001 宣告 Function解構依舊可以使用在宣告函式之中 1234type C = &#123;a: string, b?:number&#125;;function(&#123;a, b&#125;: C)&#123; // ...&#125; 也可以解構時預先放入預設值 12345function f(&#123;a, b&#125; = &#123;a: &quot;&quot;, b: 0&#125;): void&#123; //...&#125;f(); // ok, default to &#123;a: &quot;&quot;, b: 0&#125; 參數與設定型態都可以給予預設值，但是這兩個又有什麼不同呢？ 123456function(&#123;a, b=0&#125;: &#123;a: &quot;&quot;&#125;): void&#123; //...&#125; f(&#123;a: &#x27;yes&#x27;&#125;); // ok default b = 0 f(); // default to a = &#123;a: &quot;&quot;&#125;, default b = 0; f(&#123;&#125;); // error &#x27;a&#x27; is required SpreadES2015 中的 Spread 特性也是支援的 1234let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5];console.log(bothPlus); // [0, 1, 2, 3, 4, 5] Spread 也可以使用在 object 123let defaults = &#123;food: &#x27;spicy&#x27;, price: &#x27;$$&#x27;, ambiance: &#x27;noisy&#x27;&#125;;let search = &#123;...defaults, food: &#x27;rich&#x27;&#125;;console.log(search); // &#123;food: &#x27;rich&#x27;, price: &#x27;$$&#x27;, ambiance: &#x27;noisy&#x27;&#125; 在上述範例中 search 會解構 defaults 而且後面的 food 因為和 defaults 中重複而且順序在 defaults 的後面，所以會被覆蓋 123let defaults = &#123;food: &#x27;spicy&#x27;, price: &#x27;$$&#x27;, ambiance: &#x27;noisy&#x27;&#125;;let search = &#123;food: &#x27;rich&#x27;, ...defaults&#125;;console.log(search); // &#123;food: &#x27;spicy&#x27;, price: &#x27;$$&#x27;, ambiance: &#x27;noisy&#x27;&#125; 但是 Spread 只會繼承特性，部會繼承 Function 12345678910111213class C&#123; p = 12; m()&#123; //... &#125;&#125;let c = new C();let clone = &#123;...c&#125;;console.log(clone.p); // 12console.log(clone.m); // undefined 另外 TypeScript 編譯過程並不允許 generator function 的 Spread 參數傳遞","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"Leetcode-Q8","path":"/2017/11/02/Leetcode-Q8/","content":"Remove Duplicates from Sorted List題目Given a sorted linked list, delete all duplicates such that each element appear only once.+ For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 改一個排序過的連結陣列，刪除重複的節點。範例：[1,1,2] -&gt; return [1,2][1,1,2,3,3] -&gt; return [1,2,3] NodeListNodeList Nodelist 並不是陣列，主要的區別在於 array 有 push 和 pop， 但是 NodeList 並沒有 最簡單的範例就自愛瀏覽器使用 document.querySelectorAll(&#39;class&#39;) 回傳值就是 NodeList 想法因為輸入值已經是排序過後的 NodeList，所以只需要檢查室不是下一個跟這一個事不是相等 若是相等就略過 Result1234567891011121314var deleteDuplicates = function(head) &#123; if(head === null || head.next === null)&#123; return head; &#125; let temp = head; while(temp.next !== null)&#123; if(temp.val === temp.next.val)&#123; temp.next = temp.next.next; &#125;else&#123; temp = temp.next; &#125; &#125; return head;&#125;;","tags":["Javascript","Leetcode"],"categories":["Leetcode"]},{"title":"Typescript-BasicType","path":"/2017/10/31/Typescript-BasicType/","content":"翻譯來源Basic Type Introduction為了要讓更清楚的使用 TypeScript 會從最基本的元件 numbers, strings, structures, boolean, values 這類的動作， TypeScript 支援宣告這類型的 types Boolean宣告最基本的 true&#x2F;false 在 TypeScript 中稱為 boolean 1let isDone: boolean = false; Number和 Javascript 一樣，在 TypeScript 中預設的是浮點數，而這個類別統一為 number 也支援十六進制，十進制，八進制，以及 binary 1234let decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744; String另外一種工程師常用的類型是字串，這種形態使用 string 來做宣告，在 TypeScript 中都允許使用單引號(‘) 或是 雙引號(“) 來做字串的宣告 12let color: string = &quot;blue&quot;;color = &#x27;red&#x27;; 你也可以使用 template strings，宣告使用 backtick&#x2F;backquote(&#96;) 12345let fullName: string = `Bob Bobbington`;let age: number = 37;let sentence: string = `Hello, my name is $&#123;fullName&#125;;I&#x27;ll be $&#123;age + 1&#125; years old next month`; 這個 template strings 也可以寫成 12let sentence: string = &quot;Hello, my name is &quot; + fullName + &quot;. &quot; + &quot;I&#x27;ll be &quot; + (age + 1) + &quot; years old next month.&quot;; ArrayTypeString 和 Javascirpt依樣允許你使用 Array， 宣告時使用 [] 來做類型宣告 12let list: number[] = [1,2,3];let list2: Array&lt;number&gt; = [1,2,3]; TupleTuple 允許你宣告每一個參數的類型 1234let x : [string, number];x = [&#x27;hello&#x27;, 10]; //OKx = [10, &#x27;hello&#x27;]; //Error 好處就是當你明確的定義類型的時候，使用的時候就會有明確的錯誤訊息 12345678910let x : [string, number];x = [&#x27;hello&#x27;, 10];console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, &#x27;number&#x27; does not have &#x27;substr&#x27;x[3] = &quot;world&quot;; // OK, &#x27;string&#x27; can be assigned to &#x27;string | number&#x27;console.log(x[5].toString()); // OK, &#x27;string&#x27; and &#x27;number&#x27; both have &#x27;toString&#x27;x[6] = true; // Error, &#x27;boolean&#x27; isn&#x27;t &#x27;string | number&#x27; Enum另外一種特別的型別事 enum 你可以定義哪些允許的類型列表 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; 你也可以設定 enum 得值 123456789enum Color &#123; Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName);// Green 也可以直接定義 key值 123456789enum Color &#123; Red = 1, Green = 2, Blue = 4&#125;let colorName: string = Color[4];console.log(colorName);// Blue Any我們要描述一個變數，但是在攥寫程式的當下不知道他的類型，這個值是屬於動態的內容，所以可以利用 any 來做宣告 123let notSure: any = 4;notSure = &quot;maybe a string instead&quot;;notSure = false; any 類型相當的彈性，你也許會期望 object 也會有一樣的情況，但是 object 並不允許你呼叫任意的函式，即使他真的存在 123456let notSuer: any = 4;notSure.ifItExists();notSure.toFixed();let prettySure: object = 4;prettySure.toFixed(); //Error: &#x27;toFixed&#x27; not exist on type &#x27;Object&#x27; Voidvoid 有一點像 any ， 他並沒有任何類型，你可以在沒有回傳的函式中使用它 123function warnUser():void&#123; alert(&#x27;This is my warning message&#x27;);&#125; 當你宣告變數為 void 的時候，你只能 assign undefined 或是 null 1let unsable: void = undefined; Null 和 Undefined在 TypeScript 中 undefined 和 null 有他的類型就叫做 undefined 和 null 就像 void ，他們沒瞎小路用 12let u: undefined = undefined;let n: null = null; 預設 null 和 undefined 是各種類型的亞類型，也就是你可以 assign null 或是 undefined 給 number 類型的變數 然而若是你在 tsconfig.json 中的選項 strictNullChecks 設定為 true 則 null 和 undefined 只能 assign 給 void 和他們的各自類型。 若是一個變數有多重可能，你也可以利用 union 類型 1let notSure: string | null | undefined; Never never 類型代表永遠不會發生，例如你的函式確認永遠都不會回傳任何值，那麼你就可以利用 never 類型 或是某一個變數永遠都是 false 你也可以設定他為 never 12345678910111213 function error(message: string): never&#123; throw new Error(message); &#125; function fail()&#123; return error(&quot;Something failed&quot;); &#125; // Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123; &#125;&#125;","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"TypeScript-ReactAndWebpack","path":"/2017/10/31/TypeScript-ReactAndWebpack/","content":"參考來源React &amp; Webpack React &amp; Webpack這一個篇章會帶你使用 TypeScript 使用 webpack 開發 React 如果你還不知道如何初始化一個新的 React 可以參考這篇文章 換句話說，我們假設你已經會使用 nodejs 和 npm Lay out the project開始建立一個新的資料夾 proj 1mkdir proj &amp;&amp; cd proj 然後我們建立一個新的資料結構 1234proj/├─ dist/└─ src/ └─ components/ TypeScript 放置於 src 的資料夾中，經過 TypeScript compiler 後再經由 Webpack 最後在 dist 產生一個 bundle.js 的檔案，每一個 components 都會放在　src/components 的資料夾內 初始化專案123$ yarn init$ yarn add react react-dom$ yarn add @types/react @types/react-dom -D types/ 這類的套件代表我們需要他取得 TypeScript 的宣告，通常當你 import 一個套件路徑 react，才找得到 react 的套件，然而並不是所有套件都需要這種宣告套件，然而並不是所有套件都需要這種宣告套件 安裝開發用套件 1$ yarn add typescript awesome-typescript-loader source-map-loader -D 這兩個套件一起幫你編譯你的程式碼， awesome-typescript-loader 會依據 tsconfig.json 這個檔案所描述的 TypeScript 標準來做編譯。 而 source-map-loader 可以在你開發的時候可以做編譯前與編譯後的 mapping 方便追蹤錯誤的程式碼 增加 TypeScript 設定檔案若你希望你的 TypeScript 整合在一起，你需要一個 tsconfig.json 1234567891011&#123; &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;./dist/&quot;, &quot;sourceMap&quot;: true, &quot;noImplicitAny&quot;: true, &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;jsx&quot;: &quot;react&quot; &#125;, &quot;include&quot;: [&quot;./src/**/*&quot;]&#125; 若是你希望學習更多的 tsconfig.json 可以參考這篇文章 範例程式在 src/components 建立一個新的 Hello.tsx 123456789101112import * as React from &quot;react&quot;;export interface HelloProps &#123; compiler: string; framework: string;&#125;export const Hello = (props: HelloProps) =&gt; ( &lt;h1&gt; Hello from &#123;props.compiler&#125; and &#123;props.framework&#125;! &lt;/h1&gt;); 然後在 src 中新增一個 index.tsx 123456789import * as React from &quot;react&quot;;import * as ReactDOM from &quot;react-dom&quot;;import &#123; Hello &#125; from &quot;./components/Hello&quot;;ReactDOM.render( &lt;Hello compiler=&quot;TypeScript&quot; framework=&quot;React&quot; /&gt;, document.getElementById(&quot;example&quot;)); 在 index.tsx 中只是引入了 Hello.tsx 然後將 Hello component 顯示在頁面上 為了顯示這個 component 我們需要建立一個 index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;!-- Dependencies --&gt; &lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!-- Main --&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 建立一個 webpack 設定檔案123456789101112131415161718192021module.exports = &#123; entry: &quot;./src/index.tsx&quot;, output: &#123; filename: &quot;bundle.js&quot;, path: __dirname + &quot;/dist&quot; &#125;, devtool: &quot;source-map&quot;, resolve: &#123; extensions: [&quot;.ts&quot;, &quot;.tsx&quot;, &quot;.js&quot;, &quot;.json&quot;] &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/, loader: &quot;awesome-typescript-loader&quot; &#125;, &#123; enforce: &quot;pre&quot;, test: /\\.js$/, loader: &quot;source-map-loader&quot; &#125; ] &#125;, externals: &#123; react: &quot;React&quot;, &quot;react-dom&quot;: &quot;ReactDOM&quot; &#125;&#125;; 你可能會好奇 externals 這個欄位在做什麼的？ 我們希望在打包的時候希望可以共用一些 package 就好像 global variable 就像 jQuery 或是 _ 一樣 這叫做 namespace pattern， webpack 允許我們使用這個方式來引用套件。 1$ webpack","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"Typescript-Migrating from Javascript","path":"/2017/10/30/Typescript-MigratingFromJavascript/","content":"翻譯來源Migrating from JavaScript 從 Javascript 搬移你的程式到 TypeScriptTypeScript 不會憑空存在， 他還是依存於 Javascript 的生態圈內，有很多舊的 Javascript 要轉譯為 TypeScript 過程中很無趣的。 如果你是要轉譯 React project 我們會推薦你先閱讀這份文件 設定你的資料結構基本的檔案架構會如下 123456projectRoot├── src│ ├── file1.js│ └── file2.js├── built└── tsconfig.json 如果你有想要用測試的話，在 src 再加上 tests 並且在 tsconfig.json 除了 src 之外再加上 tests 寫一個設定檔案TypeScript 使用 tsconfig.json 來做專案的設定 12345678910&#123; &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;./built&quot;, &quot;allowJs&quot;: true, &quot;target&quot;: &quot;es5&quot; &#125;, &quot;include&quot;: [ &quot;./src/**/*&quot; ]&#125; 我們利用這個設定檔案 對 TypeScript 做一些設定 包含 include 讀取 src 中所有檔案 允許 Javascript 文件直接輸入 可以在 build 輸出所有編譯後文件 將 ES6或是ES7 轉譯為 ES5 如果你是使用 tsc 轉譯你的專案，你應該會在 built 資料夾裡面看到編譯成功的檔案 優勢如果你使用的是VS code 或是 Visual Studio 你可以使用相當多的工具，例如自動完成。也可以增加一些設定方便你 debug noImplicitReturns 可以防止你在 function 的最後忘記回傳值 noFallthroughCasesInSwitch 可以協助你補上 break 在 switch 中的 case TypeScript 依舊會對無法訪問的標籤的錯誤顯示，你可以利用 allowUnreachableCode 和 allowUnusedLabels 來取消 整合你的編譯工具每個人都有自己的編譯步驟 下個範例是我們覺得目前最佳的方式 Gulp相關的 gulp 使用可以參考我們另外一個文件 WebpackWebpack 是一個相當簡單的工具！ 你可以使用 awesome-typescript-loader 這是一個 TypeScript Loader 另外也可以使用 source-map-loader 讓你更易於 debug 1$ yarn add awesome-typescript-loader source-map-loader 將上述兩個套件加入你的 webpack.config.js 12345678910111213141516171819202122module.exports = &#123; entry: &#x27;./src/index.ts&#x27; output: &#123; filename: &#x27;./dist/bundle.js&#x27; &#125;, devtool: &#x27;source-map&#x27;, resolve: &#123; extensions: [&#x27;&#x27;, &#x27;webpack.js&#x27;, &#x27;.web.js&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;, &#x27;js&#x27;] &#125;, moudle: &#123; loaders: [ &#123;test: /\\.tsx?$/, loader: &#x27;awesome-typescript-loader&#x27;&#125; ], preLoaders: [ &#123;test: /\\.js$/, loader: &#x27;source-map-loader&#x27;&#125; ] &#125;&#125; awesome-typescript-load 必須在所有的 loader 的前面 ts-loader 也是一樣的道理，你可以在這邊獲得更多資訊 將 .js 轉換成為 .ts我們可以開始對檔案做一些動作開始轉換 第一個步驟就是將所有的 .js 換成 .ts 若是你的檔案有使用 JSX 則需要將檔案名稱換成 .tsx 當然你會覺得怪怪的，這樣就結束了麻？ 當然不是！ 接著你可以打開你的編輯器或是使用 command line 1$ tsc --pretty 你可以看到一些 紅色 的波浪底線 這些就像是 微軟的 word 軟體提醒你這些並不符合 TypeScript 的規範 如果這些對你說太寬鬆，你希望可以更加嚴謹的話你也可以使用 noEmitOnError 這一個選項來讓檢查更加嚴謹 如果你希望使用嚴謹模式可以參考這篇文章 例如你不希望變數型態使用不明確的 any 你可以在編輯檔案之前使用 noImplicitAny。 解決錯誤相關問題就像剛剛提到的，你會修改 .js 為 .ts 或是 .tsx 的時候會有相當多的錯誤訊息 你會發現這些錯誤雖然是屬於合法的錯誤，但是透過這些錯誤可以發現 TypeScript 對你開發程式碼的好處。 import 模組你可能會得到錯誤訊息是 Cannot find name &#39;require&#39; 或是 Cannot find name &#39;deffined&#39; 在這些狀況在這些狀況應該是 TypeScript 找不到這些模組 你需要預先選擇使用引入模組的方式，可以使用 commonjs, amd, system 和 umd 如果你有使用 Nod&#x2F;CommonJS 12var foo = require(&#x27;foo&#x27;);foo.doStuff(); 或是 RequireJS&#x2F;AMD 123define([&quot;foo&quot;], function(foo)&#123; foo.doStuff();&#125;); 你可以修改為 12import foo = require(&#x27;foo&#x27;);foo.doStuff(); TypeScript 的宣告如果你編譯檔案的時候有安裝 foo module 但是依然看到 Cannot find module &#39;foo&#39; 這個錯誤訊息，很有可能是你並未有宣告的檔案來宣告你的 library， 要處理這個問題也很簡單 1$ yarn add @types/lodash -D 如果你有使用 module 選項是 commonjs 你另外需要設定 moduleResolution 為 node 然後你才可以正常沒有錯誤訊息的引用 lodash Export 模組通常在 export 模組的時候都是使用 export 或是 module.exports TypeScript 允許你使用 export 參數，例如: 123module.exports.feedPets = function(pets)&#123; //....&#125; 你可以改為 123export function feedPets(pets)&#123; //...&#125; 有時候你會直接複寫 exports object 這是屬於 commonJS 的設計 在引用這類的模組的時候 12var express = require(&#x27;express&#x27;);var app = express(); 你在之前會有像這樣的範例程式 1234function foo()&#123; //...&#125;module.exports = foo; 在 TypeScript 你可以修改為 export &#x3D; consturct 1234function foo()&#123; //...&#125;export = foo; 有時候你呼叫函式的時候會有太多或是太少的參數， 通常這是一種 bug 但是在有些狀況中你可以宣告函示使用 arguments object 來代替寫出的所有參數 12345678910111213141516171819202122232425262728function myCoolFunction() &#123; if (arguments.length == 2 &amp;&amp; Array.isArray(arguments[1])) &#123; var f = arguments[0]; var arr = arguments[1]; arr.map(value =&gt; f(value)); &#125; else &#123; var f = arguments[0]; var arr = arguments[1]; console.log(&quot;arguments: &quot;, arguments); &#125;&#125;myCoolFunction( function(x) &#123; console.log(x); &#125;, [1, 2, 3, 4]);myCoolFunction( function(x) &#123; console.log(x); &#125;, 1, 2, 3, 4); result: 123451234arguments: &#123; &#x27;0&#x27;: [Function], &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4 &#125; 在這個範例中因為有兩種 input 方式 所以在 TypeScript 需要改為 12345678910111213141516171819202122232425262728293031function myCoolFunction(f: (x: number) =&gt; void, nums: number[]): void;function myCoolFunction(f: (x: number) =&gt; void, ...nums: number[]): voidfunction myCoolFunction() &#123; if (arguments.length == 2 &amp;&amp; Array.isArray(arguments[1])) &#123; var f = arguments[0]; var arr = arguments[1]; arr.map(value =&gt; f(value)); &#125; else &#123; var f = arguments[0]; var arr = arguments[1]; console.log(&quot;arguments: &quot;, arguments); &#125;&#125;myCoolFunction( function(x) &#123; console.log(x); &#125;, [1, 2, 3, 4]);myCoolFunction( function(x) &#123; console.log(x); &#125;, 1, 2, 3, 4); 1$ tsc src/demo1.ts &amp;&amp; node src/demo1.js result 123451234arguments: &#123; &#x27;0&#x27;: [Function], &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4 &#125; 在 TypeScript 中宣告了 myCoolFunction 兩個不同的宣告， 定義一個 f 為 function : (x: number) =&gt; void 然後也對多個變數使用 ...nums: number[] 來宣告是一個數字陣列 增加參數有些人對一個物件增加參數使用下述方式 123let options = &#123;&#125;;options.color = &#x27;red&#x27;;options.volume = 11; TypeScript 則會表示這樣無法新增 color 和 volume 因為 property 不存在 1234567interface Options &#123;color: string, volume: number&#125;;var options = &#123;&#125;; // Errorvar options = &#123;&#125; as Options; // Successoptions.color = &#x27;red&#x27;;options.volume = 11; 你可以將 type 定義為 object 或是 &#123;&#125; 這樣也可以自由地增加物件特性，但是比較常使用的是 any 來宣告這類型自由的型態 例如你有一個物件類型宣告為 object 你將無法呼叫 toLowerCase() 這個函式，但是若是你宣告的是 any 的類型的話，就可以呼叫這個函式。也就是當你宣告為 any 這個類型的話就不會有太多的錯誤提示你的型別問題 嚴謹模式TypeScript 可以幫你檢查並且分析你的程式，讓你的錯誤減少 不推薦使用 any使用了 any 這個類型會造成遇到錯誤時 TypeScript 也不會提醒你，也就喪失使用 TypeScript 的意義，你可以設定 noImplicitAny 這個選項來控制禁止使用 any 更嚴謹的檢查 undefined 和 null在 TypeScript 中 undefined 和 null 的類型宣告都是 any，但是 undefined和 null 在 Javascript 和 TypeScript 造成許多的 Bug，所以你可以設定 strictNullChecks 來做更嚴謹的檢查。 當你設定 strictNullChecks 的時候 undefined 和 null 也會擁有他們自己的類型 undefined 和 null ， 若是有些變數同時可能是數字或是 null 的時候，可以利用 union 來宣告類型， 例如 1234declare var foo: string[] | null;foo.length; // error - &#x27;foo&#x27; 有可能是nullfoo!.length; // okay - foo! 只可能是 &#x27;string[]&#x27; 不可宣告 this 為 any當你使用 this 這個keyword 的時候，預設是 any，例如 12345678910111213141516class Point&#123; constructor(public x, public y)&#123;&#125; getDistance(p: Point)&#123; let dx = p.x - this.x; let dy = p.y - this.y; return Math.sqrt(dx ** 2 + dy ** 2); &#125;&#125;interface Point&#123; distanceFromOrigin(point: Point): number;&#125;Point.prototype.distanceFromOrigin = function(point: Point)&#123; return this.getDistance(&#123;x: 0, y: 0&#125;);&#125; 這部分就像我們上面談的問題其實是一樣的 我們沒辦法去檢查 this 這個變數的型態 TypeScript 也有一個 noImplicitThis 的選項 當這個選項被設定為 true 的時候， TypeScript 會提醒你在使用 this 時要設定型態 123Poing.prototype.distanceFromOrigin = function(this: Point, point: Point)&#123; return this.getDistance(&#123;x: 0, y: 0&#125;);&#125;","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"TypeScriptWithGulp","path":"/2017/10/29/Typescript-Gulp/","content":"翻譯來源TypeScriptWithGulp Gulp此篇是使用 TypeScript 和 Gulp 並且利用 Gulp 的 pipeline增加 Browserify , uglify 或 watchify 以及 Babelify等等功能 Minimal project在此範例中建立一個資料夾 proj 但是你可以建立一個你希望的名字的資料夾 12$ mkdir proj$ cd proj 先簡單建立資料結構 123proj/ ├─ src/ └─ dist/ 初始化12$ mkdir src dist$ yarn init 安裝相關的套件12$ npm install -g gulp-cli$ yarn add typescript gulp gulp-typescript -D Example在 src 中建立一個新的 main.ts 1234function hello(compiler: string) &#123; console.log(`Hello from $&#123;compiler&#125;`);&#125;hello(&quot;TypeScript&quot;); 在 proj 中建立一個 tsconfig.json 123456789&#123; &quot;files&quot;: [ &quot;src/main.ts&quot; ], &quot;compilerOptions&quot;: &#123; &quot;noImplicitAny&quot;: true, &quot;target&quot;: &quot;es5&quot; &#125;&#125; 建立一個 gulpfile.js 123456789var gulp = require(&quot;gulp&quot;);var ts = require(&quot;gulp-typescript&quot;);var tsProject = ts.createProject(&quot;tsconfig.json&quot;);gulp.task(&quot;default&quot;, function () &#123; return tsProject.src() .pipe(tsProject()) .js.pipe(gulp.dest(&quot;dist&quot;));&#125;); 測試 App123$ gulp$ node dist/main.js//result: Hello from TypeScript 增加模組建立一個新的檔案 src/greet.ts 123export function sayHello(name: string)&#123; return `Hello from $&#123;name&#125;`;&#125; 然後再修改 src/main.ts 123import &#123; sayHello &#125; from &quot;./greet&quot;;console.log(sayHello(&quot;TypeScript&quot;)); 最後再修改 tsconfig.json 將 src/greet.ts 加入編譯 12345678910&#123; &quot;files&quot;: [ &quot;src/main.ts&quot;, &quot;src/greet.ts&quot; ], &quot;compilerOptions&quot;: &#123; &quot;noImplicitAny&quot;: true, &quot;target&quot;: &quot;es5&quot; &#125;&#125; 執行1$ gulp &amp;&amp; node dist/main.js 然後就可以看到編譯後執行的結果 1Hello from TypeScript Note: 雖然我們使用 ES2015 但是 TypeScript 使用 commonJS 模組，但是你也可以在 options 中設定 module 來改變它 Browserify我們開始寫前端的程式 我們希望可以把所有 modules 打包到一個 Javascript 檔案 而這些事情就是 browserify 所做的事情，而這會使用到 CommonJS 模組，而這也正好是 TypeScript 預設使用的，也就是我們可以在 TypeScript 直接使用 browserify 先安裝 browserify, tsify, vinyl-source-stream tsify 是 browserify 的 plugin 做的事情就像是 gulp-typescript 一樣，而vinyl-source-stream 則是提供一種方便我們了解的檔案輸出格式 1$ yarn add browserify tsify vinyl-source-stream -D 在 src 中建立一個 index.html 的檔案 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;greeting&quot;&gt;Loading ...&lt;/p&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然後修改 main.ts 12345678import &#123; sayHello &#125; from &quot;./greet&quot;;function showHello(divName: string, name: string) &#123; const elt = document.getElementById(divName); elt.innerText = sayHello(name);&#125;showHello(&quot;greeting&quot;, &quot;TypeScript&quot;); 接著再修改 gulpfile.js 123456789101112131415161718192021222324252627const gulp = require(&#x27;gulp&#x27;);const browserify = require(&#x27;browserify&#x27;);const source = require(&#x27;vinyl-source-stream&#x27;);const tsify = require(&#x27;tsify&#x27;)const paths = &#123; pages: [&#x27;src/*.html&#x27;]&#125;;gulp.task(&#x27;copy-html&#x27;, () =&gt; &#123; return gulp.src(paths.pages) .pipe(gulp.dest(&#x27;dist&#x27;));&#125;);gulp.task(&#x27;default&#x27;, [&#x27;copy-html&#x27;], () =&gt; &#123; return browserify(&#123; basedir: &#x27;.&#x27;, debug: true, entries: [&#x27;src/main.ts&#x27;], cache: &#123;&#125;, packageCache: &#123;&#125; &#125;) .plugin(tsify) .bundle() .pipe(source(&#x27;bundle.js&#x27;)) .pipe(gulp.dest(&#x27;dist&#x27;));&#125;); 增加一個 copy-html 的task 並且將其加入在 default 的 task中，也就是代表當 default執行的時候會先執行 copy-html 並且也修改 default 的 function 加入呼叫 Browserify 和 tsify 的 plugin，將 tsify 取代 gulp-typescript 也丟入一些參數在 Browserify 之中, 在 bundle 之後 再利用 vinyl-source-stream 輸出檔案 bundle.js 然後我們可以執行之後再用瀏覽器開啟 dist/index.html來觀看結果 Note: 設定 debug: true 是因為 在打包成為一個檔案之後， SourceMap 可以對照你打包後的檔案，當你發生錯誤的時候，就可以找到相關錯誤位置，提高 debug 的效率 watchify, Babel and Uglify現在我們已經有 tsify, browserify 我們還可以再加入一些套件 Watcherify 利用 gulp 啟動，可以保證程式持續執行，並且在修改後同步修改重啟，你的瀏覽器也可以立即 refresh 觀看結果 Babel 是一個大型並且彈性的編譯 Lib 可以將 ES2015 轉回 ES5 和 ES3，可以自行增加擴充編譯套件，而這些是 typescript 沒有支援的 Uglify 則是將你的程式最小化，讓你下載的時間可以大大減少下載的時間 Watcher安裝 watchify和 gulp-util 1$ yarn add watchify gulp-util -D 再修改 gulpfile.js 123456789101112131415161718192021222324252627282930313233const gulp = require(&quot;gulp&quot;);const browserify = require(&quot;browserify&quot;);const source = require(&quot;vinyl-source-stream&quot;);const tsify = require(&quot;tsify&quot;);const watchify = require(&#x27;watchify&#x27;);const gutil = require(&#x27;gulp-util&#x27;);const watchedBrowserify = watchify(browserify(&#123; basedir: &quot;.&quot;, debug: true, entries: [&quot;src/main.ts&quot;], cache: &#123;&#125;, packageCache: &#123;&#125;&#125;)).plugin(tsify);const paths = &#123; pages: [&quot;src/*.html&quot;]&#125;;gulp.task(&quot;copy-html&quot;, () =&gt; &#123; return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;));&#125;);function bundle()&#123; return watchedBrowserify .bundle() .pipe(source(&quot;bundle.js&quot;)) .pipe(gulp.dest(&quot;dist&quot;));&#125;gulp.task(&quot;default&quot;, [&quot;copy-html&quot;],bundle);watchedBrowserify.on(&#x27;update&#x27;, bundle);watchedBrowserify.on(&#x27;log&#x27;, gutil.log); gulpfile.js做了三個改變 在 browserify 外面包覆了一層 watchify 我們監聽了 watchedBrowserify 的 update Event 每次修改的時候就會自動重新打包並產生新增檔案到 dist 到資料夾內 我們也監聽了 log 的 Event 使用 gulp-util 的 log 來做紀錄顯示 綜合以上 1, 2 的步驟我們將 browserify 移出了 default task 放到了 function bundle裡然後透過 監聽 update 的 Event 來隨時重新編譯程式 而 3 則是會列印出過程的訊息方便我們開發程式的時候查閱 然後我們開始啟動則會看到下方的訊息 1234516:31:53] Starting &#x27;copy-html&#x27;...[16:31:53] Finished &#x27;copy-html&#x27; after 15 ms[16:31:53] Starting &#x27;default&#x27;...[16:31:54] 2690 bytes written (0.09 seconds)[16:31:54] Finished &#x27;default&#x27; after 1.12 s 並且當你修改 main.ts 時會自動重新編譯 也就是當你重新 refresh 網頁的時候 就可以看到最新的更新狀態 Uglify因為 Uglify 會撕裂你的程式碼，所以需要安裝 vinyl-buffer 和 gulp-sourcemaps 來讓 sourcemaps 持續動作 1$ yarn add gulp-uglify vinyl-buffer gulp-sourcemaps -D gulpfile.js修改為 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const gulp = require(&quot;gulp&quot;);const browserify = require(&quot;browserify&quot;);const source = require(&quot;vinyl-source-stream&quot;);const tsify = require(&quot;tsify&quot;);const watchify = require(&quot;watchify&quot;);const gutil = require(&quot;gulp-util&quot;);const uglify = require(&quot;gulp-uglify&quot;);const sourcemaps = require(&quot;gulp-sourcemaps&quot;);const buffer = require(&quot;vinyl-buffer&quot;);const watchedBrowserify = watchify( browserify(&#123; basedir: &quot;.&quot;, debug: true, entries: [&quot;src/main.ts&quot;], cache: &#123;&#125;, packageCache: &#123;&#125; &#125;)).plugin(tsify);const paths = &#123; pages: [&quot;src/*.html&quot;]&#125;;gulp.task(&quot;copy-html&quot;, () =&gt; &#123; return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;));&#125;);function bundle() &#123; return watchedBrowserify .bundle() .pipe(source(&quot;bundle.js&quot;)) .pipe(gulp.dest(&quot;dist&quot;));&#125;gulp.task(&quot;default&quot;, [&quot;copy-html&quot;], bundle);gulp.task(&quot;production&quot;, [&#x27;copy-html&#x27;], () =&gt; &#123; return browserify(&#123; basedir: &quot;.&quot;, debug: true, entries: [&quot;src/main.ts&quot;], cache: &#123;&#125;, packageCache: &#123;&#125; &#125;) .plugin(tsify) .bundle() .pipe(source(&quot;bundle.js&quot;)) .pipe(buffer()) .pipe(sourcemaps.init(&#123; loadMaps: true &#125;)) .pipe(uglify()) .pipe(sourcemaps.write(&quot;./&quot;)) .pipe(gulp.dest(&quot;dist&quot;));&#125;);watchedBrowserify.on(&quot;update&quot;, bundle);watchedBrowserify.on(&quot;log&quot;, gutil.log); 1$ gulp production Note: Uglify 只需要做一次，buffer和 sourcemaps 會產生一個獨立的檔案 bundle.map.js 你也可以確認 bundle.js 中的程式事不是已經最小化了","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"TypeScript-TypeScriptIn5Minutes","path":"/2017/10/27/Typescript-TypescriptIn5Minutes/","content":"翻譯來源TypeScript TypeScript in 5 minutes使用 TypeScript 建立第一個簡單的 網頁應用 Installing TypeScript有兩個主要的安裝方式 使用 NPM 安裝 安裝 [Visual Studio plugins] Visual StudioVisual Studio 2017 和 Visual Studio 2015 預設已經有使用 TypeScript ，但若是你不希望安裝 Visual Studio 你也可以安裝 TypeScript NPM1$ npm install -g typescript 建立你的第一個 TypeScript 檔案greeter.ts 1234567function greeter(person) &#123; return &quot;Hello, &quot; + person;&#125;var user = &quot;Jane User&quot;;document.body.innerHTML = greeter(user); Compiling your code1$ tsc greeter.ts 經過編譯，你會多了一個 greeter.js 的 Javascript 檔案 而這個檔案可以在前端或 Nodejs 中使用 接下來我們要開始接下來我們要開始嘗試 TypeScript 的幾個功能 就是先在 Function greeter 中的 person 這個參數加上類別的識別 1234567function greeter(person: string) &#123; return &quot;Hello, &quot; + person;&#125;// var user = &quot;Jane User&quot;;var user = [0, 1, 2];document.body.innerHTML = greeter(user); 當編譯的時候就會看到一個錯誤 1greeter.ts(7,35): error TS2345: Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;string&#x27;. 同樣的若是你使用 Function greeter 的時候移除了參數 12345function greeter(person: string) &#123; return &quot;Hello, &quot; + person;&#125;document.body.innerHTML = greeter(); 你也會得到一個錯誤訊息 1greeter.ts(7,27): error TS2554: Expected 1 arguments, but got 0. TypeScript 會協助分析你的程式並且提醒你還需要提供相關的資訊 雖然這些錯誤訊息提醒，但是你的 greeter.js 仍然會產生 TypeScript 僅僅會警告你這些程式碼執行會得到不是你的預期結果 interfaces然後我們可以進一步的開發我們的範例，我們增加一個 interface 他描述了一個物件擁有兩個欄位 firstName 和lastName 在 TypeScript 中容許一個結構內擁有兩種類型只需要描述物件的輪廓 而不需要過於明確的解釋物件的值 123456789101112interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return &quot;Hello, &quot; + person;&#125;var user = &#123; firstName: &quot;Jane&quot;, lastName: &quot;User&quot; &#125;;document.body.innerHTML = greeter(user); Classes最後我在做一些延伸 TypeScript 支援 Javascript 使用 class-based object-oriented programming Javascipt 的物件導向設計 我們再多建立一個 Student 的 class 中擁有 constructor 和一些 public 的欄位 讓 classes 和 interface 可以很好的共同使用，並且讓開發者可以選擇正確的抽象化他的程式碼 1constuctor 是一個簡潔並且方便我們建立 object 的參數 的函式 1234567891011121314151617181920212223class Student &#123; fullName: string; constructor( public firstName: string, public middleInitial: string, public lastName: string ) &#123; this.fullName = firstName + &quot; &quot; + middleInitial + &quot; &quot; + lastName; &#125;&#125;interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;&#125;var user = new Student(&quot;Jane&quot;, &quot;M.&quot;, &quot;User&quot;);document.body.innerHTML = greeter(user); 1$ tsc greeter.ts 然後你可以建立一個 greeter.html 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;TypeScript Greeter&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=&quot;greeter.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然後使用瀏覽器開啟這個 HTML 檔案 就可以看到相關的結果","tags":["Javascript","Typescript","Translate"],"categories":["Javascript"]},{"title":"Leedcode-Q7","path":"/2017/10/23/Leetcode-Q7/","content":"Hamming Distansce (漢明距離)定義 將一個字符串變換成另一個字符串所需要替換的字符個數 題目123456789101112130 ≤ x, y &lt; 231.Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. 將 1 轉為二進位的字串則是 1, 4 轉為二進位的字串則是 1000 但是計算漢明距離時必須是兩個等長的符號 所以必須幫 1 補零為 0001 \b0001 1000 所以需要替換兩個字符 所以回傳值為 2 Javascript 的位元運算子^XOR assignment 將數字轉為二進位之後再做比對的計算 ExampleRule 3 ^ 5 &#x3D; 6 011 101 110 再將 110 轉為十進制則為 6 也就是說當當兩個同位元做比對的規則是 數值相同則為 0 不相同則為 1\b我們可以和另外一個運算子 | 做比較 \b因為在官方的範例中 他們的結果都是一樣的 但是測試之後結過卻還是不一樣 Example 23 | 5 &#x3D; 7 Rule 011 101 111 再將 111 轉為十進制則為 7 也就是 OR 的比對規則是只要有一個為 1 就等於 1 &amp;Bitwise AND assignment Rule 也就是說如果同位元的都為 1 才會等於 1 否則其餘狀況皆為零 Result1234567891011121314/** * @param &#123;number&#125; x * @param &#123;number&#125; y * @return &#123;number&#125; */var hammingDistance = function(x, y) &#123; let ans = 0; while(x || y)&#123; ans += (x &amp; 1) ^ (y &amp; 1); x &gt;&gt;= 1; y &gt;&gt;= 1; &#125; return ans;&#125;; 利用 while 迴圈 \bx &amp; 1 與 y &amp; 1 會取得最後一位檢查是否為零 若是 0 則為 0, 若為 1 則為 1 其結果在使用 XOR(^) 來作判斷是否相同 若同為 0 或 1 則回傳 0 若一個為 0 一個為 1 的時候回傳 1\b將結果疊加在 ans 上 最後再將 x y 做Right shift 之後再將 ans 回傳即為我們需要的結果 參考資料漢明距離 漢明重量 Javascript 運算子","tags":["Javascript","Leetcode"],"categories":["Leetcode"]},{"title":"NPM publish with gulp","path":"/2017/08/31/NPM-Publish-With-Gulp/","content":"NPM PublishInitial Project12345678910$ mkdir publishDemo$ yarn init// question name (publishDemo):// question version (1.0.0):// question description: publishdemo// question entry point (index.js):// question repository url:// question author: Tomas// question license (MIT):// success Saved package.json 初始化結束後會增加一個 package.json 12345678&#123; &quot;name&quot;: &quot;publishDemo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;publishdemo&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;author&quot;: &quot;Tomas&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; Create index.js1module.exports = &#x27;hello world&#x27;; publish12$ npm login// 登入 NPM 的帳號並且驗證信箱 12$ \bnpm publish+ publishdemotest@1.0.0 add Gulpgulpfile.js 1$ mkdir src &amp;&amp; mv index.js ./src 1234567891011121314151617const gulp = require(&quot;gulp&quot;);const babel = require(&quot;gulp-babel&quot;);gulp.task(&quot;compile&quot;, () =&gt; &#123; return gulp .src(&quot;./src/**/*.js&quot;) .pipe( babel(&#123; presets: [&quot;es2015&quot;, &quot;stage-2&quot;], plugins: [] &#125;) ) .pipe(gulp.dest(&quot;./build&quot;));&#125;);gulp.task(&quot;default&quot;, [&quot;compile&quot;]); 12345678910$ gulp// result.├── build│ └── index.js├── gulpfile.js├── package.json├── src│ └── index.js└── yarn.lock Git.gitignore 1234567891011121314151617181920212223242526272829# Logslogs*.lognpm-debug.log*# Runtime datapids*.pid*.seed# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files).grunt# node-waf configuration.lock-wscript# Compiled binary addons (http://nodejs.org/api/addons.html)build/Release# Dependency directory# https://docs.npmjs.com/misc/faq#should-i-check-my-node-modules-folder-into-gitnode_modulesbuild publishdemo update NPM version and main12345678910111213141516&#123; &quot;name&quot;: &quot;publishdemotest&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;publishdemo&quot;, &quot;main&quot;: &quot;\b./build/index.js&quot;, &quot;author&quot;: &quot;Tomas&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-stage-0&quot;: &quot;^6.24.1&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-babel&quot;: &quot;^7.0.0&quot; &#125;&#125; 重新 publish12$ npm publish//+ publishdemotest@1.0.1 這時如果我在其他專案從 NPM 下載結果如下圖 1$ yarn add publishdemotest 123456789 $ tree ./node_modules/publishdemotest //result./node_modules/publishdemotest├── gulpfile.js├── package.json├── src│ └── index.js└── yarn.lock 並沒有build 這個 folder 但是因為在 package.json 中我們將進入點設定為 ./build/index.js 所以會造成我們引入時的錯誤 \b\bNPM 會自動\b將 .gitignore 設定為預設的設定檔案 但是我們希望可以有其他的設定 我們可以增加一個 .npmignore 1234567# Logslogs*.lognpm-debug.log*node_modules*error* 我們將build 移除在 .npmignore 中 再將 package.json 的version 升級 再重新publish 一次 在 Demo 的 project 升級 package 1$ yarn upgrade publishdemotest 12345678910$ tree node_modules/publishdemotestnode_modules/publishdemotest├── build│ └── index.js├── gulpfile.js├── package.json├── src│ └── index.js└── yarn.lock 透過 .npmignore 就可以達到我們需要的效果 同樣如果不希望\b使用者還需要安裝相關套件 也可以把 node_modules 移除 .npmignore 中 如此使用者就不需要安裝相關套件 也可以達到鎖定版本的效果","tags":["Javascript","Nodejs"]},{"title":"ReactUnitestWithJest","path":"/2017/07/31/ReactUnitestWithJest/","content":"SetupCreate React AppRun the test Without Create React App1$ npm install --save-dev jest babel-jest babel-preset-es2015 babel-preset-react react-test-renderer .babelrc 123&#123; &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]&#125; 先寫一個 React Component Link Example Link.js 1234567891011121314151617181920212223242526272829303132333435363738394041import React from &#x27;react&#x27;;const STATUS = &#123; HOVERED: &#x27;hovered&#x27;, NORMAL: &#x27;normal&#x27;,&#125;;export default class Link extends React.Component &#123; constructor(props) &#123; super(props); this._onMouseEnter = this._onMouseEnter.bind(this); this._onMouseLeave = this._onMouseLeave.bind(this); this.state = &#123; class: STATUS.NORMAL, &#125;; &#125; _onMouseEnter() &#123; this.setState(&#123;class: STATUS.HOVERED&#125;); &#125; _onMouseLeave() &#123; this.setState(&#123;class: STATUS.NORMAL&#125;); &#125; render() &#123; return ( &lt;a className=&#123;this.state.class&#125; href=&#123;this.props.page || &#x27;#&#x27;&#125; onMouseEnter=&#123;this._onMouseEnter&#125; onMouseLeave=&#123;this._onMouseLeave&#125;&gt; &#123;this.props.children&#125; &lt;/a&gt; ); &#125;&#125; __tests__/Link.test.js 12345678910111213141516171819202122import React from &#x27;react&#x27;;import Link from &#x27;../Link.react&#x27;;import renderer from &#x27;react-test-renderer&#x27;;test(&#x27;Link changes the class when hovered&#x27;, () =&gt; &#123; const component = renderer.create( &lt;Link page=&quot;http://www.facebook.com&quot;&gt;Facebook&lt;/Link&gt; ); let tree = component.toJSON(); expect(tree).toMatchSnapshot(); // manually trigger the callback tree.props.onMouseEnter(); // re-rendering tree = component.toJSON(); expect(tree).toMatchSnapshot(); // manually trigger the callback tree.props.onMouseLeave(); // re-rendering tree = component.toJSON(); expect(tree).toMatchSnapshot(); __tests__/__snashots__/Link.test.js.snap 12345678910111213141516171819202122232425262728293031323334// Jest Snapshot v1, https://goo.gl/fbAQLPexports[`Link changes the class when hovered 1`] = `&lt;a className=&quot;normal&quot; href=&quot;http://www.facebook.com&quot; onMouseEnter=&#123;[Function]&#125; onMouseLeave=&#123;[Function]&#125;&gt; Facebook&lt;/a&gt;`;exports[`Link changes the class when hovered 2`] = `&lt;a className=&quot;hovered&quot; href=&quot;http://www.facebook.com&quot; onMouseEnter=&#123;[Function]&#125; onMouseLeave=&#123;[Function]&#125;&gt; Facebook&lt;/a&gt;`;exports[`Link changes the class when hovered 3`] = `&lt;a className=&quot;normal&quot; href=&quot;http://www.facebook.com&quot; onMouseEnter=&#123;[Function]&#125; onMouseLeave=&#123;[Function]&#125;&gt; Facebook&lt;/a&gt;`; 測試的時候每次呼叫 toMatchSnapshot 的時候 會依序會依序在 __tests__/__snashots__/Link.test.js.snap 中 取得取得 Mock 做比對 需要完全吻合才會回傳正確 DOM Testing上述的範例是單純比較依據不同的 Input 後造成的 Component 比對 若是你需要操作這些實體化的 Component 則可以使用 Enzyme 或是 React 的 TestUtils 而下述範例則使用 Enzyme ExampleCheckboxWithLabel.js 123456789101112131415161718192021222324252627282930import React from &#x27;react&#x27;;export default class CheckboxWithLabel extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isChecked: false&#125;; // bind manually because React class components don&#x27;t auto-bind // http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding this.onChange = this.onChange.bind(this); &#125; onChange() &#123; this.setState(&#123;isChecked: !this.state.isChecked&#125;); &#125; render() &#123; return ( &lt;label&gt; &lt;input type=&quot;checkbox&quot; checked=&#123;this.state.isChecked&#125; onChange=&#123;this.onChange&#125; /&gt; &#123;this.state.isChecked ? this.props.labelOn : this.props.labelOff&#125; &lt;/label&gt; ); &#125;&#125; 使用 Enzyme 的 shallow renderer __tests__/CheckboxWithdLabel.test.js 1234567891011121314151617import React from &#x27;react&#x27;;import &#123;shallow&#125; from &#x27;enzyme&#x27;;import CheckboxWithLabel from &#x27;../CheckboxWithLabel&#x27;;test(&#x27;CheckboxWithLabel changes the text after click&#x27;, () =&gt; &#123; // Render a checkbox with label in the document const checkbox = shallow( &lt;CheckboxWithLabel labelOn=&quot;On&quot; labelOff=&quot;Off&quot; /&gt; ); expect(checkbox.text()).toEqual(&#x27;Off&#x27;); checkbox.find(&#x27;input&#x27;).simulate(&#x27;change&#x27;); expect(checkbox.text()).toEqual(&#x27;On&#x27;);&#125;); 參考資料jest Testing React Apps","tags":["Javascript","React"],"categories":["Javascript"]},{"title":"Python-Decorator","path":"/2017/06/10/Python-Decorator/","content":"Decorator在網路上最常看到的範例 Example123456789101112def logged(func): def with_logging(*args, **kwargs): print func.__name__ + &quot; was called&quot; return func(*args, **kwargs) return with_logging@loggeddef f(x): return x + x * xprint f(2) 在 logger 中\b定義一個 Function with_logging\b\u001e \b在執行前 f 會被當成參數 func 傳入 logged中 而 with_logging 會優先被執行 執行後才會執行 func \b上面的程式碼也會等於 123456789101112def logged(func): def with_logging(*args, **kwargs): print func.__name__ + &quot; was called&quot; return func(*args, **kwargs) return with_loggingdef f(x): return x + x * xf = logged(f)print f(2) 執行後的結果是一樣的 看起來要使用 Decorator 所有的操作都會在 Function 上 傳入與回傳值都是 Function 再來就是如果有多個裝飾子 那麼順序又如何決定的呢？ 1234567891011121314151617181920def makebold(fn): def wrapper(): return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot; return wrapperdef makeitalic(fn): def wrapper(): return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot; return wrapper@makeitalic@makebolddef hello(): return &quot;hello world&quot;print hello()\b# result: &lt;i&gt;&lt;b&gt;hello world&lt;/b&gt;&lt;/i&gt; 可以看到順序會先包 makeblod 然後再來才是 makeitalic \b執行順序是由下往上 也可以把 decorator 當成是 recurcive 理解 \b# Class 的 \bDecorator Exampleclass entryExit(object): def __init__(self, f): print &#39;entry init enter&#39; self.f = f print &#39;entry init exit&#39; def __call__(self, *args): print &#39;Entering&#39;, self.f.__name__ r = self.f(*args) print &#39;Exit&#39;, self.f.__name__ return r print &#39;decorator using&#39; @entryExit def hello(a): print &#39;inside hello&#39; return &#39;hello world&#39; + a print &#39;test start&#39; print hello(&#39;friends&#39;) &#39;&#39;&#39; result: --------------------- decorator using entry init enter entry init exit test start Entering hello inside hello Exit hello hello worldfriends &#39;&#39;&#39; 比較一開始的函式例子跟後來的類別例子 雖然識別字指的一個是類別 一個是函數 在程式碼中 在函式名後面加上() 變成函式呼叫 而類別本來是不能被呼叫的(not callable) 但加上類別方法__call__之後 就變得可以被呼叫 從程式的結果來看 test start 出現在 entry init exit 的後面 代表在 print &#39;test start&#39; 之前 entryExit 就已實例化 應該就是 @entryExit 這句執行的 當程式執行到 hello(&#39;friend&#39;) 的時候 先進入的是 entryExit 的 __call__ 後來才是 hello 自己的內容 這樣的流程觀察比較清楚 但是 cpython 倒底如何實作這段 這個例子很漂亮的介紹兩件事 第一件事是 decorator 第二件事就是 python 函式與物件之間的巧妙關聯","tags":["Python"],"categories":["Python"]},{"title":"Debugging-Nodejs-With-VSCode","path":"/2017/06/09/Debugging-Nodejs-With-VSCode/","content":"環境 Nodejs - 7.9.10 VSCode - 1.12.2 Download VSCodevscode \b點擊這個 Icon 後再點擊齒輪\b會自動產生 launch.json launch.json123456789101112131415161718192021&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;protocol&quot;: &quot;inspector&quot;, &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/index.js&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;runtimeArgs&quot;: [ &quot;--nolazy&quot;, &quot;--inspect-brk&quot; ], &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;development&quot; &#125; &#125; ]&#125; console - 在Terminal 中啟動程式 env - 設定動態變數，可以傳入程式中使用 runtimeArgs - 動態參數 program - 啟動程式路徑 protocol - npm 8 有兩種不同的protocol , 預設是 legacy 檢查launch.json 開始 debug 後上方會多一條控制 bar 使用 postman 發送 Request 因為我有 console.log 所以在 Debug Console 中會把 login 顯示出來","tags":["Nodejs","VSCode"],"categories":["Javascript"]},{"title":"NodeDesignPatten-06","path":"/2017/05/31/NodeDesignPatten-06/","content":"Design Patten設計模式是關於程式碼重複使用的問題 推薦書籍 Elements of Reusable Object-Oriented Software Pearson Education Gang of Four (GoF) Design Pattern List Factory Revealing constructor Proxy Decorator Adapter Strategy State Template Middleware Command Factory在 Javascript 中 設計通常以可用，簡單並且模組化開發為主旨 而使用 Factory 則可以在物件導向上包覆一層 Wrapper 使用上可以更加彈性 在 Factory 中可以透過 Object.create() 來建立一個物件 或是利用特定的條件來建立不同的物件 Examplefactory.js 123456789101112131415161718192021const ImageJpeg = require(&#x27;./imageJpeg&#x27;);const ImageGif = require(&#x27;./imageGif&#x27;);const ImagePng = require(&#x27;./imagePng&#x27;);function createImage(name) &#123; if (name.match(/\\.jpe?g$/)) &#123; return new ImageJpeg(name); &#125; else if (name.match(/\\.gif$/)) &#123; return new ImageGif(name); &#125; else if (name.match(/\\.png$/)) &#123; return new ImagePng(name); &#125; else &#123; throw new Exception(&#x27;Unsupported format&#x27;); &#125;&#125;const image1 = createImage(&#x27;photo.jpg&#x27;);const image2 = createImage(&#x27;photo.gif&#x27;);const image3 = createImage(&#x27;photo.png&#x27;);console.log(image1, image2, image3); imageJpeg.js 123456789101112&quot;use strict&quot;;const Image = require(&#x27;./image&#x27;);module.exports = class ImageJpg extends Image &#123; constructor(path) &#123; if (!path.match(/\\.jpe?g$/)) &#123; throw new Error(`$&#123;path&#125; is not a JPEG image`); &#125; super(path); &#125;&#125;; imagePng.js 123456789101112&quot;use strict&quot;;const Image = require(&#x27;./image&#x27;);module.exports = class ImagePng extends Image &#123; constructor(path) &#123; if (!path.match(/\\.png$/)) &#123; throw new Error(`$&#123;path&#125; is not a PNG image`); &#125; super(path); &#125;&#125;; imageGif.js 123456789101112&quot;use strict&quot;;const Image = require(&#x27;./image&#x27;);module.exports = class ImageGif extends Image &#123; constructor(path) &#123; if (!path.match(/\\.gif/)) &#123; throw new Error(`$&#123;path&#125; is not a GIF image`); &#125; super(path); &#125;&#125;; 封裝封裝是防止某些程式碼被外部直接飲用或更改時使用 也稱為訊息隱藏 而 Javascript 常用 Closure 來實現 Example12345678910111213141516function createPerson(name) &#123; const privateProperties = &#123;&#125;; const person = &#123; setName: name =&gt; &#123; if (!name) throw new Error(&#x27;A person must have a name&#x27;); privateProperties.name = name; &#125;, getName: () =&gt; privateProperties.name &#125;; person.setName(name); return person;&#125;const person = createPerson(&#x27;Tomas Lin&#x27;);console.log(person.getName(), person); 此範例中的person 只有透過 setName與 getName可以對person 取值與修改 123456789使用 Factory 只是其中一個方式另外也有不成文約定在function 前加上 **_** 或 **$**但是這樣依舊可以在外部呼叫另外也可以使用 [WeakMap](http://fitzgeraldnick.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html) 建立一個完整的 Factory Demoprofiler.js 1234567891011121314151617181920212223242526272829class Profiler &#123; constructor(label) &#123; this.label = label; this.lastTime = null; &#125; start() &#123; this.lastTime = process.hrtime(); &#125; end() &#123; const diff = process.hrtime(this.lastTime); console.log( `Timer &quot;$&#123;this.label&#125;&quot; took $&#123;diff[0]&#125; seconds and $&#123;diff[1]&#125; nanoseconds.` ); &#125;&#125;module.exports = function (label) &#123; if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; return new Profiler(label); //[1] &#125; else if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; return &#123; //[2] start: function () &#123; &#125;, end: function () &#123; &#125; &#125; &#125; else &#123; throw new Error(&#x27;Must set NODE_ENV&#x27;); &#125;&#125; profilerTest.js 1234567891011121314const profiler = require(&#x27;./profile&#x27;);function getRandomArray(len) &#123; const p = profiler(`Generating a $&#123;len&#125; items long array`); p.start(); const arr = []; for (let i = 0; i &lt; len; i++) &#123; arr.push(Math.random()); &#125; p.end();&#125;getRandomArray(1e6);console.log(&#x27;Done&#x27;); 1$ NODE_ENV=development node profilerTest 1$ NODE_ENV=production node profilerTest 組合工廠利用遊戲的方式來解說 通常一種遊戲會有多種角色 每種角色會擁有各自不同的基本能力 Runner: 可移動 Samurai: 可移動並且攻擊 Sniper: 可射擊但不可移動 Gunslinger: 可移動並且射擊 Western Samurai: 可以移動 攻擊 並射擊 希望上述可以自由地互相結合 所以不能使用 Class 或是 inheritance 來解決 Example使用套件stampit","tags":["Nodejs","DesignPatten"],"categories":["Designpatten"]},{"title":"RabbitMQ-Routing","path":"/2017/05/27/RabbitMQ-Routing/","content":"Routing\b之前完成了 fanout 的 logging system 但是我們不希望每一則訊息都會通知到每一個人 也希望會有一些特定的訊息推送 這時就可以利用 direct 來做訊息的發送 \b可是 direct 並沒有辦法做到多個條件分類 Route 因為不希望 logging system 只能依據嚴重性來發送訊息 例如 unix 中的 syslog 中就可以依據嚴重性或是設備其他條件來發訊息傳遞 會更加彈性化 此時為了要達到這個需要 必須使用較為複雜的 topic exchange Topic Exchange當訊息發送到 topic exchage 的時候 route_key 是由多個字使用 . 來做分隔組成 這些字也不是隨意選定 通常都代表著 \bfeatures Example: “stock.usd.nyse” “nyse.vmw” “quick.orange.rabbit”. 上述都是可以當成 Routing 的範例 最多可以接受 255 bytes 的大小 ##\b# Binding Key \b可以有兩種特別的綁定方式 \b* ‘*’ (star) 可以取代一個字 ‘#’ (hash) 可以取代零或多個字 Example範例中我們發送關於描述動物的訊息 \b訊息將會以三個字(兩個.)的方式來發送 第一個字描述速度 第二個字描述描述顏色 第三個描述種類 \b建立建立三種不同的 Binding key “.orange.“ \b&#x2F;&#x2F;所有橘色的動物 “..rabbit” &#x2F;&#x2F; 所有兔子類的動物 “lazy.#” &#x2F;&#x2F; 所有 lazy 的動物 若發送一個 “quick.orange.rabbit” 會發送給兩個 Queue “lazy.orange.elephone” 也會發送給兩個 Queue “quick.orange.fox” 只會發送給一個 Queue “quick.brown.fox” 則不會發送給任何 Queue 而被棄用 若我們發送單一字節 如”Orange” 這些都不會符合 binding routing 發送四個字節 “quick.orange.male.rabbit” 因為最後一個字節有符合 將會被傳到第二個 Queue \b&#96;&#96;&#96;Topic Exchange \bTopic Exchange 是相當強大的 Exchange 而且可以模仿其他不同的 Exchange 如果有你使用 \b”#” 則可以取得所有 Exchange 效果就如同 fanout 若是沒有使用 “*”, “#” 來做 Routing 效果則是如同 direct一樣 Putting it all togetheremit_log_topic.js12345678910111213141516const amqp = require(&#x27;amqplib/callback_api&#x27;);amqp.connect(&#x27;amqp:localhost&#x27;, function (err, conn) &#123; conn.createChannel(function (err, ch) &#123; const ex = &#x27;topic_logs&#x27;; const args = process.argv.slice(2); const key = (args.length &gt; 0) ? args[0] : &#x27;anonymous.info&#x27;; const msg = args.slice(1).join(&#x27; &#x27;) || &#x27;Hello World&#x27;; ch.assertExchange(ex, &#x27;topic&#x27;, &#123; durable: false &#125;); ch.publish(ex, key, new Buffer(msg)); console.log(&quot; [x] Sent %s:&#x27;%s&#x27;&quot;, key, msg); &#125;); setTimeout(function () &#123; conn.close(); process.exit(0) &#125;, 500);&#125;); receive_logs_topic.js1234567891011121314151617181920212223242526272829const amqp = require(&#x27;amqplib/callback_api&#x27;);const args = process.argv.slice(2);if (args.length === 0) &#123; console.log(&quot;Usage: receive_logs_topic.js &lt;facility&gt;.&lt;severity&gt;&quot;); process.exit(1);&#125;amqp.connect(&#x27;amqp://localhost&#x27;, function (err, conn) &#123; console.log(err); conn.createChannel(function (err, ch) &#123; const ex = &#x27;topic_logs&#x27;; ch.assertExchange(ex, &#x27;topic&#x27;, &#123; durable: false &#125;); ch.assertQueue(&#x27;&#x27;, &#123; exclusive: true &#125;, function (err, q) &#123; console.log(&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;); args.forEach(function (key) &#123; ch.bindQueue(q.queue, ex, key); &#125;); ch.consume(q.queue, function (msg) &#123; console.log(&quot; [x] %s:&#x27;%s&#x27;&quot;, msg.fields.routingKey, msg.content.toString()); &#125;, &#123; noAck: true &#125;); &#125;); &#125;);&#125;);","tags":["Nodejs","MessageQueue"],"categories":["RabbitMQ"]},{"title":"RabbitMQ-PublishAndSubscribe","path":"/2017/05/26/RabbitMQ-PublishAndSubscribe/","content":"Publish and Subscribe為了說明發布與訂閱 我們將會建立一個簡單的 log system 這包含了兩隻程式 一隻會發布 log 另一隻則會接收並且 print 在 console上 \b\b若我們有多個接收的程式 他們就都會接收到同樣的訊息 如此的話 我們就可以一個程式在接收到 Log 後寫入檔案 另一個接收到 Log 則將訊息顯示在螢幕上 也就是說也就是說發布的訊息將會被所有接收者接收 Exchanges我們之前教學的內容 \b生產者負責發送訊息 Queue 是任務的暫存區 客戶是負責接收訊息 \b\bRabbitMQ 的核心是生產者不直接發送任何訊息進入Queue 甚至也不知道 Message 發送後會進入哪一個Queue \b生產者只需要將 Message 發送給 Exchange 就好了 Exchange 必須十分清楚接收到了訊息之後要如何處理 加入特定的 Queue? 加到多個 Queue? 或是應該捨棄 規則則由 Exchange type 定義 有幾種 \bExchange type 可以使用 Direct Topic headers fanout \b這個範例是以 fanout 為主 先建立一個 \bfanout 類型的 type 命名為 log 1ch.assertExchange(&#x27;logs&#x27;, &#x27;fanout&#x27;, &#123;durable: false&#125;); fanout 主要就是廣播給所有的 channel 知道 \b很適合這次的 Log 範例 123456789//Listing exchanges列出可以使用的 Exchange type 可以使用命令列查詢 \b$ sudo rabbitmqctl list_exchanges列表會顯示 amq.*發送預設的 Exchange 1ch.sendToQueue(&#x27;hello&#x27;, new Buffer(&#x27;Hello World!&#x27;)); 我們發送一個 訊息 1ch.publish(&#x27;logs&#x27;, &#x27;&#x27;, new Buffer(&#x27;Hello World!&#x27;)); 第二個值給空字串代表我們沒有要發送給其他 chaneel, 只有要發送給 log Temporary queues可以將 Queue 定義一個 name 而 producers 要與 consumers 要共享時 就可以依據 name 做為指定 Queue 的依據 而對於每一個 Queue 重視的是當前的訊息 對於已經取得過的訊息並不重視 所以我們在取得一個新的 Queue 時有兩個事情是很重要的 初始化必須是空的一個 Queue 所有連結者斷線後，必須刪掉Queue Binding剛剛有建立了一個 fanout 的 channel 名為 log 現在我們希望告訴這個 log 有訊息的時候可以通知我 這個行為叫做 binding 1ch.bindQueue(queue_name, &#x27;logs&#x27;, &#x27;&#x27;); 123# 可以列出目前有binding 的 queue listrabbitmqctl list_bindings Exampleemeit_log.js1234567891011121314const amqp = require(&#x27;amqplib/callback_api&#x27;);amqp.connect(&#x27;amqp://localhost&#x27;, function (err, conn) &#123; conn.createChannel(function (err, ch) &#123; var ex = &#x27;logs&#x27;; var msg = process.argv.slice(2).join(&#x27; &#x27;) || &#x27;Hello World!&#x27;; ch.assertExchange(ex, &#x27;fanout&#x27;, &#123; durable: false &#125;); ch.publish(ex, &#x27;&#x27;, new Buffer(msg)); console.log(&quot; [x] Sent %s&quot;, msg); &#125;); setTimeout(function () &#123; conn.close(); process.exit(0) &#125;, 500);&#125;); recive_log.js123456789101112131415161718var amqp = require(&#x27;amqplib/callback_api&#x27;);amqp.connect(&#x27;amqp://localhost&#x27;, function (err, conn) &#123; conn.createChannel(function (err, ch) &#123; var ex = &#x27;logs&#x27;; ch.assertExchange(ex, &#x27;fanout&#x27;, &#123; durable: false &#125;); ch.assertQueue(&#x27;&#x27;, &#123; exclusive: true &#125;, function (err, q) &#123; console.log(&quot; [*] Waiting for messages in %s. To exit press CTRL+C&quot;, q.queue); ch.bindQueue(q.queue, ex, &#x27;&#x27;); ch.consume(q.queue, function (msg) &#123; console.log(&quot; [x] %s&quot;, msg.content.toString()); &#125;, &#123; noAck: true &#125;); &#125;); &#125;);&#125;);","tags":["Nodejs","MessageQueue"],"categories":["RabbitMQ"]},{"title":"RabbitMQ-WorkQueue","path":"/2017/05/24/RabbitMQ-WorkQueue/","content":"Work Queues避免一些佔用大量資源或是時間的工作， 我們幫每份工作定義一個 channel 透過 MessageQueue 發送文字訊息 通知增加一個 Task 而 Queue 會自動在未來某個時間點處理這件事情 Round-robin dispatching使用任務隊列的優點之一是能夠輕鬆地併行工作 如果我們正在建立許多的的工作 我們可以增加更多的worker 這樣可以輕易地擴充架構 範例下列的範例可以開三個 Terminal console 兩個執行 work.js 而一個執行 new_task.js 12# shell 1 $ node worker.js 1$ node worker.js 在第三個我們將發布新的任務 一旦您開始使用消費者 您可以發布一些消息 123456# shell 3./new_task.js First message../new_task.js Second message.../new_task.js Third message..../new_task.js Fourth message...../new_task.js Fifth message..... 執行結果 123456# shell 1./worker.js# =&gt; [*] Waiting for messages. To exit press CTRL+C# =&gt; [x] Received &#x27;First message.&#x27;# =&gt; [x] Received &#x27;Third message...&#x27;# =&gt; [x] Received &#x27;Fifth message.....&#x27; 12345# shell 2./worker.js# =&gt; [*] Waiting for messages. To exit press CTRL+C# =&gt; [x] Received &#x27;Second message..&#x27;# =&gt; [x] Received &#x27;Fourth message....&#x27; Message acknowledgment如果有一個長時間的任務 在執行過程中 crash 我們將會失去這個執行的任務 但是我們不希望失去任務 所以我們可以把任務交給其他的 worker 為了確保任務不會消失 所以提供了 Message acknowledgment (消息確認) 若是 worker Crash 連接關閉或 TCP 連接結束 並不發送確認訊息 RabbitMQ 將會重新排隊 若有其他 worker 則會將任務轉給其他 worker 所以即使有長時間執行的任務 也會確保該任務執行完成不會丟失 在上一個例子中 消息確認功能被關閉 ** {noAck: false} ** 123456789ch.consume(q, function(msg) &#123; var secs = msg.content.toString().split(&#x27;.&#x27;).length - 1; console.log(&quot; [x] Received %s&quot;, msg.content.toString()); setTimeout(function() &#123; console.log(&quot; [x] Done&quot;); ch.ack(msg); &#125;, secs * 1000);&#125;, &#123;noAck: false&#125;); 上述範例可以確認任務會執行 若 worker Crash 也會把任務重新執行 123456789101112131415忘記確認錯過這個錯誤是一個常見的錯誤這是一個容易的錯誤但後果是嚴重的當您的客戶端退出（可能看起來像隨機重新傳遞）時消息將被重新傳遞但是RabbitMQ將會消耗越來越多的內存因為它將無法釋放任何未包含的消息 Message durability我們已經學會瞭如何確保即使 worker Crash 任務也不會丟失 但是如果RabbitMQ服務器停止 我們的任務仍然會丟失 當RabbitMQ退出或崩潰時 它會忘記隊列和消息 需要兩件事來確保消息不會丟失：我們需要將 Queue 和消息 durable 設定為 true 1ch.assertQueue(&#x27;hello&#x27;, &#123;durable: true&#125;); 雖然這個命令本身是正確的 但是在我們目前的設置中是不行的 這是因為我們已經定義了一個不耐用的名為 hello 的隊列。 RabbitMQ 不允許您重新定義具有不同參數的現有隊列 並會向嘗試執行此操作的任何程序返回錯誤 但是有一個快速的解決方法 - 讓我們用不同的名稱聲明一個隊列 例如task_queue 1ch.assertQueue(&#x27;task_queue&#x27;, &#123;durable: true&#125;); 這種持久的選項更改需要適用於 new_task 和 worker代碼。 在這一點上 我們確信 即使RabbitMQ重新啟動 task_queue Queue也不會丟失 現在我們需要使用持久化選項 Channel.sendToQueue 來將消息標記為持久性 1ch.sendToQueue(q, new Buffer(msg), &#123;persistent: true&#125;); 1234567891011121314151617181920212223注意消息持久性將消息標記為持久性不能完全保證消息不會丟失雖然它告訴RabbitMQ將消息保存到硬碟但是當RabbitMQ接受消息並且還沒有保存時仍然有一個很短的時間窗口RabbitMQ不會對每個消息執行fsync（2） - 它可能只是保存到緩存中而不是真正寫入磁盤持久性保證不強但對我們的簡單任務隊列來說已經足夠了如果您需要更強大的保證那麼您可以使用發布商確認 Fair dispatch您可能已經注意到 dispatching 仍然無法正常工作 例如在兩個 worker 的情況下 當所有奇怪的信息都很消耗資源與時間 甚至信息很小的時候 一個worker將不斷忙碌 另一個worker幾乎不會做任何工作 那麼 RabbitMQ 還會平均分配消息 這是因為當消息進入隊列時 RabbitMQ只會分派消息 它不看 sender 的未確認消息的數量 它只是盲目地向第n個 sender 發送每個第n個消息。 1ch.prefetch(1); 12345678910注意 Queue大小如果所有的 **worker** 都忙你的Queue可以填滿你會想要注意的是也許增加更多的 worker 或者有其他的策略 Server1234567891011121314151617181920const amqp = require(&#x27;amqplib/callback_api&#x27;);amqp.connect(&#x27;amqp://localhost&#x27;, function (err, conn) &#123; conn.createChannel(function (err, ch) &#123; var q = &#x27;task&#x27;; ch.assertQueue(q, &#123; durable: true &#125;); console.log(&quot; [*] Waiting for messages in %s. To exit press CTRL+C&quot;, q); ch.consume(q, function (msg) &#123; var secs = msg.content.toString().split(&#x27;.&#x27;).length - 1; console.log(&quot; [x] Received %s&quot;, msg.content.toString()); setTimeout(function () &#123; console.log(&quot; [x] Done&quot;); ch.ack(msg); &#125;, secs * 1000); &#125;, &#123; noAck: false &#125;); &#125;);&#125;); Clientnew_task.js 12345678910111213const amqp = require(&#x27;amqplib/callback_api&#x27;);amqp.connect(&#x27;amqp://localhost&#x27;, function (err, conn) &#123; conn.createChannel(function (err, ch) &#123; const q = &#x27;task&#x27;; const msg = process.argv.slice(2).join(&#x27; &#x27;) || &#x27;Hello world!&#x27;; ch.assertQueue(q, &#123; durable: true &#125;); ch.sendToQueue(q, new Buffer(msg), &#123; persistent: true &#125;); console.log(&quot; [x] Sent &#x27;%s&#x27;&quot;, msg); &#125;); setTimeout(function () &#123; conn.close(); process.exit(0) &#125;, 500);&#125;);","tags":["Nodejs","MessageQueue"],"categories":["RabbitMQ"]},{"title":"RabbitMQ-Install","path":"/2017/05/22/RabbitMQ-Install/","content":"Rabbit Message QueueInstalling on HomebrewStep 11$ brew update Step 21$ brew install rabbitmq Step 31$ rabbitmqctl status ExampleClientsend.js 1234567891011121314const amqp = require(&#x27;amqplib/callback_api&#x27;);amqp.connect(&#x27;amqp://localhost&#x27;, function (err, conn) &#123; conn.createChannel((err, ch) =&gt; &#123; const q = &#x27;hello&#x27;; const msg = &#x27;Hello World!&#x27;; ch.assertQueue(q, &#123; durable: false &#125;); ch.sendToQueue(q, new Buffer(&#x27;Hello world&#x27;)); console.log(&quot; [x] Sent &#x27;Hello World!&#x27;&quot;); &#125;); setTimeout(function () &#123; conn.close(); process.exit(0) &#125;, 500);&#125;); Serverreceive.js 12345678910111213const amqp = require(&#x27;amqplib/callback_api&#x27;);amqp.connect(&#x27;amqp://localhost&#x27;, function (err, conn) &#123; conn.createChannel((err, ch) =&gt; &#123; const q = &#x27;hello&#x27;; const msg = &#x27;Hello World!&#x27;; ch.assertQueue(q, &#123; durable: false &#125;); ch.sendToQueue(q, new Buffer(&#x27;Hello world&#x27;)); &#125;); setTimeout(function () &#123; conn.close(); process.exit(0) &#125;, 500);&#125;); Result 參考文章install","tags":["Nodejs","MessageQueue"],"categories":["RabbitMQ"]},{"title":"Leetcode-Q6","path":"/2017/05/09/Leetcode-Q6/","content":"12 Integer to RomanDescriptionGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 這是進制的轉換 要將十進位進位轉換成羅馬數字 數字的範圍在1~3999 關於羅馬數字的規則 羅馬數字總共會有七個 Ⅰ（1）、Ⅴ（5）、Ⅹ（10）、Ⅼ（50）、Ⅽ（100）、Ⅾ（500）和Ⅿ（1000） 重複數次：一個羅馬數字重複幾次，就表示這個數的幾倍 Example1234567891011121314const intToRoman = function (num) &#123; if (num &lt; 1 || num &gt; 3999) &#123; return &#x27;&#x27;; &#125; const lookup = &#123; M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 &#125;; let romanStr = &#x27;&#x27;; for (const key in lookup) &#123; while (num &gt;= lookup[key]) &#123; romanStr += key; num -= lookup[key]; &#125; &#125; return romanStr;&#125;; 因為有規範在1~3999之間 所以先檢查 num 是否在這個區間 若不在的話則回傳空字串 先用一個物件將羅馬數字設為Key與十進位數字設為Value 準備等等做比對計算 然後使用一個迴圈依序對此物件中的各值去做轉換 在迴圈中加上一個 while 迴圈 當值比較大的時候 代表它可以在轉換一次 所以在romanStr中加上一次符號 num 在扣除相對的value 直到num為零為止 此時romanStr就是相對應的羅馬字串 回傳後就可以解答","tags":["Javascript","Leetcode"],"categories":["Leetcode"]},{"title":"Leetcode-Q5","path":"/2017/05/09/Leetcode-Q5/","content":"561 Array Partition IDescriptionGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. 一個 2n 個整數的陣列 將這些整入分成N對整數 (a1, a2), (b1, b2)….. 並使(ai, bi)的最大總和數 Hint將陣列做排序 然後切個 n 個陣列 每個陣列兩個元素 再把各自陣列的第二個元素相加 就可以得到答案 Example123456nums = nums.sort((a, b) =&gt; (a - b)); let total = 0; for (let index = 0; index &lt; nums.length; index += 2) &#123; total += nums[index]; &#125; return total;","tags":["Javascript","Leetcode"],"categories":["Leetcode"]},{"title":"Leetcode-Q4","path":"/2017/05/07/Leetcode-Q4/","content":"9 Palindrome Number迴文數wiki Example12345678910111213141516171819202122232425const INT_MAX = 2147483647;let y = 0;if (x &gt; 0 &amp;&amp; x &lt; 10) &#123; return true;&#125; else &#123; let str = x.toString(), length = str.length, total = 0; for (let index = 0; index &lt; length; index++) &#123; let num = parseInt(str[index]) * Math.pow(10, index); total += num; &#125; if (total &gt; INT_MAX || total &lt; -(1 + INT_MAX) || x &gt; INT_MAX || x &lt; -(1 + INT_MAX)) &#123; return false; &#125; else if (total === x) &#123; return true; &#125; else &#123; return false; &#125;&#125; 這一題的原理跟上一題 Reverse Integer 原理類似 在翻轉變數之後 比對是否相等 若是相等就回傳 true 不相等就回傳 false","tags":["Javascript","Leetcode"],"categories":["Leetcode"]},{"title":"Leetcode-Q3","path":"/2017/05/06/Leetcode-Q3/","content":"7 Reverse IntegerExampleExample1: x &#x3D; 123, return 321 Example2: x &#x3D; -123, return -321 解題Version 1第一個想到的方式就是先用字串的方式 12345678910111213141516171819202122var reverse = function (x) &#123; const INT_MAX = 2147483647; const isNegativeNumber = (x &lt; 0) ? true : false, y = Math.abs(x).toString().split(&#x27;&#x27;) length = y.length; let result = []; for (let i = 0; i &lt; length; i++) &#123; result.push(y.pop()); &#125; let total = parseInt(result.join(&#x27;&#x27;)); total = isNegativeNumber ? (0 - total) : total; if (total &gt; INT_MAX || total &lt; -(1 + INT_MAX)) &#123; return 0; &#125; else &#123; return total; &#125;&#125;; 我先確定他是否為負數 然後把數字轉絕對值 切一維陣列 在使用for 迴圈來迴轉 最後檢查是否有超出32 bit與回傳正負總值 但是這樣的效能實在欠佳 Version 212345678910111213141516171819202122var reverse = function (x) &#123; if (x &gt;= 0 &amp;&amp; x &lt; 10) &#123; return x; &#125; const INT_MAX = 2147483647; const isNegativeNumber = (x &lt; 0) ? true : false, y = Math.abs(x).toString().split(&#x27;&#x27;), length = y.length; let total = 0; y.map((v, index) =&gt; &#123; const value = parseInt(v) * Math.pow(10, index); total += value; &#125;) total = isNegativeNumber ? (0 - total) : total; if (total &gt; INT_MAX || total &lt; -(1 + INT_MAX)) &#123; return 0; &#125; else &#123; return total; &#125;&#125;; 第二種方式其實跟第一種大同小異 只是我是利用數字十進位數的方式 使用迴圈加回去一個值 最後再檢查是否有超出32 bit 因為使用數字計算 所以效能提昇了不少 最高衝到了51 % 不過還是略有欠缺 若有其他解法再來更新","tags":["Javascript","Leetcode"],"categories":["Leetcode"]},{"title":"Leetcode-Q2","path":"/2017/05/05/Leetcode-Q2/","content":"1 Two sumFirst solution123456789101112131415161718var twoSum = function(nums, target) &#123; var index, index2 = -1, i = 0; while(index === undefined)&#123; var num = nums[i], need = target - num; index2 = nums.indexOf(need) if(index2 === i)&#123; index = undefined; index2 = -1 &#125;else if(index2 !== -1)&#123; index = i; &#125; i++; &#125; return [index, index2];&#125;; 因為是兩層的巢狀迴圈 加上有兩個 if 判斷式 所以效能會很差 1234567891011121314var twoSum = function(nums, target) &#123; var map = &#123;&#125;; for(var i = 0 ; i &lt; nums.length ; i++)&#123; var v = nums[i]; for(var j = i+1 ; j &lt; nums.length ; j++ )&#123; if( nums[i] + nums[j] == target )&#123; return [i,j]; &#125; &#125; &#125;&#125;; 因為是兩層的巢狀迴圈 加上有一個 if 判斷式 所以效能好一點 但還是不理想 1234567891011121314var map = &#123;&#125;;for(var i = 0 ; i &lt; nums.length ; i++)&#123; var v = nums[i]; if(map[target-v] &gt;= 0)&#123; // 如果 target - v可以在map中找到值x，代表之前已經出現過值x， target = x + v // 因此回傳 x的位置與目前v的位置 return [map[target-v],i] &#125; else &#123; // 使用map儲存目前的數字與其位置 map[v] = i; &#125;&#125; 僅僅使用一層迴圈 若沒有找到的話就會記錄在 map 中 所以效能提升不少","tags":["Javascript","Leetcode"],"categories":["Leetcode"]},{"title":"Leetcode-Q1","path":"/2017/05/03/Leetcode-Q1/","content":"538 Convert BST to Greater TreeDescriptionGiven a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. 1輸入一個Binary Search Tree(BST), 將每一個節點得值更改為原始的值加上加上大於BST中 Node 的值的總和 Example123456789Input: The root of a Binary Search Tree like this: 5 / \\ 2 13Output: The root of a Greater Tree like this: 18 / \\ 20 13 1234567891011121314151617181920212223 var convertBST = function(root) &#123; var vals = []; var count = 0; function visit1(root)&#123; if(root)&#123; visit1(root.left); vals.push(root.val); visit1(root.right); &#125; &#125; visit1(root); function visit2(root)&#123; if(root)&#123; visit2(root.right); count += vals.pop(); root.val = count; visit2(root.left); &#125; &#125; visit2(root); return root;&#125; Notevisit1: 利用遞迴將 Node 往下延伸到最左邊子元素的時候依序push 到陣列中 visit2: 利用遞迴將 Node 往下延伸到最右邊的子元素依序將 value 修改為加總得值 利用二元樹的特性來做輪巡並修改值","tags":["Javascript","Leetcode"],"categories":["Leetcode"]},{"title":"NodeDesignPatten-01","path":"/2017/04/29/NodeDesignPatten-01/","content":"Welcome to the Node.js PlatformSmall modules* NPM * 提供一個共同的Module 下載平台 * 分享彼此的模組，節省時間 * DRY(Don&#39;t Reapt yourself) * 小型的模組 * 易於維護與測試 * 做好一件事情就好 * 避免使用Global變數造成套件之間衝突 * 容易被理解 * package.json * 解決依賴性地獄的問題 * 版本控制 Introduction to Node.js 6 and ES2015ES6 瀏覽器支援現況 1strict mode is enbend strict mode The arrow functiontry it out Class syntax ES5 沒有 Class ES5 prototype ES5 prototype.call constructor super Enhanced object literalsobject object - 沒有順序的集合 key - 為英文或數字_ 的集合 value - 可以是任何類型的變數(string, number, boolean…) array array - 有順序的集合 key - 從0 開始依序往上遞增 value - 可以是任何類型的變數(string, number, boolean…) seter and geter Getter Setter Map and Set collectionsMap Set key 與 value的配對 當key刪除的時候，記憶體會自動被Realse? WeakMap and WeakSet collectionsstartwordflow 討論 weakmap Template literals字串組合方式 123var lastname = &#x27;Tomas&#x27;;var firstname = &#x27;Lin&#x27;;var fullname = firstname +&#x27; &#x27; + lastname; 123var lastname = &#x27;Tomas&#x27;;var firstname = &#x27;Lin&#x27;;var fullname = `$&#123;firstname&#125; $&#123;lastname&#125;`;","tags":["Nodejs","DesignPatten"],"categories":["Designpatten"]},{"title":"關於我","path":"/about/index.html","content":"工作經驗 Full-Stack DeveloperAdenovo Integral Institute Co., Ltd. Build a web for app.imrenter.com Build a admin for app.imrenter.com Develop serverless API March 2018 – Now Front-end DeveloperTaiwin Integral Institute Co., Ltd.December 2015 – August 2017 Build a File control APP with React Native Build an Email APP with React Native Back-end DeveloperEasyApp Integral Institute Co. Ltd.July 2014 – November 2015 Shoppingcar Web API with Express and MongoDB. Admin System with React. Software EnginnerOSS Integral Institute Co. Ltd.March 2011 - January 2014exam system User could create a new exam for students with Flask and MongoDB. Convert pdf to epub3 and open it with node-webkit Education Mechanical EnginneringFar East UniversitySeptember 2001 – July 2006 專長 Python MongoDB Nodejs React Native React Technical Experience Taipei.py speaker - Flask and MongoDB Introl (2014.01.23) 2014 JSDC core Member 2015 Taichang Front-end Group Speaker React Native Introl React and Flux Happy Coding with React 2016 Taichang Front-end Group Speaker Bome in React Native 2016 JSDC Speaker - dispatch route like web uri 2016 CTJS Manager"}]